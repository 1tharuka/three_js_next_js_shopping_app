"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-it";
exports.ids = ["vendor-chunks/get-it"];
exports.modules = {

/***/ "(ssr)/./node_modules/get-it/dist/_chunks-es/_commonjsHelpers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks-es/_commonjsHelpers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   g: () => (/* binding */ getDefaultExportFromCjs),\n/* harmony export */   p: () => (/* binding */ processOptions),\n/* harmony export */   v: () => (/* binding */ validateOptions)\n/* harmony export */ });\nconst isReactNative = typeof navigator > \"u\" ? !1 : navigator.product === \"ReactNative\", defaultOptions = { timeout: isReactNative ? 6e4 : 12e4 }, processOptions = function(opts) {\n  const options = {\n    ...defaultOptions,\n    ...typeof opts == \"string\" ? { url: opts } : opts\n  };\n  if (options.timeout = normalizeTimeout(options.timeout), options.query) {\n    const { url, searchParams } = splitUrl(options.url);\n    for (const [key, value] of Object.entries(options.query)) {\n      if (value !== void 0)\n        if (Array.isArray(value))\n          for (const v of value)\n            searchParams.append(key, v);\n        else\n          searchParams.append(key, value);\n      const search = searchParams.toString();\n      search && (options.url = `${url}?${search}`);\n    }\n  }\n  return options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase(), options;\n};\nfunction splitUrl(url) {\n  const qIndex = url.indexOf(\"?\");\n  if (qIndex === -1)\n    return { url, searchParams: new URLSearchParams() };\n  const base = url.slice(0, qIndex), qs = url.slice(qIndex + 1), searchParams = new URLSearchParams(qs);\n  if (typeof searchParams.set == \"function\")\n    return { url: base, searchParams };\n  if (typeof decodeURIComponent != \"function\")\n    throw new Error(\n      \"Broken `URLSearchParams` implementation, and `decodeURIComponent` is not defined\"\n    );\n  const params = new URLSearchParams();\n  for (const pair of qs.split(\"&\")) {\n    const [key, value] = pair.split(\"=\");\n    key && params.append(decodeQueryParam(key), decodeQueryParam(value || \"\"));\n  }\n  return { url: base, searchParams: params };\n}\nfunction decodeQueryParam(value) {\n  return decodeURIComponent(value.replace(/\\+/g, \" \"));\n}\nfunction normalizeTimeout(time) {\n  if (time === !1 || time === 0)\n    return !1;\n  if (time.connect || time.socket)\n    return time;\n  const delay = Number(time);\n  return isNaN(delay) ? normalizeTimeout(defaultOptions.timeout) : { connect: delay, socket: delay };\n}\nconst validUrl = /^https?:\\/\\//i, validateOptions = function(options) {\n  if (!validUrl.test(options.url))\n    throw new Error(`\"${options.url}\" is not a valid URL`);\n};\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x.default : x;\n}\n\n//# sourceMappingURL=_commonjsHelpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy1lcy9fY29tbW9uanNIZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDRHQUE0RyxxQ0FBcUM7QUFDako7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUksR0FBRyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBS0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MtZXMvX2NvbW1vbmpzSGVscGVycy5qcz80MDIzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yID4gXCJ1XCIgPyAhMSA6IG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIlJlYWN0TmF0aXZlXCIsIGRlZmF1bHRPcHRpb25zID0geyB0aW1lb3V0OiBpc1JlYWN0TmF0aXZlID8gNmU0IDogMTJlNCB9LCBwcm9jZXNzT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi50eXBlb2Ygb3B0cyA9PSBcInN0cmluZ1wiID8geyB1cmw6IG9wdHMgfSA6IG9wdHNcbiAgfTtcbiAgaWYgKG9wdGlvbnMudGltZW91dCA9IG5vcm1hbGl6ZVRpbWVvdXQob3B0aW9ucy50aW1lb3V0KSwgb3B0aW9ucy5xdWVyeSkge1xuICAgIGNvbnN0IHsgdXJsLCBzZWFyY2hQYXJhbXMgfSA9IHNwbGl0VXJsKG9wdGlvbnMudXJsKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgY29uc3Qgc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAgICBzZWFyY2ggJiYgKG9wdGlvbnMudXJsID0gYCR7dXJsfT8ke3NlYXJjaH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnMubWV0aG9kID0gb3B0aW9ucy5ib2R5ICYmICFvcHRpb25zLm1ldGhvZCA/IFwiUE9TVFwiIDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLnRvVXBwZXJDYXNlKCksIG9wdGlvbnM7XG59O1xuZnVuY3Rpb24gc3BsaXRVcmwodXJsKSB7XG4gIGNvbnN0IHFJbmRleCA9IHVybC5pbmRleE9mKFwiP1wiKTtcbiAgaWYgKHFJbmRleCA9PT0gLTEpXG4gICAgcmV0dXJuIHsgdXJsLCBzZWFyY2hQYXJhbXM6IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSB9O1xuICBjb25zdCBiYXNlID0gdXJsLnNsaWNlKDAsIHFJbmRleCksIHFzID0gdXJsLnNsaWNlKHFJbmRleCArIDEpLCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzKTtcbiAgaWYgKHR5cGVvZiBzZWFyY2hQYXJhbXMuc2V0ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4geyB1cmw6IGJhc2UsIHNlYXJjaFBhcmFtcyB9O1xuICBpZiAodHlwZW9mIGRlY29kZVVSSUNvbXBvbmVudCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJCcm9rZW4gYFVSTFNlYXJjaFBhcmFtc2AgaW1wbGVtZW50YXRpb24sIGFuZCBgZGVjb2RlVVJJQ29tcG9uZW50YCBpcyBub3QgZGVmaW5lZFwiXG4gICAgKTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgcXMuc3BsaXQoXCImXCIpKSB7XG4gICAgY29uc3QgW2tleSwgdmFsdWVdID0gcGFpci5zcGxpdChcIj1cIik7XG4gICAga2V5ICYmIHBhcmFtcy5hcHBlbmQoZGVjb2RlUXVlcnlQYXJhbShrZXkpLCBkZWNvZGVRdWVyeVBhcmFtKHZhbHVlIHx8IFwiXCIpKTtcbiAgfVxuICByZXR1cm4geyB1cmw6IGJhc2UsIHNlYXJjaFBhcmFtczogcGFyYW1zIH07XG59XG5mdW5jdGlvbiBkZWNvZGVRdWVyeVBhcmFtKHZhbHVlKSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVUaW1lb3V0KHRpbWUpIHtcbiAgaWYgKHRpbWUgPT09ICExIHx8IHRpbWUgPT09IDApXG4gICAgcmV0dXJuICExO1xuICBpZiAodGltZS5jb25uZWN0IHx8IHRpbWUuc29ja2V0KVxuICAgIHJldHVybiB0aW1lO1xuICBjb25zdCBkZWxheSA9IE51bWJlcih0aW1lKTtcbiAgcmV0dXJuIGlzTmFOKGRlbGF5KSA/IG5vcm1hbGl6ZVRpbWVvdXQoZGVmYXVsdE9wdGlvbnMudGltZW91dCkgOiB7IGNvbm5lY3Q6IGRlbGF5LCBzb2NrZXQ6IGRlbGF5IH07XG59XG5jb25zdCB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pLCB2YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7b3B0aW9ucy51cmx9XCIgaXMgbm90IGEgdmFsaWQgVVJMYCk7XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoeCkge1xuICByZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsIFwiZGVmYXVsdFwiKSA/IHguZGVmYXVsdCA6IHg7XG59XG5leHBvcnQge1xuICBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyBhcyBnLFxuICBwcm9jZXNzT3B0aW9ucyBhcyBwLFxuICB2YWxpZGF0ZU9wdGlvbnMgYXMgdlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9jb21tb25qc0hlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks-es/_commonjsHelpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/_chunks-es/createRequester.js":
/*!****************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks-es/createRequester.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ createRequester)\n/* harmony export */ });\n/* harmony import */ var _defaultOptionsValidator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defaultOptionsValidator.js */ \"(ssr)/./node_modules/get-it/dist/_chunks-es/defaultOptionsValidator.js\");\n\nconst middlewareReducer = (middleware) => function(hook, defaultValue, ...args) {\n  const bailEarly = hook === \"onError\";\n  let value = defaultValue;\n  for (let i = 0; i < middleware[hook].length; i++) {\n    const handler = middleware[hook][i];\n    if (value = handler(value, ...args), bailEarly && !value)\n      break;\n  }\n  return value;\n};\nfunction createPubSub() {\n  const subscribers = /* @__PURE__ */ Object.create(null);\n  let nextId = 0;\n  function subscribe(subscriber) {\n    const id = nextId++;\n    return subscribers[id] = subscriber, function() {\n      delete subscribers[id];\n    };\n  }\n  function publish(event) {\n    for (const id in subscribers)\n      subscribers[id](event);\n  }\n  return {\n    publish,\n    subscribe\n  };\n}\nconst channelNames = [\n  \"request\",\n  \"response\",\n  \"progress\",\n  \"error\",\n  \"abort\"\n], middlehooks = [\n  \"processOptions\",\n  \"validateOptions\",\n  \"interceptRequest\",\n  \"finalizeOptions\",\n  \"onRequest\",\n  \"onResponse\",\n  \"onError\",\n  \"onReturn\",\n  \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n  const loadedMiddleware = [], middleware = middlehooks.reduce(\n    (ware, name) => (ware[name] = ware[name] || [], ware),\n    {\n      processOptions: [_defaultOptionsValidator_js__WEBPACK_IMPORTED_MODULE_0__.p],\n      validateOptions: [_defaultOptionsValidator_js__WEBPACK_IMPORTED_MODULE_0__.v]\n    }\n  );\n  function request(opts) {\n    const onResponse = (reqErr, res, ctx) => {\n      let error = reqErr, response = res;\n      if (!error)\n        try {\n          response = applyMiddleware(\"onResponse\", res, ctx);\n        } catch (err) {\n          response = null, error = err;\n        }\n      error = error && applyMiddleware(\"onError\", error, ctx), error ? channels.error.publish(error) : response && channels.response.publish(response);\n    }, channels = channelNames.reduce((target, name) => (target[name] = createPubSub(), target), {}), applyMiddleware = middlewareReducer(middleware), options = applyMiddleware(\"processOptions\", opts);\n    applyMiddleware(\"validateOptions\", options);\n    const context = { options, channels, applyMiddleware };\n    let ongoingRequest;\n    const unsubscribe = channels.request.subscribe((ctx) => {\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx));\n    });\n    channels.abort.subscribe(() => {\n      unsubscribe(), ongoingRequest && ongoingRequest.abort();\n    });\n    const returnValue = applyMiddleware(\"onReturn\", channels, context);\n    return returnValue === channels && channels.request.publish(context), returnValue;\n  }\n  return request.use = function(newMiddleware) {\n    if (!newMiddleware)\n      throw new Error(\"Tried to add middleware that resolved to falsey value\");\n    if (typeof newMiddleware == \"function\")\n      throw new Error(\n        \"Tried to add middleware that was a function. It probably expects you to pass options to it.\"\n      );\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0)\n      throw new Error(\n        \"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\"\n      );\n    return middlehooks.forEach((key) => {\n      newMiddleware[key] && middleware[key].push(newMiddleware[key]);\n    }), loadedMiddleware.push(newMiddleware), request;\n  }, request.clone = () => createRequester(loadedMiddleware, httpRequest), initMiddleware.forEach(request.use), request;\n}\n\n//# sourceMappingURL=createRequester.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy1lcy9jcmVhdGVSZXF1ZXN0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQWM7QUFDckMsd0JBQXdCLDBEQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4RkFBOEY7QUFDbkc7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBR0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MtZXMvY3JlYXRlUmVxdWVzdGVyLmpzPzQ3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcCBhcyBwcm9jZXNzT3B0aW9ucywgdiBhcyB2YWxpZGF0ZU9wdGlvbnMgfSBmcm9tIFwiLi9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5qc1wiO1xuY29uc3QgbWlkZGxld2FyZVJlZHVjZXIgPSAobWlkZGxld2FyZSkgPT4gZnVuY3Rpb24oaG9vaywgZGVmYXVsdFZhbHVlLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGJhaWxFYXJseSA9IGhvb2sgPT09IFwib25FcnJvclwiO1xuICBsZXQgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWlkZGxld2FyZVtob29rXS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBtaWRkbGV3YXJlW2hvb2tdW2ldO1xuICAgIGlmICh2YWx1ZSA9IGhhbmRsZXIodmFsdWUsIC4uLmFyZ3MpLCBiYWlsRWFybHkgJiYgIXZhbHVlKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVB1YlN1YigpIHtcbiAgY29uc3Qgc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG5leHRJZCA9IDA7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgY29uc3QgaWQgPSBuZXh0SWQrKztcbiAgICByZXR1cm4gc3Vic2NyaWJlcnNbaWRdID0gc3Vic2NyaWJlciwgZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgc3Vic2NyaWJlcnNbaWRdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcHVibGlzaChldmVudCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gc3Vic2NyaWJlcnMpXG4gICAgICBzdWJzY3JpYmVyc1tpZF0oZXZlbnQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcHVibGlzaCxcbiAgICBzdWJzY3JpYmVcbiAgfTtcbn1cbmNvbnN0IGNoYW5uZWxOYW1lcyA9IFtcbiAgXCJyZXF1ZXN0XCIsXG4gIFwicmVzcG9uc2VcIixcbiAgXCJwcm9ncmVzc1wiLFxuICBcImVycm9yXCIsXG4gIFwiYWJvcnRcIlxuXSwgbWlkZGxlaG9va3MgPSBbXG4gIFwicHJvY2Vzc09wdGlvbnNcIixcbiAgXCJ2YWxpZGF0ZU9wdGlvbnNcIixcbiAgXCJpbnRlcmNlcHRSZXF1ZXN0XCIsXG4gIFwiZmluYWxpemVPcHRpb25zXCIsXG4gIFwib25SZXF1ZXN0XCIsXG4gIFwib25SZXNwb25zZVwiLFxuICBcIm9uRXJyb3JcIixcbiAgXCJvblJldHVyblwiLFxuICBcIm9uSGVhZGVyc1wiXG5dO1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdGVyKGluaXRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCkge1xuICBjb25zdCBsb2FkZWRNaWRkbGV3YXJlID0gW10sIG1pZGRsZXdhcmUgPSBtaWRkbGVob29rcy5yZWR1Y2UoXG4gICAgKHdhcmUsIG5hbWUpID0+ICh3YXJlW25hbWVdID0gd2FyZVtuYW1lXSB8fCBbXSwgd2FyZSksXG4gICAge1xuICAgICAgcHJvY2Vzc09wdGlvbnM6IFtwcm9jZXNzT3B0aW9uc10sXG4gICAgICB2YWxpZGF0ZU9wdGlvbnM6IFt2YWxpZGF0ZU9wdGlvbnNdXG4gICAgfVxuICApO1xuICBmdW5jdGlvbiByZXF1ZXN0KG9wdHMpIHtcbiAgICBjb25zdCBvblJlc3BvbnNlID0gKHJlcUVyciwgcmVzLCBjdHgpID0+IHtcbiAgICAgIGxldCBlcnJvciA9IHJlcUVyciwgcmVzcG9uc2UgPSByZXM7XG4gICAgICBpZiAoIWVycm9yKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXNwb25zZVwiLCByZXMsIGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3BvbnNlID0gbnVsbCwgZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgIGVycm9yID0gZXJyb3IgJiYgYXBwbHlNaWRkbGV3YXJlKFwib25FcnJvclwiLCBlcnJvciwgY3R4KSwgZXJyb3IgPyBjaGFubmVscy5lcnJvci5wdWJsaXNoKGVycm9yKSA6IHJlc3BvbnNlICYmIGNoYW5uZWxzLnJlc3BvbnNlLnB1Ymxpc2gocmVzcG9uc2UpO1xuICAgIH0sIGNoYW5uZWxzID0gY2hhbm5lbE5hbWVzLnJlZHVjZSgodGFyZ2V0LCBuYW1lKSA9PiAodGFyZ2V0W25hbWVdID0gY3JlYXRlUHViU3ViKCksIHRhcmdldCksIHt9KSwgYXBwbHlNaWRkbGV3YXJlID0gbWlkZGxld2FyZVJlZHVjZXIobWlkZGxld2FyZSksIG9wdGlvbnMgPSBhcHBseU1pZGRsZXdhcmUoXCJwcm9jZXNzT3B0aW9uc1wiLCBvcHRzKTtcbiAgICBhcHBseU1pZGRsZXdhcmUoXCJ2YWxpZGF0ZU9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgY29uc3QgY29udGV4dCA9IHsgb3B0aW9ucywgY2hhbm5lbHMsIGFwcGx5TWlkZGxld2FyZSB9O1xuICAgIGxldCBvbmdvaW5nUmVxdWVzdDtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IGNoYW5uZWxzLnJlcXVlc3Quc3Vic2NyaWJlKChjdHgpID0+IHtcbiAgICAgIG9uZ29pbmdSZXF1ZXN0ID0gaHR0cFJlcXVlc3QoY3R4LCAoZXJyLCByZXMpID0+IG9uUmVzcG9uc2UoZXJyLCByZXMsIGN0eCkpO1xuICAgIH0pO1xuICAgIGNoYW5uZWxzLmFib3J0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB1bnN1YnNjcmliZSgpLCBvbmdvaW5nUmVxdWVzdCAmJiBvbmdvaW5nUmVxdWVzdC5hYm9ydCgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXR1cm5cIiwgY2hhbm5lbHMsIGNvbnRleHQpO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZSA9PT0gY2hhbm5lbHMgJiYgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpLCByZXR1cm5WYWx1ZTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdC51c2UgPSBmdW5jdGlvbihuZXdNaWRkbGV3YXJlKSB7XG4gICAgaWYgKCFuZXdNaWRkbGV3YXJlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCByZXNvbHZlZCB0byBmYWxzZXkgdmFsdWVcIik7XG4gICAgaWYgKHR5cGVvZiBuZXdNaWRkbGV3YXJlID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHdhcyBhIGZ1bmN0aW9uLiBJdCBwcm9iYWJseSBleHBlY3RzIHlvdSB0byBwYXNzIG9wdGlvbnMgdG8gaXQuXCJcbiAgICAgICk7XG4gICAgaWYgKG5ld01pZGRsZXdhcmUub25SZXR1cm4gJiYgbWlkZGxld2FyZS5vblJldHVybi5sZW5ndGggPiAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlRyaWVkIHRvIGFkZCBuZXcgbWlkZGxld2FyZSB3aXRoIGBvblJldHVybmAgaGFuZGxlciwgYnV0IGFub3RoZXIgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnRcIlxuICAgICAgKTtcbiAgICByZXR1cm4gbWlkZGxlaG9va3MuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBuZXdNaWRkbGV3YXJlW2tleV0gJiYgbWlkZGxld2FyZVtrZXldLnB1c2gobmV3TWlkZGxld2FyZVtrZXldKTtcbiAgICB9KSwgbG9hZGVkTWlkZGxld2FyZS5wdXNoKG5ld01pZGRsZXdhcmUpLCByZXF1ZXN0O1xuICB9LCByZXF1ZXN0LmNsb25lID0gKCkgPT4gY3JlYXRlUmVxdWVzdGVyKGxvYWRlZE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KSwgaW5pdE1pZGRsZXdhcmUuZm9yRWFjaChyZXF1ZXN0LnVzZSksIHJlcXVlc3Q7XG59XG5leHBvcnQge1xuICBjcmVhdGVSZXF1ZXN0ZXIgYXMgY1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVJlcXVlc3Rlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks-es/createRequester.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/_chunks-es/defaultOptionsValidator.js":
/*!************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks-es/defaultOptionsValidator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p: () => (/* binding */ processOptions),\n/* harmony export */   v: () => (/* binding */ validateOptions)\n/* harmony export */ });\nconst isReactNative = typeof navigator > \"u\" ? !1 : navigator.product === \"ReactNative\", defaultOptions = { timeout: isReactNative ? 6e4 : 12e4 }, processOptions = function(opts) {\n  const options = {\n    ...defaultOptions,\n    ...typeof opts == \"string\" ? { url: opts } : opts\n  };\n  if (options.timeout = normalizeTimeout(options.timeout), options.query) {\n    const { url, searchParams } = splitUrl(options.url);\n    for (const [key, value] of Object.entries(options.query)) {\n      if (value !== void 0)\n        if (Array.isArray(value))\n          for (const v of value)\n            searchParams.append(key, v);\n        else\n          searchParams.append(key, value);\n      const search = searchParams.toString();\n      search && (options.url = `${url}?${search}`);\n    }\n  }\n  return options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase(), options;\n};\nfunction splitUrl(url) {\n  const qIndex = url.indexOf(\"?\");\n  if (qIndex === -1)\n    return { url, searchParams: new URLSearchParams() };\n  const base = url.slice(0, qIndex), qs = url.slice(qIndex + 1), searchParams = new URLSearchParams(qs);\n  if (typeof searchParams.set == \"function\")\n    return { url: base, searchParams };\n  if (typeof decodeURIComponent != \"function\")\n    throw new Error(\n      \"Broken `URLSearchParams` implementation, and `decodeURIComponent` is not defined\"\n    );\n  const params = new URLSearchParams();\n  for (const pair of qs.split(\"&\")) {\n    const [key, value] = pair.split(\"=\");\n    key && params.append(decodeQueryParam(key), decodeQueryParam(value || \"\"));\n  }\n  return { url: base, searchParams: params };\n}\nfunction decodeQueryParam(value) {\n  return decodeURIComponent(value.replace(/\\+/g, \" \"));\n}\nfunction normalizeTimeout(time) {\n  if (time === !1 || time === 0)\n    return !1;\n  if (time.connect || time.socket)\n    return time;\n  const delay = Number(time);\n  return isNaN(delay) ? normalizeTimeout(defaultOptions.timeout) : { connect: delay, socket: delay };\n}\nconst validUrl = /^https?:\\/\\//i, validateOptions = function(options) {\n  if (!validUrl.test(options.url))\n    throw new Error(`\"${options.url}\" is not a valid URL`);\n};\n\n//# sourceMappingURL=defaultOptionsValidator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy1lcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDRHQUE0RyxxQ0FBcUM7QUFDako7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUksR0FBRyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L19jaHVua3MtZXMvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IuanM/OTAyMSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpc1JlYWN0TmF0aXZlID0gdHlwZW9mIG5hdmlnYXRvciA+IFwidVwiID8gITEgOiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiLCBkZWZhdWx0T3B0aW9ucyA9IHsgdGltZW91dDogaXNSZWFjdE5hdGl2ZSA/IDZlNCA6IDEyZTQgfSwgcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4udHlwZW9mIG9wdHMgPT0gXCJzdHJpbmdcIiA/IHsgdXJsOiBvcHRzIH0gOiBvcHRzXG4gIH07XG4gIGlmIChvcHRpb25zLnRpbWVvdXQgPSBub3JtYWxpemVUaW1lb3V0KG9wdGlvbnMudGltZW91dCksIG9wdGlvbnMucXVlcnkpIHtcbiAgICBjb25zdCB7IHVybCwgc2VhcmNoUGFyYW1zIH0gPSBzcGxpdFVybChvcHRpb25zLnVybCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5xdWVyeSkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKVxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHYpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgIGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgc2VhcmNoICYmIChvcHRpb25zLnVybCA9IGAke3VybH0/JHtzZWFyY2h9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zLm1ldGhvZCA9IG9wdGlvbnMuYm9keSAmJiAhb3B0aW9ucy5tZXRob2QgPyBcIlBPU1RcIiA6IChvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zO1xufTtcbmZ1bmN0aW9uIHNwbGl0VXJsKHVybCkge1xuICBjb25zdCBxSW5kZXggPSB1cmwuaW5kZXhPZihcIj9cIik7XG4gIGlmIChxSW5kZXggPT09IC0xKVxuICAgIHJldHVybiB7IHVybCwgc2VhcmNoUGFyYW1zOiBuZXcgVVJMU2VhcmNoUGFyYW1zKCkgfTtcbiAgY29uc3QgYmFzZSA9IHVybC5zbGljZSgwLCBxSW5kZXgpLCBxcyA9IHVybC5zbGljZShxSW5kZXggKyAxKSwgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhxcyk7XG4gIGlmICh0eXBlb2Ygc2VhcmNoUGFyYW1zLnNldCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHsgdXJsOiBiYXNlLCBzZWFyY2hQYXJhbXMgfTtcbiAgaWYgKHR5cGVvZiBkZWNvZGVVUklDb21wb25lbnQgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiQnJva2VuIGBVUkxTZWFyY2hQYXJhbXNgIGltcGxlbWVudGF0aW9uLCBhbmQgYGRlY29kZVVSSUNvbXBvbmVudGAgaXMgbm90IGRlZmluZWRcIlxuICAgICk7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgZm9yIChjb25zdCBwYWlyIG9mIHFzLnNwbGl0KFwiJlwiKSkge1xuICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhaXIuc3BsaXQoXCI9XCIpO1xuICAgIGtleSAmJiBwYXJhbXMuYXBwZW5kKGRlY29kZVF1ZXJ5UGFyYW0oa2V5KSwgZGVjb2RlUXVlcnlQYXJhbSh2YWx1ZSB8fCBcIlwiKSk7XG4gIH1cbiAgcmV0dXJuIHsgdXJsOiBiYXNlLCBzZWFyY2hQYXJhbXM6IHBhcmFtcyB9O1xufVxuZnVuY3Rpb24gZGVjb2RlUXVlcnlQYXJhbSh2YWx1ZSkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVGltZW91dCh0aW1lKSB7XG4gIGlmICh0aW1lID09PSAhMSB8fCB0aW1lID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHRpbWUuY29ubmVjdCB8fCB0aW1lLnNvY2tldClcbiAgICByZXR1cm4gdGltZTtcbiAgY29uc3QgZGVsYXkgPSBOdW1iZXIodGltZSk7XG4gIHJldHVybiBpc05hTihkZWxheSkgPyBub3JtYWxpemVUaW1lb3V0KGRlZmF1bHRPcHRpb25zLnRpbWVvdXQpIDogeyBjb25uZWN0OiBkZWxheSwgc29ja2V0OiBkZWxheSB9O1xufVxuY29uc3QgdmFsaWRVcmwgPSAvXmh0dHBzPzpcXC9cXC8vaSwgdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAoIXZhbGlkVXJsLnRlc3Qob3B0aW9ucy51cmwpKVxuICAgIHRocm93IG5ldyBFcnJvcihgXCIke29wdGlvbnMudXJsfVwiIGlzIG5vdCBhIHZhbGlkIFVSTGApO1xufTtcbmV4cG9ydCB7XG4gIHByb2Nlc3NPcHRpb25zIGFzIHAsXG4gIHZhbGlkYXRlT3B0aW9ucyBhcyB2XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks-es/defaultOptionsValidator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/get-it/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var tunnel_agent__WEBPACK_IMPORTED_MODULE_9___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adapter: () => (/* binding */ adapter),\n/* harmony export */   environment: () => (/* binding */ environment),\n/* harmony export */   getIt: () => (/* binding */ getIt)\n/* harmony export */ });\n/* harmony import */ var _chunks_es_createRequester_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_chunks-es/createRequester.js */ \"(ssr)/./node_modules/get-it/dist/_chunks-es/createRequester.js\");\n/* harmony import */ var decompress_response__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\");\n/* harmony import */ var follow_redirects__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! follow-redirects */ \"(ssr)/./node_modules/follow-redirects/index.js\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var into_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! into-stream */ \"(ssr)/./node_modules/into-stream/index.js\");\n/* harmony import */ var is_stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-stream */ \"(ssr)/./node_modules/is-stream/index.js\");\n/* harmony import */ var progress_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\n/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! querystring */ \"querystring\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var tunnel_agent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\");\n\n\n\n\n\n\n\n\n\n\n\nfunction lowerCaseHeaders(headers) {\n  return Object.keys(headers || {}).reduce((acc, header) => (acc[header.toLowerCase()] = headers[header], acc), {});\n}\nfunction formatHostname(hostname) {\n  return hostname.replace(/^\\.*/, \".\").toLowerCase();\n}\nfunction parseNoProxyZone(zoneStr) {\n  const zone = zoneStr.trim().toLowerCase(), zoneParts = zone.split(\":\", 2), zoneHost = formatHostname(zoneParts[0]), zonePort = zoneParts[1], hasPort = zone.indexOf(\":\") > -1;\n  return { hostname: zoneHost, port: zonePort, hasPort };\n}\nfunction uriInNoProxy(uri, noProxy) {\n  const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\"), hostname = formatHostname(uri.hostname);\n  return noProxy.split(\",\").map(parseNoProxyZone).some((noProxyZone) => {\n    const isMatchedAt = hostname.indexOf(noProxyZone.hostname), hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;\n    return noProxyZone.hasPort ? port === noProxyZone.port && hostnameMatched : hostnameMatched;\n  });\n}\nfunction getProxyFromUri(uri) {\n  const noProxy = process.env.NO_PROXY || process.env.no_proxy || \"\";\n  return noProxy === \"*\" || noProxy !== \"\" && uriInNoProxy(uri, noProxy) ? null : uri.protocol === \"http:\" ? process.env.HTTP_PROXY || process.env.http_proxy || null : uri.protocol === \"https:\" && (process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy) || null;\n}\nfunction getHostFromUri(uri) {\n  let host = uri.host;\n  return uri.port && (uri.port === \"80\" && uri.protocol === \"http:\" || uri.port === \"443\" && uri.protocol === \"https:\") && (host = uri.hostname), host;\n}\nfunction getHostHeaderWithPort(uri) {\n  const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n  return `${uri.hostname}:${port}`;\n}\nfunction rewriteUriForProxy(reqOpts, uri, proxy) {\n  const headers = reqOpts.headers || {}, options = Object.assign({}, reqOpts, { headers });\n  return headers.host = headers.host || getHostHeaderWithPort(uri), options.protocol = proxy.protocol || options.protocol, options.hostname = proxy.host.replace(/:\\d+/, \"\"), options.port = proxy.port, options.host = getHostFromUri(Object.assign({}, uri, proxy)), options.href = `${options.protocol}//${options.host}${options.path}`, options.path = url__WEBPACK_IMPORTED_MODULE_8__.format(uri), options;\n}\nfunction getProxyOptions(options) {\n  let proxy;\n  if (options.hasOwnProperty(\"proxy\"))\n    proxy = options.proxy;\n  else {\n    const uri = url__WEBPACK_IMPORTED_MODULE_8__.parse(options.url);\n    proxy = getProxyFromUri(uri);\n  }\n  return typeof proxy == \"string\" ? url__WEBPACK_IMPORTED_MODULE_8__.parse(proxy) : proxy;\n}\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nfunction concat(stream, cb) {\n  const chunks = [];\n  stream.on(\"data\", function(chunk) {\n    chunks.push(chunk);\n  }), stream.once(\"end\", function() {\n    cb && cb(null, Buffer.concat(chunks)), cb = null;\n  }), stream.once(\"error\", function(err) {\n    cb && cb(err), cb = null;\n  });\n}\nfunction timedOut(req, time) {\n  if (req.timeoutTimer)\n    return req;\n  const delays = isNaN(time) ? time : { socket: time, connect: time }, hostHeader = req.getHeader(\"host\"), host = hostHeader ? \" to \" + hostHeader : \"\";\n  delays.connect !== void 0 && (req.timeoutTimer = setTimeout(function() {\n    req.abort();\n    const e = new Error(\"Connection timed out on request\" + host);\n    e.code = \"ETIMEDOUT\", req.emit(\"error\", e);\n  }, delays.connect)), req.on(\"socket\", function(socket) {\n    if (!(socket.connecting || socket._connecting)) {\n      connect();\n      return;\n    }\n    socket.once(\"connect\", connect);\n  });\n  function clear() {\n    req.timeoutTimer && (clearTimeout(req.timeoutTimer), req.timeoutTimer = null);\n  }\n  function connect() {\n    clear(), delays.socket !== void 0 && req.setTimeout(delays.socket, function() {\n      req.abort();\n      const e = new Error(\"Socket timed out on request\" + host);\n      e.code = \"ESOCKETTIMEDOUT\", req.emit(\"error\", e);\n    });\n  }\n  return req.on(\"error\", clear);\n}\nconst uriParts = [\n  \"protocol\",\n  \"slashes\",\n  \"auth\",\n  \"host\",\n  \"port\",\n  \"hostname\",\n  \"hash\",\n  \"search\",\n  \"query\",\n  \"pathname\",\n  \"path\",\n  \"href\"\n], defaultProxyHeaderWhiteList = [\n  \"accept\",\n  \"accept-charset\",\n  \"accept-encoding\",\n  \"accept-language\",\n  \"accept-ranges\",\n  \"cache-control\",\n  \"content-encoding\",\n  \"content-language\",\n  \"content-location\",\n  \"content-md5\",\n  \"content-range\",\n  \"content-type\",\n  \"connection\",\n  \"date\",\n  \"expect\",\n  \"max-forwards\",\n  \"pragma\",\n  \"referer\",\n  \"te\",\n  \"user-agent\",\n  \"via\"\n], defaultProxyHeaderExclusiveList = [\"proxy-authorization\"];\nfunction shouldEnable(options) {\n  return typeof options.tunnel < \"u\" ? !!options.tunnel : url__WEBPACK_IMPORTED_MODULE_8__.parse(options.url).protocol === \"https:\";\n}\nfunction applyAgent(opts = {}, proxy) {\n  const options = Object.assign({}, opts), proxyHeaderWhiteList = defaultProxyHeaderWhiteList.concat(options.proxyHeaderWhiteList || []).map((header) => header.toLowerCase()), proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList.concat(options.proxyHeaderExclusiveList || []).map((header) => header.toLowerCase()), proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList);\n  proxyHeaders.host = constructProxyHost(options), options.headers = Object.keys(options.headers || {}).reduce((headers, header) => (proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1 && (headers[header] = options.headers[header]), headers), {});\n  const tunnelFn = getTunnelFn(options, proxy), tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders);\n  return options.agent = tunnelFn(tunnelOptions), options;\n}\nfunction getTunnelFn(options, proxy) {\n  const uri = getUriParts(options), tunnelFnName = constructTunnelFnName(uri, proxy);\n  return /*#__PURE__*/ (tunnel_agent__WEBPACK_IMPORTED_MODULE_9___namespace_cache || (tunnel_agent__WEBPACK_IMPORTED_MODULE_9___namespace_cache = __webpack_require__.t(tunnel_agent__WEBPACK_IMPORTED_MODULE_9__, 2)))[tunnelFnName];\n}\nfunction getUriParts(options) {\n  return uriParts.reduce((uri, part) => (uri[part] = options[part], uri), {});\n}\nfunction constructTunnelFnName(uri, proxy) {\n  const uriProtocol = uri.protocol === \"https:\" ? \"https\" : \"http\", proxyProtocol = proxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n  return `${uriProtocol}Over${proxyProtocol}`;\n}\nfunction constructProxyHost(uri) {\n  const port = uri.port, protocol = uri.protocol;\n  let proxyHost = `${uri.hostname}:`;\n  return port ? proxyHost += port : protocol === \"https:\" ? proxyHost += \"443\" : proxyHost += \"80\", proxyHost;\n}\nfunction getAllowedProxyHeaders(headers, whiteList) {\n  return Object.keys(headers).filter((header) => whiteList.indexOf(header.toLowerCase()) !== -1).reduce((set, header) => (set[header] = headers[header], set), {});\n}\nfunction constructTunnelOptions(options, proxy, proxyHeaders) {\n  return {\n    proxy: {\n      host: proxy.hostname,\n      port: +proxy.port,\n      proxyAuth: proxy.auth,\n      headers: proxyHeaders\n    },\n    headers: options.headers,\n    ca: options.ca,\n    cert: options.cert,\n    key: options.key,\n    passphrase: options.passphrase,\n    pfx: options.pfx,\n    ciphers: options.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized,\n    secureOptions: options.secureOptions,\n    secureProtocol: options.secureProtocol\n  };\n}\nconst adapter = \"node\", reduceResponse = (res, reqUrl, method, body) => ({\n  body,\n  url: reqUrl,\n  method,\n  headers: res.headers,\n  statusCode: res.statusCode,\n  statusMessage: res.statusMessage\n}), httpRequester = (context, cb) => {\n  const { options } = context, uri = Object.assign({}, url__WEBPACK_IMPORTED_MODULE_8__.parse(options.url));\n  if (typeof fetch == \"function\" && options.fetch) {\n    const controller = new AbortController(), reqOpts2 = context.applyMiddleware(\"finalizeOptions\", {\n      ...uri,\n      method: options.method,\n      headers: {\n        ...typeof options.fetch == \"object\" && options.fetch.headers ? lowerCaseHeaders(options.fetch.headers) : {},\n        ...lowerCaseHeaders(options.headers)\n      },\n      maxRedirects: options.maxRedirects\n    }), fetchOpts = {\n      credentials: options.withCredentials ? \"include\" : \"omit\",\n      ...typeof options.fetch == \"object\" ? options.fetch : {},\n      method: reqOpts2.method,\n      headers: reqOpts2.headers,\n      body: options.body,\n      signal: controller.signal\n    }, injectedResponse2 = context.applyMiddleware(\"interceptRequest\", void 0, {\n      adapter,\n      context\n    });\n    if (injectedResponse2) {\n      const cbTimer = setTimeout(cb, 0, null, injectedResponse2);\n      return { abort: () => clearTimeout(cbTimer) };\n    }\n    const request2 = fetch(options.url, fetchOpts);\n    return context.applyMiddleware(\"onRequest\", { options, adapter, request: request2, context }), request2.then(async (res) => {\n      const body = options.rawBody ? res.body : await res.text(), headers = {};\n      res.headers.forEach((value, key) => {\n        headers[key] = value;\n      }), cb(null, {\n        body,\n        url: res.url,\n        method: options.method,\n        headers,\n        statusCode: res.status,\n        statusMessage: res.statusText\n      });\n    }).catch((err) => {\n      err.name != \"AbortError\" && cb(err);\n    }), { abort: () => controller.abort() };\n  }\n  const bodyType = is_stream__WEBPACK_IMPORTED_MODULE_5__(options.body) ? \"stream\" : typeof options.body;\n  if (bodyType !== \"undefined\" && bodyType !== \"stream\" && bodyType !== \"string\" && !Buffer.isBuffer(options.body))\n    throw new Error(`Request body must be a string, buffer or stream, got ${bodyType}`);\n  const lengthHeader = {};\n  options.bodySize ? lengthHeader[\"content-length\"] = options.bodySize : options.body && bodyType !== \"stream\" && (lengthHeader[\"content-length\"] = Buffer.byteLength(options.body));\n  let aborted = !1;\n  const callback = (err, res) => !aborted && cb(err, res);\n  context.channels.abort.subscribe(() => {\n    aborted = !0;\n  });\n  let reqOpts = Object.assign({}, uri, {\n    method: options.method,\n    headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n    maxRedirects: options.maxRedirects\n  });\n  const proxy = getProxyOptions(options), tunnel2 = proxy && shouldEnable(options), injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n    adapter,\n    context\n  });\n  if (injectedResponse) {\n    const cbTimer = setImmediate(callback, null, injectedResponse);\n    return { abort: () => clearImmediate(cbTimer) };\n  }\n  if (options.maxRedirects !== 0 && (reqOpts.maxRedirects = options.maxRedirects || 5), proxy && tunnel2 ? reqOpts = applyAgent(reqOpts, proxy) : proxy && !tunnel2 && (reqOpts = rewriteUriForProxy(reqOpts, uri, proxy)), !tunnel2 && proxy && proxy.auth && !reqOpts.headers[\"proxy-authorization\"]) {\n    const [username, password] = proxy.auth.username ? [proxy.auth.username, proxy.auth.password] : proxy.auth.split(\":\").map((item) => querystring__WEBPACK_IMPORTED_MODULE_7__.unescape(item)), authBase64 = Buffer.from(`${username}:${password}`, \"utf8\").toString(\"base64\");\n    reqOpts.headers[\"proxy-authorization\"] = `Basic ${authBase64}`;\n  }\n  const transport = getRequestTransport(reqOpts, proxy, tunnel2);\n  typeof options.debug == \"function\" && proxy && options.debug(\n    \"Proxying using %s\",\n    reqOpts.agent ? \"tunnel agent\" : `${reqOpts.host}:${reqOpts.port}`\n  );\n  const tryCompressed = reqOpts.method !== \"HEAD\";\n  tryCompressed && !reqOpts.headers[\"accept-encoding\"] && options.compress !== !1 && (reqOpts.headers[\"accept-encoding\"] = // Workaround Bun not supporting brotli: https://github.com/oven-sh/bun/issues/267\n  typeof Bun < \"u\" ? \"gzip, deflate\" : \"br, gzip, deflate\");\n  const finalOptions = context.applyMiddleware(\n    \"finalizeOptions\",\n    reqOpts\n  ), request = transport.request(finalOptions, (response) => {\n    const res = tryCompressed ? decompress_response__WEBPACK_IMPORTED_MODULE_0__(response) : response, resStream = context.applyMiddleware(\"onHeaders\", res, {\n      headers: response.headers,\n      adapter,\n      context\n    }), reqUrl = \"responseUrl\" in response ? response.responseUrl : options.url;\n    if (options.stream) {\n      callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream));\n      return;\n    }\n    concat(resStream, (err, data) => {\n      if (err)\n        return callback(err);\n      const body = options.rawBody ? data : data.toString(), reduced = reduceResponse(res, reqUrl, reqOpts.method, body);\n      return callback(null, reduced);\n    });\n  });\n  options.timeout && timedOut(request, options.timeout), request.once(\"error\", callback);\n  const { bodyStream, progress } = getProgressStream(options);\n  return context.applyMiddleware(\"onRequest\", { options, adapter, request, context, progress }), bodyStream ? bodyStream.pipe(request) : request.end(options.body), { abort: () => request.abort() };\n};\nfunction getProgressStream(options) {\n  if (!options.body)\n    return {};\n  const bodyIsStream = is_stream__WEBPACK_IMPORTED_MODULE_5__(options.body), length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body));\n  if (!length)\n    return bodyIsStream ? { bodyStream: options.body } : {};\n  const progress = progress_stream__WEBPACK_IMPORTED_MODULE_6__({ time: 16, length });\n  return { bodyStream: (bodyIsStream ? options.body : into_stream__WEBPACK_IMPORTED_MODULE_4__(options.body)).pipe(progress), progress };\n}\nfunction getRequestTransport(reqOpts, proxy, tunnel2) {\n  const isHttpsRequest = reqOpts.protocol === \"https:\", transports = reqOpts.maxRedirects === 0 ? { http: http__WEBPACK_IMPORTED_MODULE_2__, https: https__WEBPACK_IMPORTED_MODULE_3__ } : { http: follow_redirects__WEBPACK_IMPORTED_MODULE_1__.http, https: follow_redirects__WEBPACK_IMPORTED_MODULE_1__.https };\n  if (!proxy || tunnel2)\n    return isHttpsRequest ? transports.https : transports.http;\n  let isHttpsProxy = proxy.port === 443;\n  return proxy.protocol && (isHttpsProxy = /^https:?/.test(proxy.protocol)), isHttpsProxy ? transports.https : transports.http;\n}\nconst getIt = (initMiddleware = [], httpRequest = httpRequester) => (0,_chunks_es_createRequester_js__WEBPACK_IMPORTED_MODULE_10__.c)(initMiddleware, httpRequest), environment = \"node\";\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ2xCO0FBQ2Y7QUFDZDtBQUNFO0FBQ1M7QUFDRjtBQUNZO0FBQ2hCO0FBQ1A7QUFDaUI7QUFDdkM7QUFDQSxrQ0FBa0MsZ0ZBQWdGO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSxHQUFHLEtBQUs7QUFDakM7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEIsYUFBYSxTQUFTO0FBQ3pGLHVQQUF1UCxrQ0FBa0MsaUJBQWlCLElBQUksYUFBYSxFQUFFLGFBQWEsa0JBQWtCLHVDQUFVO0FBQ3RXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQ0FBUztBQUN6QjtBQUNBO0FBQ0Esb0NBQW9DLHNDQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2QkFBNkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNDQUFTO0FBQ25FO0FBQ0EsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQyxzR0FBc0cseUpBQXlKO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhNQUFNO0FBQ2Y7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVksTUFBTSxjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGlLQUFpSztBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsVUFBVSxpQ0FBaUMsRUFBRSxzQ0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esa0RBQWtELDhDQUE4QztBQUNoRztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUssS0FBSztBQUNWO0FBQ0EsbUJBQW1CLHNDQUFRO0FBQzNCO0FBQ0EsNEVBQTRFLFNBQVM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdDQUFnQztBQUNoQztBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esd0lBQXdJLGlEQUFXLHFDQUFxQyxTQUFTLEdBQUcsU0FBUztBQUM3TSxzREFBc0QsV0FBVztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxhQUFhLEdBQUcsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdEQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDLGdEQUFnRCw4Q0FBOEMsd0VBQXdFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNDQUFRO0FBQy9CO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RCxtQkFBbUIsNENBQWMsR0FBRyxrQkFBa0I7QUFDdEQsV0FBVywyQ0FBMkMsd0NBQVE7QUFDOUQ7QUFDQTtBQUNBLG9HQUFvRyxJQUFJLDBDQUFPLHVDQUFHLElBQUksTUFBTSxrREFBVyxTQUFTLG1EQUFZO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsaUVBQWU7QUFLakY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L2luZGV4LmpzP2IyNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyBhcyBjcmVhdGVSZXF1ZXN0ZXIgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL2NyZWF0ZVJlcXVlc3Rlci5qc1wiO1xuaW1wb3J0IGRlY29tcHJlc3NSZXNwb25zZSBmcm9tIFwiZGVjb21wcmVzcy1yZXNwb25zZVwiO1xuaW1wb3J0IGZvbGxvdyBmcm9tIFwiZm9sbG93LXJlZGlyZWN0c1wiO1xuaW1wb3J0IGh0dHAgZnJvbSBcImh0dHBcIjtcbmltcG9ydCBodHRwcyBmcm9tIFwiaHR0cHNcIjtcbmltcG9ydCB0b1N0cmVhbSBmcm9tIFwiaW50by1zdHJlYW1cIjtcbmltcG9ydCBpc1N0cmVhbSBmcm9tIFwiaXMtc3RyZWFtXCI7XG5pbXBvcnQgcHJvZ3Jlc3NTdHJlYW0gZnJvbSBcInByb2dyZXNzLXN0cmVhbVwiO1xuaW1wb3J0IHFzIGZyb20gXCJxdWVyeXN0cmluZ1wiO1xuaW1wb3J0IHVybCBmcm9tIFwidXJsXCI7XG5pbXBvcnQgKiBhcyB0dW5uZWwgZnJvbSBcInR1bm5lbC1hZ2VudFwiO1xuZnVuY3Rpb24gbG93ZXJDYXNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhoZWFkZXJzIHx8IHt9KS5yZWR1Y2UoKGFjYywgaGVhZGVyKSA9PiAoYWNjW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlcnNbaGVhZGVyXSwgYWNjKSwge30pO1xufVxuZnVuY3Rpb24gZm9ybWF0SG9zdG5hbWUoaG9zdG5hbWUpIHtcbiAgcmV0dXJuIGhvc3RuYW1lLnJlcGxhY2UoL15cXC4qLywgXCIuXCIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBwYXJzZU5vUHJveHlab25lKHpvbmVTdHIpIHtcbiAgY29uc3Qgem9uZSA9IHpvbmVTdHIudHJpbSgpLnRvTG93ZXJDYXNlKCksIHpvbmVQYXJ0cyA9IHpvbmUuc3BsaXQoXCI6XCIsIDIpLCB6b25lSG9zdCA9IGZvcm1hdEhvc3RuYW1lKHpvbmVQYXJ0c1swXSksIHpvbmVQb3J0ID0gem9uZVBhcnRzWzFdLCBoYXNQb3J0ID0gem9uZS5pbmRleE9mKFwiOlwiKSA+IC0xO1xuICByZXR1cm4geyBob3N0bmFtZTogem9uZUhvc3QsIHBvcnQ6IHpvbmVQb3J0LCBoYXNQb3J0IH07XG59XG5mdW5jdGlvbiB1cmlJbk5vUHJveHkodXJpLCBub1Byb3h5KSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIiksIGhvc3RuYW1lID0gZm9ybWF0SG9zdG5hbWUodXJpLmhvc3RuYW1lKTtcbiAgcmV0dXJuIG5vUHJveHkuc3BsaXQoXCIsXCIpLm1hcChwYXJzZU5vUHJveHlab25lKS5zb21lKChub1Byb3h5Wm9uZSkgPT4ge1xuICAgIGNvbnN0IGlzTWF0Y2hlZEF0ID0gaG9zdG5hbWUuaW5kZXhPZihub1Byb3h5Wm9uZS5ob3N0bmFtZSksIGhvc3RuYW1lTWF0Y2hlZCA9IGlzTWF0Y2hlZEF0ID4gLTEgJiYgaXNNYXRjaGVkQXQgPT09IGhvc3RuYW1lLmxlbmd0aCAtIG5vUHJveHlab25lLmhvc3RuYW1lLmxlbmd0aDtcbiAgICByZXR1cm4gbm9Qcm94eVpvbmUuaGFzUG9ydCA/IHBvcnQgPT09IG5vUHJveHlab25lLnBvcnQgJiYgaG9zdG5hbWVNYXRjaGVkIDogaG9zdG5hbWVNYXRjaGVkO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFByb3h5RnJvbVVyaSh1cmkpIHtcbiAgY29uc3Qgbm9Qcm94eSA9IHByb2Nlc3MuZW52Lk5PX1BST1hZIHx8IHByb2Nlc3MuZW52Lm5vX3Byb3h5IHx8IFwiXCI7XG4gIHJldHVybiBub1Byb3h5ID09PSBcIipcIiB8fCBub1Byb3h5ICE9PSBcIlwiICYmIHVyaUluTm9Qcm94eSh1cmksIG5vUHJveHkpID8gbnVsbCA6IHVyaS5wcm90b2NvbCA9PT0gXCJodHRwOlwiID8gcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWSB8fCBwcm9jZXNzLmVudi5odHRwX3Byb3h5IHx8IG51bGwgOiB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgJiYgKHByb2Nlc3MuZW52LkhUVFBTX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5IHx8IHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSkgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEhvc3RGcm9tVXJpKHVyaSkge1xuICBsZXQgaG9zdCA9IHVyaS5ob3N0O1xuICByZXR1cm4gdXJpLnBvcnQgJiYgKHVyaS5wb3J0ID09PSBcIjgwXCIgJiYgdXJpLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdXJpLnBvcnQgPT09IFwiNDQzXCIgJiYgdXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSAmJiAoaG9zdCA9IHVyaS5ob3N0bmFtZSksIGhvc3Q7XG59XG5mdW5jdGlvbiBnZXRIb3N0SGVhZGVyV2l0aFBvcnQodXJpKSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIik7XG4gIHJldHVybiBgJHt1cmkuaG9zdG5hbWV9OiR7cG9ydH1gO1xufVxuZnVuY3Rpb24gcmV3cml0ZVVyaUZvclByb3h5KHJlcU9wdHMsIHVyaSwgcHJveHkpIHtcbiAgY29uc3QgaGVhZGVycyA9IHJlcU9wdHMuaGVhZGVycyB8fCB7fSwgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHJlcU9wdHMsIHsgaGVhZGVycyB9KTtcbiAgcmV0dXJuIGhlYWRlcnMuaG9zdCA9IGhlYWRlcnMuaG9zdCB8fCBnZXRIb3N0SGVhZGVyV2l0aFBvcnQodXJpKSwgb3B0aW9ucy5wcm90b2NvbCA9IHByb3h5LnByb3RvY29sIHx8IG9wdGlvbnMucHJvdG9jb2wsIG9wdGlvbnMuaG9zdG5hbWUgPSBwcm94eS5ob3N0LnJlcGxhY2UoLzpcXGQrLywgXCJcIiksIG9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnQsIG9wdGlvbnMuaG9zdCA9IGdldEhvc3RGcm9tVXJpKE9iamVjdC5hc3NpZ24oe30sIHVyaSwgcHJveHkpKSwgb3B0aW9ucy5ocmVmID0gYCR7b3B0aW9ucy5wcm90b2NvbH0vLyR7b3B0aW9ucy5ob3N0fSR7b3B0aW9ucy5wYXRofWAsIG9wdGlvbnMucGF0aCA9IHVybC5mb3JtYXQodXJpKSwgb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFByb3h5T3B0aW9ucyhvcHRpb25zKSB7XG4gIGxldCBwcm94eTtcbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoXCJwcm94eVwiKSlcbiAgICBwcm94eSA9IG9wdGlvbnMucHJveHk7XG4gIGVsc2Uge1xuICAgIGNvbnN0IHVyaSA9IHVybC5wYXJzZShvcHRpb25zLnVybCk7XG4gICAgcHJveHkgPSBnZXRQcm94eUZyb21VcmkodXJpKTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHByb3h5ID09IFwic3RyaW5nXCIgPyB1cmwucGFyc2UocHJveHkpIDogcHJveHk7XG59XG4vKiEgc2ltcGxlLWNvbmNhdC4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZnVuY3Rpb24gY29uY2F0KHN0cmVhbSwgY2IpIHtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIHN0cmVhbS5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjaHVua3MucHVzaChjaHVuayk7XG4gIH0pLCBzdHJlYW0ub25jZShcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICBjYiAmJiBjYihudWxsLCBCdWZmZXIuY29uY2F0KGNodW5rcykpLCBjYiA9IG51bGw7XG4gIH0pLCBzdHJlYW0ub25jZShcImVycm9yXCIsIGZ1bmN0aW9uKGVycikge1xuICAgIGNiICYmIGNiKGVyciksIGNiID0gbnVsbDtcbiAgfSk7XG59XG5mdW5jdGlvbiB0aW1lZE91dChyZXEsIHRpbWUpIHtcbiAgaWYgKHJlcS50aW1lb3V0VGltZXIpXG4gICAgcmV0dXJuIHJlcTtcbiAgY29uc3QgZGVsYXlzID0gaXNOYU4odGltZSkgPyB0aW1lIDogeyBzb2NrZXQ6IHRpbWUsIGNvbm5lY3Q6IHRpbWUgfSwgaG9zdEhlYWRlciA9IHJlcS5nZXRIZWFkZXIoXCJob3N0XCIpLCBob3N0ID0gaG9zdEhlYWRlciA/IFwiIHRvIFwiICsgaG9zdEhlYWRlciA6IFwiXCI7XG4gIGRlbGF5cy5jb25uZWN0ICE9PSB2b2lkIDAgJiYgKHJlcS50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHJlcS5hYm9ydCgpO1xuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXCJDb25uZWN0aW9uIHRpbWVkIG91dCBvbiByZXF1ZXN0XCIgKyBob3N0KTtcbiAgICBlLmNvZGUgPSBcIkVUSU1FRE9VVFwiLCByZXEuZW1pdChcImVycm9yXCIsIGUpO1xuICB9LCBkZWxheXMuY29ubmVjdCkpLCByZXEub24oXCJzb2NrZXRcIiwgZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgaWYgKCEoc29ja2V0LmNvbm5lY3RpbmcgfHwgc29ja2V0Ll9jb25uZWN0aW5nKSkge1xuICAgICAgY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzb2NrZXQub25jZShcImNvbm5lY3RcIiwgY29ubmVjdCk7XG4gIH0pO1xuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICByZXEudGltZW91dFRpbWVyICYmIChjbGVhclRpbWVvdXQocmVxLnRpbWVvdXRUaW1lciksIHJlcS50aW1lb3V0VGltZXIgPSBudWxsKTtcbiAgfVxuICBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIGNsZWFyKCksIGRlbGF5cy5zb2NrZXQgIT09IHZvaWQgMCAmJiByZXEuc2V0VGltZW91dChkZWxheXMuc29ja2V0LCBmdW5jdGlvbigpIHtcbiAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIlNvY2tldCB0aW1lZCBvdXQgb24gcmVxdWVzdFwiICsgaG9zdCk7XG4gICAgICBlLmNvZGUgPSBcIkVTT0NLRVRUSU1FRE9VVFwiLCByZXEuZW1pdChcImVycm9yXCIsIGUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXEub24oXCJlcnJvclwiLCBjbGVhcik7XG59XG5jb25zdCB1cmlQYXJ0cyA9IFtcbiAgXCJwcm90b2NvbFwiLFxuICBcInNsYXNoZXNcIixcbiAgXCJhdXRoXCIsXG4gIFwiaG9zdFwiLFxuICBcInBvcnRcIixcbiAgXCJob3N0bmFtZVwiLFxuICBcImhhc2hcIixcbiAgXCJzZWFyY2hcIixcbiAgXCJxdWVyeVwiLFxuICBcInBhdGhuYW1lXCIsXG4gIFwicGF0aFwiLFxuICBcImhyZWZcIlxuXSwgZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0ID0gW1xuICBcImFjY2VwdFwiLFxuICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gIFwiYWNjZXB0LWVuY29kaW5nXCIsXG4gIFwiYWNjZXB0LWxhbmd1YWdlXCIsXG4gIFwiYWNjZXB0LXJhbmdlc1wiLFxuICBcImNhY2hlLWNvbnRyb2xcIixcbiAgXCJjb250ZW50LWVuY29kaW5nXCIsXG4gIFwiY29udGVudC1sYW5ndWFnZVwiLFxuICBcImNvbnRlbnQtbG9jYXRpb25cIixcbiAgXCJjb250ZW50LW1kNVwiLFxuICBcImNvbnRlbnQtcmFuZ2VcIixcbiAgXCJjb250ZW50LXR5cGVcIixcbiAgXCJjb25uZWN0aW9uXCIsXG4gIFwiZGF0ZVwiLFxuICBcImV4cGVjdFwiLFxuICBcIm1heC1mb3J3YXJkc1wiLFxuICBcInByYWdtYVwiLFxuICBcInJlZmVyZXJcIixcbiAgXCJ0ZVwiLFxuICBcInVzZXItYWdlbnRcIixcbiAgXCJ2aWFcIlxuXSwgZGVmYXVsdFByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCA9IFtcInByb3h5LWF1dGhvcml6YXRpb25cIl07XG5mdW5jdGlvbiBzaG91bGRFbmFibGUob3B0aW9ucykge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMudHVubmVsIDwgXCJ1XCIgPyAhIW9wdGlvbnMudHVubmVsIDogdXJsLnBhcnNlKG9wdGlvbnMudXJsKS5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbn1cbmZ1bmN0aW9uIGFwcGx5QWdlbnQob3B0cyA9IHt9LCBwcm94eSkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHByb3h5SGVhZGVyV2hpdGVMaXN0ID0gZGVmYXVsdFByb3h5SGVhZGVyV2hpdGVMaXN0LmNvbmNhdChvcHRpb25zLnByb3h5SGVhZGVyV2hpdGVMaXN0IHx8IFtdKS5tYXAoKGhlYWRlcikgPT4gaGVhZGVyLnRvTG93ZXJDYXNlKCkpLCBwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QgPSBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0LmNvbmNhdChvcHRpb25zLnByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCB8fCBbXSkubWFwKChoZWFkZXIpID0+IGhlYWRlci50b0xvd2VyQ2FzZSgpKSwgcHJveHlIZWFkZXJzID0gZ2V0QWxsb3dlZFByb3h5SGVhZGVycyhvcHRpb25zLmhlYWRlcnMsIHByb3h5SGVhZGVyV2hpdGVMaXN0KTtcbiAgcHJveHlIZWFkZXJzLmhvc3QgPSBjb25zdHJ1Y3RQcm94eUhvc3Qob3B0aW9ucyksIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSkucmVkdWNlKChoZWFkZXJzLCBoZWFkZXIpID0+IChwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xICYmIChoZWFkZXJzW2hlYWRlcl0gPSBvcHRpb25zLmhlYWRlcnNbaGVhZGVyXSksIGhlYWRlcnMpLCB7fSk7XG4gIGNvbnN0IHR1bm5lbEZuID0gZ2V0VHVubmVsRm4ob3B0aW9ucywgcHJveHkpLCB0dW5uZWxPcHRpb25zID0gY29uc3RydWN0VHVubmVsT3B0aW9ucyhvcHRpb25zLCBwcm94eSwgcHJveHlIZWFkZXJzKTtcbiAgcmV0dXJuIG9wdGlvbnMuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKSwgb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGdldFR1bm5lbEZuKG9wdGlvbnMsIHByb3h5KSB7XG4gIGNvbnN0IHVyaSA9IGdldFVyaVBhcnRzKG9wdGlvbnMpLCB0dW5uZWxGbk5hbWUgPSBjb25zdHJ1Y3RUdW5uZWxGbk5hbWUodXJpLCBwcm94eSk7XG4gIHJldHVybiB0dW5uZWxbdHVubmVsRm5OYW1lXTtcbn1cbmZ1bmN0aW9uIGdldFVyaVBhcnRzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVyaVBhcnRzLnJlZHVjZSgodXJpLCBwYXJ0KSA9PiAodXJpW3BhcnRdID0gb3B0aW9uc1twYXJ0XSwgdXJpKSwge30pO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpIHtcbiAgY29uc3QgdXJpUHJvdG9jb2wgPSB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcImh0dHBzXCIgOiBcImh0dHBcIiwgcHJveHlQcm90b2NvbCA9IHByb3h5LnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCJIdHRwc1wiIDogXCJIdHRwXCI7XG4gIHJldHVybiBgJHt1cmlQcm90b2NvbH1PdmVyJHtwcm94eVByb3RvY29sfWA7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm94eUhvc3QodXJpKSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydCwgcHJvdG9jb2wgPSB1cmkucHJvdG9jb2w7XG4gIGxldCBwcm94eUhvc3QgPSBgJHt1cmkuaG9zdG5hbWV9OmA7XG4gIHJldHVybiBwb3J0ID8gcHJveHlIb3N0ICs9IHBvcnQgOiBwcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IHByb3h5SG9zdCArPSBcIjQ0M1wiIDogcHJveHlIb3N0ICs9IFwiODBcIiwgcHJveHlIb3N0O1xufVxuZnVuY3Rpb24gZ2V0QWxsb3dlZFByb3h5SGVhZGVycyhoZWFkZXJzLCB3aGl0ZUxpc3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZpbHRlcigoaGVhZGVyKSA9PiB3aGl0ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgIT09IC0xKS5yZWR1Y2UoKHNldCwgaGVhZGVyKSA9PiAoc2V0W2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl0sIHNldCksIHt9KTtcbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdFR1bm5lbE9wdGlvbnMob3B0aW9ucywgcHJveHksIHByb3h5SGVhZGVycykge1xuICByZXR1cm4ge1xuICAgIHByb3h5OiB7XG4gICAgICBob3N0OiBwcm94eS5ob3N0bmFtZSxcbiAgICAgIHBvcnQ6ICtwcm94eS5wb3J0LFxuICAgICAgcHJveHlBdXRoOiBwcm94eS5hdXRoLFxuICAgICAgaGVhZGVyczogcHJveHlIZWFkZXJzXG4gICAgfSxcbiAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgY2E6IG9wdGlvbnMuY2EsXG4gICAgY2VydDogb3B0aW9ucy5jZXJ0LFxuICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgcGFzc3BocmFzZTogb3B0aW9ucy5wYXNzcGhyYXNlLFxuICAgIHBmeDogb3B0aW9ucy5wZngsXG4gICAgY2lwaGVyczogb3B0aW9ucy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQsXG4gICAgc2VjdXJlT3B0aW9uczogb3B0aW9ucy5zZWN1cmVPcHRpb25zLFxuICAgIHNlY3VyZVByb3RvY29sOiBvcHRpb25zLnNlY3VyZVByb3RvY29sXG4gIH07XG59XG5jb25zdCBhZGFwdGVyID0gXCJub2RlXCIsIHJlZHVjZVJlc3BvbnNlID0gKHJlcywgcmVxVXJsLCBtZXRob2QsIGJvZHkpID0+ICh7XG4gIGJvZHksXG4gIHVybDogcmVxVXJsLFxuICBtZXRob2QsXG4gIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSxcbiAgc3RhdHVzTWVzc2FnZTogcmVzLnN0YXR1c01lc3NhZ2Vcbn0pLCBodHRwUmVxdWVzdGVyID0gKGNvbnRleHQsIGNiKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dCwgdXJpID0gT2JqZWN0LmFzc2lnbih7fSwgdXJsLnBhcnNlKG9wdGlvbnMudXJsKSk7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuZmV0Y2gpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLCByZXFPcHRzMiA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiZmluYWxpemVPcHRpb25zXCIsIHtcbiAgICAgIC4uLnVyaSxcbiAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLnR5cGVvZiBvcHRpb25zLmZldGNoID09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5mZXRjaC5oZWFkZXJzID8gbG93ZXJDYXNlSGVhZGVycyhvcHRpb25zLmZldGNoLmhlYWRlcnMpIDoge30sXG4gICAgICAgIC4uLmxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgICAgfSxcbiAgICAgIG1heFJlZGlyZWN0czogb3B0aW9ucy5tYXhSZWRpcmVjdHNcbiAgICB9KSwgZmV0Y2hPcHRzID0ge1xuICAgICAgY3JlZGVudGlhbHM6IG9wdGlvbnMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcIm9taXRcIixcbiAgICAgIC4uLnR5cGVvZiBvcHRpb25zLmZldGNoID09IFwib2JqZWN0XCIgPyBvcHRpb25zLmZldGNoIDoge30sXG4gICAgICBtZXRob2Q6IHJlcU9wdHMyLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHJlcU9wdHMyLmhlYWRlcnMsXG4gICAgICBib2R5OiBvcHRpb25zLmJvZHksXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSwgaW5qZWN0ZWRSZXNwb25zZTIgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImludGVyY2VwdFJlcXVlc3RcIiwgdm9pZCAwLCB7XG4gICAgICBhZGFwdGVyLFxuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIGlmIChpbmplY3RlZFJlc3BvbnNlMikge1xuICAgICAgY29uc3QgY2JUaW1lciA9IHNldFRpbWVvdXQoY2IsIDAsIG51bGwsIGluamVjdGVkUmVzcG9uc2UyKTtcbiAgICAgIHJldHVybiB7IGFib3J0OiAoKSA9PiBjbGVhclRpbWVvdXQoY2JUaW1lcikgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdDIgPSBmZXRjaChvcHRpb25zLnVybCwgZmV0Y2hPcHRzKTtcbiAgICByZXR1cm4gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvblJlcXVlc3RcIiwgeyBvcHRpb25zLCBhZGFwdGVyLCByZXF1ZXN0OiByZXF1ZXN0MiwgY29udGV4dCB9KSwgcmVxdWVzdDIudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5yYXdCb2R5ID8gcmVzLmJvZHkgOiBhd2FpdCByZXMudGV4dCgpLCBoZWFkZXJzID0ge307XG4gICAgICByZXMuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgfSksIGNiKG51bGwsIHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgdXJsOiByZXMudXJsLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzLFxuICAgICAgICBzdGF0dXNNZXNzYWdlOiByZXMuc3RhdHVzVGV4dFxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgZXJyLm5hbWUgIT0gXCJBYm9ydEVycm9yXCIgJiYgY2IoZXJyKTtcbiAgICB9KSwgeyBhYm9ydDogKCkgPT4gY29udHJvbGxlci5hYm9ydCgpIH07XG4gIH1cbiAgY29uc3QgYm9keVR5cGUgPSBpc1N0cmVhbShvcHRpb25zLmJvZHkpID8gXCJzdHJlYW1cIiA6IHR5cGVvZiBvcHRpb25zLmJvZHk7XG4gIGlmIChib2R5VHlwZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJlYW1cIiAmJiBib2R5VHlwZSAhPT0gXCJzdHJpbmdcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMuYm9keSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0IGJvZHkgbXVzdCBiZSBhIHN0cmluZywgYnVmZmVyIG9yIHN0cmVhbSwgZ290ICR7Ym9keVR5cGV9YCk7XG4gIGNvbnN0IGxlbmd0aEhlYWRlciA9IHt9O1xuICBvcHRpb25zLmJvZHlTaXplID8gbGVuZ3RoSGVhZGVyW1wiY29udGVudC1sZW5ndGhcIl0gPSBvcHRpb25zLmJvZHlTaXplIDogb3B0aW9ucy5ib2R5ICYmIGJvZHlUeXBlICE9PSBcInN0cmVhbVwiICYmIChsZW5ndGhIZWFkZXJbXCJjb250ZW50LWxlbmd0aFwiXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSkpO1xuICBsZXQgYWJvcnRlZCA9ICExO1xuICBjb25zdCBjYWxsYmFjayA9IChlcnIsIHJlcykgPT4gIWFib3J0ZWQgJiYgY2IoZXJyLCByZXMpO1xuICBjb250ZXh0LmNoYW5uZWxzLmFib3J0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgYWJvcnRlZCA9ICEwO1xuICB9KTtcbiAgbGV0IHJlcU9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB1cmksIHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKSwgbGVuZ3RoSGVhZGVyKSxcbiAgICBtYXhSZWRpcmVjdHM6IG9wdGlvbnMubWF4UmVkaXJlY3RzXG4gIH0pO1xuICBjb25zdCBwcm94eSA9IGdldFByb3h5T3B0aW9ucyhvcHRpb25zKSwgdHVubmVsMiA9IHByb3h5ICYmIHNob3VsZEVuYWJsZShvcHRpb25zKSwgaW5qZWN0ZWRSZXNwb25zZSA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiaW50ZXJjZXB0UmVxdWVzdFwiLCB2b2lkIDAsIHtcbiAgICBhZGFwdGVyLFxuICAgIGNvbnRleHRcbiAgfSk7XG4gIGlmIChpbmplY3RlZFJlc3BvbnNlKSB7XG4gICAgY29uc3QgY2JUaW1lciA9IHNldEltbWVkaWF0ZShjYWxsYmFjaywgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZSk7XG4gICAgcmV0dXJuIHsgYWJvcnQ6ICgpID0+IGNsZWFySW1tZWRpYXRlKGNiVGltZXIpIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMubWF4UmVkaXJlY3RzICE9PSAwICYmIChyZXFPcHRzLm1heFJlZGlyZWN0cyA9IG9wdGlvbnMubWF4UmVkaXJlY3RzIHx8IDUpLCBwcm94eSAmJiB0dW5uZWwyID8gcmVxT3B0cyA9IGFwcGx5QWdlbnQocmVxT3B0cywgcHJveHkpIDogcHJveHkgJiYgIXR1bm5lbDIgJiYgKHJlcU9wdHMgPSByZXdyaXRlVXJpRm9yUHJveHkocmVxT3B0cywgdXJpLCBwcm94eSkpLCAhdHVubmVsMiAmJiBwcm94eSAmJiBwcm94eS5hdXRoICYmICFyZXFPcHRzLmhlYWRlcnNbXCJwcm94eS1hdXRob3JpemF0aW9uXCJdKSB7XG4gICAgY29uc3QgW3VzZXJuYW1lLCBwYXNzd29yZF0gPSBwcm94eS5hdXRoLnVzZXJuYW1lID8gW3Byb3h5LmF1dGgudXNlcm5hbWUsIHByb3h5LmF1dGgucGFzc3dvcmRdIDogcHJveHkuYXV0aC5zcGxpdChcIjpcIikubWFwKChpdGVtKSA9PiBxcy51bmVzY2FwZShpdGVtKSksIGF1dGhCYXNlNjQgPSBCdWZmZXIuZnJvbShgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gLCBcInV0ZjhcIikudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgcmVxT3B0cy5oZWFkZXJzW1wicHJveHktYXV0aG9yaXphdGlvblwiXSA9IGBCYXNpYyAke2F1dGhCYXNlNjR9YDtcbiAgfVxuICBjb25zdCB0cmFuc3BvcnQgPSBnZXRSZXF1ZXN0VHJhbnNwb3J0KHJlcU9wdHMsIHByb3h5LCB0dW5uZWwyKTtcbiAgdHlwZW9mIG9wdGlvbnMuZGVidWcgPT0gXCJmdW5jdGlvblwiICYmIHByb3h5ICYmIG9wdGlvbnMuZGVidWcoXG4gICAgXCJQcm94eWluZyB1c2luZyAlc1wiLFxuICAgIHJlcU9wdHMuYWdlbnQgPyBcInR1bm5lbCBhZ2VudFwiIDogYCR7cmVxT3B0cy5ob3N0fToke3JlcU9wdHMucG9ydH1gXG4gICk7XG4gIGNvbnN0IHRyeUNvbXByZXNzZWQgPSByZXFPcHRzLm1ldGhvZCAhPT0gXCJIRUFEXCI7XG4gIHRyeUNvbXByZXNzZWQgJiYgIXJlcU9wdHMuaGVhZGVyc1tcImFjY2VwdC1lbmNvZGluZ1wiXSAmJiBvcHRpb25zLmNvbXByZXNzICE9PSAhMSAmJiAocmVxT3B0cy5oZWFkZXJzW1wiYWNjZXB0LWVuY29kaW5nXCJdID0gLy8gV29ya2Fyb3VuZCBCdW4gbm90IHN1cHBvcnRpbmcgYnJvdGxpOiBodHRwczovL2dpdGh1Yi5jb20vb3Zlbi1zaC9idW4vaXNzdWVzLzI2N1xuICB0eXBlb2YgQnVuIDwgXCJ1XCIgPyBcImd6aXAsIGRlZmxhdGVcIiA6IFwiYnIsIGd6aXAsIGRlZmxhdGVcIik7XG4gIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFxuICAgIFwiZmluYWxpemVPcHRpb25zXCIsXG4gICAgcmVxT3B0c1xuICApLCByZXF1ZXN0ID0gdHJhbnNwb3J0LnJlcXVlc3QoZmluYWxPcHRpb25zLCAocmVzcG9uc2UpID0+IHtcbiAgICBjb25zdCByZXMgPSB0cnlDb21wcmVzc2VkID8gZGVjb21wcmVzc1Jlc3BvbnNlKHJlc3BvbnNlKSA6IHJlc3BvbnNlLCByZXNTdHJlYW0gPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcIm9uSGVhZGVyc1wiLCByZXMsIHtcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBhZGFwdGVyLFxuICAgICAgY29udGV4dFxuICAgIH0pLCByZXFVcmwgPSBcInJlc3BvbnNlVXJsXCIgaW4gcmVzcG9uc2UgPyByZXNwb25zZS5yZXNwb25zZVVybCA6IG9wdGlvbnMudXJsO1xuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVkdWNlUmVzcG9uc2UocmVzLCByZXFVcmwsIHJlcU9wdHMubWV0aG9kLCByZXNTdHJlYW0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uY2F0KHJlc1N0cmVhbSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycilcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5yYXdCb2R5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKSwgcmVkdWNlZCA9IHJlZHVjZVJlc3BvbnNlKHJlcywgcmVxVXJsLCByZXFPcHRzLm1ldGhvZCwgYm9keSk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVkdWNlZCk7XG4gICAgfSk7XG4gIH0pO1xuICBvcHRpb25zLnRpbWVvdXQgJiYgdGltZWRPdXQocmVxdWVzdCwgb3B0aW9ucy50aW1lb3V0KSwgcmVxdWVzdC5vbmNlKFwiZXJyb3JcIiwgY2FsbGJhY2spO1xuICBjb25zdCB7IGJvZHlTdHJlYW0sIHByb2dyZXNzIH0gPSBnZXRQcm9ncmVzc1N0cmVhbShvcHRpb25zKTtcbiAgcmV0dXJuIGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwib25SZXF1ZXN0XCIsIHsgb3B0aW9ucywgYWRhcHRlciwgcmVxdWVzdCwgY29udGV4dCwgcHJvZ3Jlc3MgfSksIGJvZHlTdHJlYW0gPyBib2R5U3RyZWFtLnBpcGUocmVxdWVzdCkgOiByZXF1ZXN0LmVuZChvcHRpb25zLmJvZHkpLCB7IGFib3J0OiAoKSA9PiByZXF1ZXN0LmFib3J0KCkgfTtcbn07XG5mdW5jdGlvbiBnZXRQcm9ncmVzc1N0cmVhbShvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5ib2R5KVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgYm9keUlzU3RyZWFtID0gaXNTdHJlYW0ob3B0aW9ucy5ib2R5KSwgbGVuZ3RoID0gb3B0aW9ucy5ib2R5U2l6ZSB8fCAoYm9keUlzU3RyZWFtID8gbnVsbCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMuYm9keSkpO1xuICBpZiAoIWxlbmd0aClcbiAgICByZXR1cm4gYm9keUlzU3RyZWFtID8geyBib2R5U3RyZWFtOiBvcHRpb25zLmJvZHkgfSA6IHt9O1xuICBjb25zdCBwcm9ncmVzcyA9IHByb2dyZXNzU3RyZWFtKHsgdGltZTogMTYsIGxlbmd0aCB9KTtcbiAgcmV0dXJuIHsgYm9keVN0cmVhbTogKGJvZHlJc1N0cmVhbSA/IG9wdGlvbnMuYm9keSA6IHRvU3RyZWFtKG9wdGlvbnMuYm9keSkpLnBpcGUocHJvZ3Jlc3MpLCBwcm9ncmVzcyB9O1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdFRyYW5zcG9ydChyZXFPcHRzLCBwcm94eSwgdHVubmVsMikge1xuICBjb25zdCBpc0h0dHBzUmVxdWVzdCA9IHJlcU9wdHMucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIsIHRyYW5zcG9ydHMgPSByZXFPcHRzLm1heFJlZGlyZWN0cyA9PT0gMCA/IHsgaHR0cCwgaHR0cHMgfSA6IHsgaHR0cDogZm9sbG93Lmh0dHAsIGh0dHBzOiBmb2xsb3cuaHR0cHMgfTtcbiAgaWYgKCFwcm94eSB8fCB0dW5uZWwyKVxuICAgIHJldHVybiBpc0h0dHBzUmVxdWVzdCA/IHRyYW5zcG9ydHMuaHR0cHMgOiB0cmFuc3BvcnRzLmh0dHA7XG4gIGxldCBpc0h0dHBzUHJveHkgPSBwcm94eS5wb3J0ID09PSA0NDM7XG4gIHJldHVybiBwcm94eS5wcm90b2NvbCAmJiAoaXNIdHRwc1Byb3h5ID0gL15odHRwczo/Ly50ZXN0KHByb3h5LnByb3RvY29sKSksIGlzSHR0cHNQcm94eSA/IHRyYW5zcG9ydHMuaHR0cHMgOiB0cmFuc3BvcnRzLmh0dHA7XG59XG5jb25zdCBnZXRJdCA9IChpbml0TWlkZGxld2FyZSA9IFtdLCBodHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0ZXIpID0+IGNyZWF0ZVJlcXVlc3Rlcihpbml0TWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpLCBlbnZpcm9ubWVudCA9IFwibm9kZVwiO1xuZXhwb3J0IHtcbiAgYWRhcHRlcixcbiAgZW52aXJvbm1lbnQsXG4gIGdldEl0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/middleware.js":
/*!************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Cancel: () => (/* binding */ Cancel),\n/* harmony export */   CancelToken: () => (/* binding */ CancelToken),\n/* harmony export */   agent: () => (/* binding */ agent),\n/* harmony export */   base: () => (/* binding */ base),\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   headers: () => (/* binding */ headers),\n/* harmony export */   httpErrors: () => (/* binding */ httpErrors),\n/* harmony export */   injectResponse: () => (/* binding */ injectResponse),\n/* harmony export */   jsonRequest: () => (/* binding */ jsonRequest),\n/* harmony export */   jsonResponse: () => (/* binding */ jsonResponse),\n/* harmony export */   keepAlive: () => (/* binding */ keepAlive),\n/* harmony export */   mtls: () => (/* binding */ mtls),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   processOptions: () => (/* reexport safe */ _chunks_es_defaultOptionsValidator_js__WEBPACK_IMPORTED_MODULE_7__.p),\n/* harmony export */   progress: () => (/* binding */ progress),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   proxy: () => (/* binding */ proxy),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   urlEncoded: () => (/* binding */ urlEncoded),\n/* harmony export */   validateOptions: () => (/* reexport safe */ _chunks_es_defaultOptionsValidator_js__WEBPACK_IMPORTED_MODULE_7__.v)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var _chunks_es_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_chunks-es/_commonjsHelpers.js */ \"(ssr)/./node_modules/get-it/dist/_chunks-es/_commonjsHelpers.js\");\n/* harmony import */ var tty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tty */ \"tty\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var _chunks_es_defaultOptionsValidator_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_chunks-es/defaultOptionsValidator.js */ \"(ssr)/./node_modules/get-it/dist/_chunks-es/defaultOptionsValidator.js\");\n/* harmony import */ var progress_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\n/* harmony import */ var is_retry_allowed__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! is-retry-allowed */ \"(ssr)/./node_modules/is-retry-allowed/index.js\");\n\n\n\n\n\n\n\n\nconst isHttpsProto = /^https:/i;\nfunction agent(opts) {\n  const httpAgent = new http__WEBPACK_IMPORTED_MODULE_0__.Agent(opts), httpsAgent = new https__WEBPACK_IMPORTED_MODULE_1__.Agent(opts), agents = { http: httpAgent, https: httpsAgent };\n  return {\n    finalizeOptions: (options) => {\n      if (options.agent)\n        return options;\n      if (options.maxRedirects > 0)\n        return { ...options, agents };\n      const isHttps = isHttpsProto.test(options.href || options.protocol);\n      return { ...options, agent: isHttps ? httpsAgent : httpAgent };\n    }\n  };\n}\nconst leadingSlash = /^\\//, trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n  const baseUri = baseUrl.replace(trailingSlash, \"\");\n  return {\n    processOptions: (options) => {\n      if (/^https?:\\/\\//i.test(options.url))\n        return options;\n      const url = [baseUri, options.url.replace(leadingSlash, \"\")].join(\"/\");\n      return Object.assign({}, options, { url });\n    }\n  };\n}\nvar src = { exports: {} }, browser$1 = { exports: {} }, ms, hasRequiredMs;\nfunction requireMs() {\n  if (hasRequiredMs)\n    return ms;\n  hasRequiredMs = 1;\n  var s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25;\n  ms = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === \"string\" && val.length > 0)\n      return parse(val);\n    if (type === \"number\" && isFinite(val))\n      return options.long ? fmtLong(val) : fmtShort(val);\n    throw new Error(\n      \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(val)\n    );\n  };\n  function parse(str) {\n    if (str = String(str), !(str.length > 100)) {\n      var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        str\n      );\n      if (match) {\n        var n = parseFloat(match[1]), type = (match[2] || \"ms\").toLowerCase();\n        switch (type) {\n          case \"years\":\n          case \"year\":\n          case \"yrs\":\n          case \"yr\":\n          case \"y\":\n            return n * y;\n          case \"weeks\":\n          case \"week\":\n          case \"w\":\n            return n * w;\n          case \"days\":\n          case \"day\":\n          case \"d\":\n            return n * d;\n          case \"hours\":\n          case \"hour\":\n          case \"hrs\":\n          case \"hr\":\n          case \"h\":\n            return n * h;\n          case \"minutes\":\n          case \"minute\":\n          case \"mins\":\n          case \"min\":\n          case \"m\":\n            return n * m;\n          case \"seconds\":\n          case \"second\":\n          case \"secs\":\n          case \"sec\":\n          case \"s\":\n            return n * s;\n          case \"milliseconds\":\n          case \"millisecond\":\n          case \"msecs\":\n          case \"msec\":\n          case \"ms\":\n            return n;\n          default:\n            return;\n        }\n      }\n    }\n  }\n  function fmtShort(ms2) {\n    var msAbs = Math.abs(ms2);\n    return msAbs >= d ? Math.round(ms2 / d) + \"d\" : msAbs >= h ? Math.round(ms2 / h) + \"h\" : msAbs >= m ? Math.round(ms2 / m) + \"m\" : msAbs >= s ? Math.round(ms2 / s) + \"s\" : ms2 + \"ms\";\n  }\n  function fmtLong(ms2) {\n    var msAbs = Math.abs(ms2);\n    return msAbs >= d ? plural(ms2, msAbs, d, \"day\") : msAbs >= h ? plural(ms2, msAbs, h, \"hour\") : msAbs >= m ? plural(ms2, msAbs, m, \"minute\") : msAbs >= s ? plural(ms2, msAbs, s, \"second\") : ms2 + \" ms\";\n  }\n  function plural(ms2, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms2 / n) + \" \" + name + (isPlural ? \"s\" : \"\");\n  }\n  return ms;\n}\nvar common, hasRequiredCommon;\nfunction requireCommon() {\n  if (hasRequiredCommon)\n    return common;\n  hasRequiredCommon = 1;\n  function setup(env) {\n    createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = requireMs(), createDebug.destroy = destroy, Object.keys(env).forEach((key) => {\n      createDebug[key] = env[key];\n    }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};\n    function selectColor(namespace) {\n      let hash = 0;\n      for (let i = 0; i < namespace.length; i++)\n        hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;\n      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    function createDebug(namespace) {\n      let prevTime, enableOverride = null, namespacesCache, enabledCache;\n      function debug2(...args) {\n        if (!debug2.enabled)\n          return;\n        const self2 = debug2, curr = Number(/* @__PURE__ */ new Date()), ms2 = curr - (prevTime || curr);\n        self2.diff = ms2, self2.prev = prevTime, self2.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] != \"string\" && args.unshift(\"%O\");\n        let index = 0;\n        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n          if (match === \"%%\")\n            return \"%\";\n          index++;\n          const formatter = createDebug.formatters[format];\n          if (typeof formatter == \"function\") {\n            const val = args[index];\n            match = formatter.call(self2, val), args.splice(index, 1), index--;\n          }\n          return match;\n        }), createDebug.formatArgs.call(self2, args), (self2.log || createDebug.log).apply(self2, args);\n      }\n      return debug2.namespace = namespace, debug2.useColors = createDebug.useColors(), debug2.color = createDebug.selectColor(namespace), debug2.extend = extend, debug2.destroy = createDebug.destroy, Object.defineProperty(debug2, \"enabled\", {\n        enumerable: !0,\n        configurable: !1,\n        get: () => enableOverride !== null ? enableOverride : (namespacesCache !== createDebug.namespaces && (namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace)), enabledCache),\n        set: (v2) => {\n          enableOverride = v2;\n        }\n      }), typeof createDebug.init == \"function\" && createDebug.init(debug2), debug2;\n    }\n    function extend(namespace, delimiter) {\n      const newDebug = createDebug(this.namespace + (typeof delimiter > \"u\" ? \":\" : delimiter) + namespace);\n      return newDebug.log = this.log, newDebug;\n    }\n    function enable(namespaces) {\n      createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];\n      let i;\n      const split = (typeof namespaces == \"string\" ? namespaces : \"\").split(/[\\s,]+/), len = split.length;\n      for (i = 0; i < len; i++)\n        split[i] && (namespaces = split[i].replace(/\\*/g, \".*?\"), namespaces[0] === \"-\" ? createDebug.skips.push(new RegExp(\"^\" + namespaces.slice(1) + \"$\")) : createDebug.names.push(new RegExp(\"^\" + namespaces + \"$\")));\n    }\n    function disable() {\n      const namespaces = [\n        ...createDebug.names.map(toNamespace),\n        ...createDebug.skips.map(toNamespace).map((namespace) => \"-\" + namespace)\n      ].join(\",\");\n      return createDebug.enable(\"\"), namespaces;\n    }\n    function enabled(name) {\n      if (name[name.length - 1] === \"*\")\n        return !0;\n      let i, len;\n      for (i = 0, len = createDebug.skips.length; i < len; i++)\n        if (createDebug.skips[i].test(name))\n          return !1;\n      for (i = 0, len = createDebug.names.length; i < len; i++)\n        if (createDebug.names[i].test(name))\n          return !0;\n      return !1;\n    }\n    function toNamespace(regexp) {\n      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n    }\n    function coerce(val) {\n      return val instanceof Error ? val.stack || val.message : val;\n    }\n    function destroy() {\n      console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n    }\n    return createDebug.enable(createDebug.load()), createDebug;\n  }\n  return common = setup, common;\n}\nvar hasRequiredBrowser$1;\nfunction requireBrowser$1() {\n  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(module, exports) {\n    exports.formatArgs = formatArgs, exports.save = save, exports.load = load, exports.useColors = useColors, exports.storage = localstorage(), exports.destroy = /* @__PURE__ */ (() => {\n      let warned = !1;\n      return () => {\n        warned || (warned = !0, console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"));\n      };\n    })(), exports.colors = [\n      \"#0000CC\",\n      \"#0000FF\",\n      \"#0033CC\",\n      \"#0033FF\",\n      \"#0066CC\",\n      \"#0066FF\",\n      \"#0099CC\",\n      \"#0099FF\",\n      \"#00CC00\",\n      \"#00CC33\",\n      \"#00CC66\",\n      \"#00CC99\",\n      \"#00CCCC\",\n      \"#00CCFF\",\n      \"#3300CC\",\n      \"#3300FF\",\n      \"#3333CC\",\n      \"#3333FF\",\n      \"#3366CC\",\n      \"#3366FF\",\n      \"#3399CC\",\n      \"#3399FF\",\n      \"#33CC00\",\n      \"#33CC33\",\n      \"#33CC66\",\n      \"#33CC99\",\n      \"#33CCCC\",\n      \"#33CCFF\",\n      \"#6600CC\",\n      \"#6600FF\",\n      \"#6633CC\",\n      \"#6633FF\",\n      \"#66CC00\",\n      \"#66CC33\",\n      \"#9900CC\",\n      \"#9900FF\",\n      \"#9933CC\",\n      \"#9933FF\",\n      \"#99CC00\",\n      \"#99CC33\",\n      \"#CC0000\",\n      \"#CC0033\",\n      \"#CC0066\",\n      \"#CC0099\",\n      \"#CC00CC\",\n      \"#CC00FF\",\n      \"#CC3300\",\n      \"#CC3333\",\n      \"#CC3366\",\n      \"#CC3399\",\n      \"#CC33CC\",\n      \"#CC33FF\",\n      \"#CC6600\",\n      \"#CC6633\",\n      \"#CC9900\",\n      \"#CC9933\",\n      \"#CCCC00\",\n      \"#CCCC33\",\n      \"#FF0000\",\n      \"#FF0033\",\n      \"#FF0066\",\n      \"#FF0099\",\n      \"#FF00CC\",\n      \"#FF00FF\",\n      \"#FF3300\",\n      \"#FF3333\",\n      \"#FF3366\",\n      \"#FF3399\",\n      \"#FF33CC\",\n      \"#FF33FF\",\n      \"#FF6600\",\n      \"#FF6633\",\n      \"#FF9900\",\n      \"#FF9933\",\n      \"#FFCC00\",\n      \"#FFCC33\"\n    ];\n    function useColors() {\n      return typeof window < \"u\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs) ? !0 : typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/) ? !1 : typeof document < \"u\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n      typeof window < \"u\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n      typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n      typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n    }\n    function formatArgs(args) {\n      if (args[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + args[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff), !this.useColors)\n        return;\n      const c = \"color: \" + this.color;\n      args.splice(1, 0, c, \"color: inherit\");\n      let index = 0, lastC = 0;\n      args[0].replace(/%[a-zA-Z%]/g, (match) => {\n        match !== \"%%\" && (index++, match === \"%c\" && (lastC = index));\n      }), args.splice(lastC, 0, c);\n    }\n    exports.log = console.debug || console.log || (() => {\n    });\n    function save(namespaces) {\n      try {\n        namespaces ? exports.storage.setItem(\"debug\", namespaces) : exports.storage.removeItem(\"debug\");\n      } catch {\n      }\n    }\n    function load() {\n      let r;\n      try {\n        r = exports.storage.getItem(\"debug\");\n      } catch {\n      }\n      return !r && typeof process < \"u\" && \"env\" in process && (r = process.env.DEBUG), r;\n    }\n    function localstorage() {\n      try {\n        return localStorage;\n      } catch {\n      }\n    }\n    module.exports = requireCommon()(exports);\n    const { formatters } = module.exports;\n    formatters.j = function(v2) {\n      try {\n        return JSON.stringify(v2);\n      } catch (error) {\n        return \"[UnexpectedJSONParseError]: \" + error.message;\n      }\n    };\n  }(browser$1, browser$1.exports)), browser$1.exports;\n}\nvar node = { exports: {} }, browser, hasRequiredBrowser;\nfunction requireBrowser() {\n  if (hasRequiredBrowser)\n    return browser;\n  hasRequiredBrowser = 1;\n  function getChromeVersion() {\n    const matches = /(Chrome|Chromium)\\/(?<chromeVersion>\\d+)\\./.exec(navigator.userAgent);\n    if (matches)\n      return Number.parseInt(matches.groups.chromeVersion, 10);\n  }\n  const colorSupport = getChromeVersion() >= 69 ? {\n    level: 1,\n    hasBasic: !0,\n    has256: !1,\n    has16m: !1\n  } : !1;\n  return browser = {\n    stdout: colorSupport,\n    stderr: colorSupport\n  }, browser;\n}\nvar hasRequiredNode;\nfunction requireNode() {\n  return hasRequiredNode || (hasRequiredNode = 1, function(module, exports) {\n    const tty = tty__WEBPACK_IMPORTED_MODULE_2__, util = util__WEBPACK_IMPORTED_MODULE_3__;\n    exports.init = init, exports.log = log, exports.formatArgs = formatArgs, exports.save = save, exports.load = load, exports.useColors = useColors, exports.destroy = util.deprecate(\n      () => {\n      },\n      \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"\n    ), exports.colors = [6, 2, 3, 4, 5, 1];\n    try {\n      const supportsColor = requireBrowser();\n      supportsColor && (supportsColor.stderr || supportsColor).level >= 2 && (exports.colors = [\n        20,\n        21,\n        26,\n        27,\n        32,\n        33,\n        38,\n        39,\n        40,\n        41,\n        42,\n        43,\n        44,\n        45,\n        56,\n        57,\n        62,\n        63,\n        68,\n        69,\n        74,\n        75,\n        76,\n        77,\n        78,\n        79,\n        80,\n        81,\n        92,\n        93,\n        98,\n        99,\n        112,\n        113,\n        128,\n        129,\n        134,\n        135,\n        148,\n        149,\n        160,\n        161,\n        162,\n        163,\n        164,\n        165,\n        166,\n        167,\n        168,\n        169,\n        170,\n        171,\n        172,\n        173,\n        178,\n        179,\n        184,\n        185,\n        196,\n        197,\n        198,\n        199,\n        200,\n        201,\n        202,\n        203,\n        204,\n        205,\n        206,\n        207,\n        208,\n        209,\n        214,\n        215,\n        220,\n        221\n      ]);\n    } catch {\n    }\n    exports.inspectOpts = Object.keys(process.env).filter((key) => /^debug_/i.test(key)).reduce((obj, key) => {\n      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => k.toUpperCase());\n      let val = process.env[key];\n      return /^(yes|on|true|enabled)$/i.test(val) ? val = !0 : /^(no|off|false|disabled)$/i.test(val) ? val = !1 : val === \"null\" ? val = null : val = Number(val), obj[prop] = val, obj;\n    }, {});\n    function useColors() {\n      return \"colors\" in exports.inspectOpts ? !!exports.inspectOpts.colors : tty.isatty(process.stderr.fd);\n    }\n    function formatArgs(args) {\n      const { namespace: name, useColors: useColors2 } = this;\n      if (useColors2) {\n        const c = this.color, colorCode = \"\\x1B[3\" + (c < 8 ? c : \"8;5;\" + c), prefix = `  ${colorCode};1m${name} \\x1B[0m`;\n        args[0] = prefix + args[0].split(`\n`).join(`\n` + prefix), args.push(colorCode + \"m+\" + module.exports.humanize(this.diff) + \"\\x1B[0m\");\n      } else\n        args[0] = getDate() + name + \" \" + args[0];\n    }\n    function getDate() {\n      return exports.inspectOpts.hideDate ? \"\" : (/* @__PURE__ */ new Date()).toISOString() + \" \";\n    }\n    function log(...args) {\n      return process.stderr.write(util.format(...args) + `\n`);\n    }\n    function save(namespaces) {\n      namespaces ? process.env.DEBUG = namespaces : delete process.env.DEBUG;\n    }\n    function load() {\n      return process.env.DEBUG;\n    }\n    function init(debug2) {\n      debug2.inspectOpts = {};\n      const keys = Object.keys(exports.inspectOpts);\n      for (let i = 0; i < keys.length; i++)\n        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n    module.exports = requireCommon()(exports);\n    const { formatters } = module.exports;\n    formatters.o = function(v2) {\n      return this.inspectOpts.colors = this.useColors, util.inspect(v2, this.inspectOpts).split(`\n`).map((str) => str.trim()).join(\" \");\n    }, formatters.O = function(v2) {\n      return this.inspectOpts.colors = this.useColors, util.inspect(v2, this.inspectOpts);\n    };\n  }(node, node.exports)), node.exports;\n}\ntypeof process > \"u\" || process.type === \"renderer\" || false === !0 || process.__nwjs ? src.exports = requireBrowser$1() : src.exports = requireNode();\nvar srcExports = src.exports, debugIt = /* @__PURE__ */ (0,_chunks_es_commonjsHelpers_js__WEBPACK_IMPORTED_MODULE_6__.g)(srcExports);\nconst SENSITIVE_HEADERS = [\"cookie\", \"authorization\"], hasOwn = Object.prototype.hasOwnProperty, redactKeys = (source, redacted) => {\n  const target = {};\n  for (const key in source)\n    hasOwn.call(source, key) && (target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key]);\n  return target;\n};\nfunction debug(opts = {}) {\n  const verbose = opts.verbose, namespace = opts.namespace || \"get-it\", defaultLogger = debugIt(namespace), log = opts.log || defaultLogger, shortCircuit = log === defaultLogger && !debugIt.enabled(namespace);\n  let requestId = 0;\n  return {\n    processOptions: (options) => (options.debug = log, options.requestId = options.requestId || ++requestId, options),\n    onRequest: (event) => {\n      if (shortCircuit || !event)\n        return event;\n      const options = event.options;\n      if (log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url), verbose && options.body && typeof options.body == \"string\" && log(\"[%s] Request body: %s\", options.requestId, options.body), verbose && options.headers) {\n        const headers2 = opts.redactSensitiveHeaders === !1 ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n        log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers2, null, 2));\n      }\n      return event;\n    },\n    onResponse: (res, context) => {\n      if (shortCircuit || !res)\n        return res;\n      const reqId = context.options.requestId;\n      return log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage), verbose && res.body && log(\"[%s] Response body: %s\", reqId, stringifyBody(res)), res;\n    },\n    onError: (err, context) => {\n      const reqId = context.options.requestId;\n      return err ? (log(\"[%s] ERROR: %s\", reqId, err.message), err) : (log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId), err);\n    }\n  };\n}\nfunction stringifyBody(res) {\n  return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n  try {\n    const parsed = typeof body == \"string\" ? JSON.parse(body) : body;\n    return JSON.stringify(parsed, null, 2);\n  } catch {\n    return body;\n  }\n}\nfunction headers(_headers, opts = {}) {\n  return {\n    processOptions: (options) => {\n      const existing = options.headers || {};\n      return options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing), options;\n    }\n  };\n}\nvar __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => (__defNormalProp$1(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass HttpError extends Error {\n  constructor(res, ctx) {\n    super(), __publicField$1(this, \"response\"), __publicField$1(this, \"request\");\n    const truncatedUrl = res.url.length > 400 ? `${res.url.slice(0, 399)}\\u2026` : res.url;\n    let msg = `${res.method}-request to ${truncatedUrl} resulted in `;\n    msg += `HTTP ${res.statusCode} ${res.statusMessage}`, this.message = msg.trim(), this.response = res, this.request = ctx.options;\n  }\n}\nfunction httpErrors() {\n  return {\n    onResponse: (res, ctx) => {\n      if (!(res.statusCode >= 400))\n        return res;\n      throw new HttpError(res, ctx);\n    }\n  };\n}\nfunction injectResponse(opts = {}) {\n  if (typeof opts.inject != \"function\")\n    throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n  return { interceptRequest: function(prevValue, event) {\n    const response = opts.inject(event, prevValue);\n    if (!response)\n      return prevValue;\n    const options = event.context.options;\n    return {\n      body: \"\",\n      url: options.url,\n      method: options.method,\n      headers: {},\n      statusCode: 200,\n      statusMessage: \"OK\",\n      ...response\n    };\n  } };\n}\nconst isBuffer = typeof Buffer > \"u\" ? () => !1 : (obj) => Buffer.isBuffer(obj);\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isPlainObject(o) {\n  if (isObject(o) === !1)\n    return !1;\n  const ctor = o.constructor;\n  if (ctor === void 0)\n    return !0;\n  const prot = ctor.prototype;\n  return !(isObject(prot) === !1 || // eslint-disable-next-line no-prototype-builtins\n  prot.hasOwnProperty(\"isPrototypeOf\") === !1);\n}\nconst serializeTypes = [\"boolean\", \"string\", \"number\"];\nfunction jsonRequest() {\n  return {\n    processOptions: (options) => {\n      const body = options.body;\n      return !body || !(typeof body.pipe != \"function\" && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject(body))) ? options : Object.assign({}, options, {\n        body: JSON.stringify(options.body),\n        headers: Object.assign({}, options.headers, {\n          \"Content-Type\": \"application/json\"\n        })\n      });\n    }\n  };\n}\nfunction jsonResponse(opts) {\n  return {\n    onResponse: (response) => {\n      const contentType = response.headers[\"content-type\"] || \"\", shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n      return !response.body || !contentType || !shouldDecode ? response : Object.assign({}, response, { body: tryParse(response.body) });\n    },\n    processOptions: (options) => Object.assign({}, options, {\n      headers: Object.assign({ Accept: \"application/json\" }, options.headers)\n    })\n  };\n  function tryParse(body) {\n    try {\n      return JSON.parse(body);\n    } catch (err) {\n      throw err.message = `Failed to parsed response body as JSON: ${err.message}`, err;\n    }\n  }\n}\nfunction isBrowserOptions(options) {\n  return typeof options == \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls(config = {}) {\n  if (!config.ca)\n    throw new Error('Required mtls option \"ca\" is missing');\n  if (!config.cert)\n    throw new Error('Required mtls option \"cert\" is missing');\n  if (!config.key)\n    throw new Error('Required mtls option \"key\" is missing');\n  return {\n    finalizeOptions: (options) => {\n      if (isBrowserOptions(options))\n        return options;\n      const mtlsOpts = {\n        cert: config.cert,\n        key: config.key,\n        ca: config.ca\n      };\n      return Object.assign({}, options, mtlsOpts);\n    }\n  };\n}\nlet actualGlobal = {};\ntypeof globalThis < \"u\" ? actualGlobal = globalThis : typeof window < \"u\" ? actualGlobal = window : typeof global < \"u\" ? actualGlobal = global : typeof self < \"u\" && (actualGlobal = self);\nvar global$1 = actualGlobal;\nfunction observable(opts = {}) {\n  const Observable = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable\n  );\n  if (!Observable)\n    throw new Error(\n      \"`Observable` is not available in global scope, and no implementation was passed\"\n    );\n  return {\n    onReturn: (channels, context) => new Observable((observer) => (channels.error.subscribe((err) => observer.error(err)), channels.progress.subscribe(\n      (event) => observer.next(Object.assign({ type: \"progress\" }, event))\n    ), channels.response.subscribe((response) => {\n      observer.next(Object.assign({ type: \"response\" }, response)), observer.complete();\n    }), channels.request.publish(context), () => channels.abort.publish()))\n  };\n}\nfunction normalizer(stage) {\n  return (prog) => ({\n    stage,\n    percent: prog.percentage,\n    total: prog.length,\n    loaded: prog.transferred,\n    lengthComputable: !(prog.length === 0 && prog.percentage === 0)\n  });\n}\nfunction progress() {\n  return {\n    onHeaders: (response, evt) => {\n      const _progress = progress_stream__WEBPACK_IMPORTED_MODULE_4__({ time: 16 }), normalize = normalizer(\"download\"), contentLength = response.headers[\"content-length\"], length = contentLength ? Number(contentLength) : 0;\n      return !isNaN(length) && length > 0 && _progress.setLength(length), _progress.on(\"progress\", (prog) => evt.context.channels.progress.publish(normalize(prog))), response.pipe(_progress);\n    },\n    onRequest: (evt) => {\n      if (!evt.progress)\n        return;\n      const normalize = normalizer(\"upload\");\n      evt.progress.on(\n        \"progress\",\n        (prog) => evt.context.channels.progress.publish(normalize(prog))\n      );\n    }\n  };\n}\nvar __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nconst promise = (options = {}) => {\n  const PromiseImplementation = options.implementation || Promise;\n  if (!PromiseImplementation)\n    throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n  return {\n    onReturn: (channels, context) => new PromiseImplementation((resolve, reject) => {\n      const cancel = context.options.cancelToken;\n      cancel && cancel.promise.then((reason) => {\n        channels.abort.publish(reason), reject(reason);\n      }), channels.error.subscribe(reject), channels.response.subscribe((response) => {\n        resolve(options.onlyBody ? response.body : response);\n      }), setTimeout(() => {\n        try {\n          channels.request.publish(context);\n        } catch (err) {\n          reject(err);\n        }\n      }, 0);\n    })\n  };\n};\nclass Cancel {\n  constructor(message) {\n    __publicField(this, \"__CANCEL__\", !0), __publicField(this, \"message\"), this.message = message;\n  }\n  toString() {\n    return `Cancel${this.message ? `: ${this.message}` : \"\"}`;\n  }\n}\nconst _CancelToken = class {\n  constructor(executor) {\n    if (__publicField(this, \"promise\"), __publicField(this, \"reason\"), typeof executor != \"function\")\n      throw new TypeError(\"executor must be a function.\");\n    let resolvePromise = null;\n    this.promise = new Promise((resolve) => {\n      resolvePromise = resolve;\n    }), executor((message) => {\n      this.reason || (this.reason = new Cancel(message), resolvePromise(this.reason));\n    });\n  }\n};\n__publicField(_CancelToken, \"source\", () => {\n  let cancel;\n  return {\n    token: new _CancelToken((can) => {\n      cancel = can;\n    }),\n    cancel\n  };\n});\nlet CancelToken = _CancelToken;\nconst isCancel = (value) => !!(value && value != null && value.__CANCEL__);\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n  if (_proxy !== !1 && (!_proxy || !_proxy.host))\n    throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n  return {\n    processOptions: (options) => Object.assign({ proxy: _proxy }, options)\n  };\n}\nvar defaultShouldRetry = (err, _num, options) => options.method !== \"GET\" && options.method !== \"HEAD\" || err.response && err.response.statusCode ? !1 : is_retry_allowed__WEBPACK_IMPORTED_MODULE_5__(err);\nconst isStream = (stream) => stream !== null && typeof stream == \"object\" && typeof stream.pipe == \"function\";\nvar sharedRetry = (opts) => {\n  const maxRetries = opts.maxRetries || 5, retryDelay = opts.retryDelay || getRetryDelay, allowRetry = opts.shouldRetry;\n  return {\n    onError: (err, context) => {\n      const options = context.options, max = options.maxRetries || maxRetries, delay = options.retryDelay || retryDelay, shouldRetry = options.shouldRetry || allowRetry, attemptNumber = options.attemptNumber || 0;\n      if (isStream(options.body) || !shouldRetry(err, attemptNumber, options) || attemptNumber >= max)\n        return err;\n      const newContext = Object.assign({}, context, {\n        options: Object.assign({}, options, { attemptNumber: attemptNumber + 1 })\n      });\n      return setTimeout(() => context.channels.request.publish(newContext), delay(attemptNumber)), null;\n    }\n  };\n};\nfunction getRetryDelay(attemptNum) {\n  return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = (opts = {}) => sharedRetry({ shouldRetry: defaultShouldRetry, ...opts });\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n  const query = new URLSearchParams(), nest = (name, _value) => {\n    const value = _value instanceof Set ? Array.from(_value) : _value;\n    if (Array.isArray(value))\n      if (value.length)\n        for (const index in value)\n          nest(`${name}[${index}]`, value[index]);\n      else\n        query.append(`${name}[]`, \"\");\n    else if (typeof value == \"object\" && value !== null)\n      for (const [key, obj] of Object.entries(value))\n        nest(`${name}[${key}]`, obj);\n    else\n      query.append(name, value);\n  };\n  for (const [key, value] of Object.entries(data))\n    nest(key, value);\n  return query.toString();\n}\nfunction urlEncoded() {\n  return {\n    processOptions: (options) => {\n      const body = options.body;\n      return !body || !(typeof body.pipe != \"function\" && !isBuffer(body) && isPlainObject(body)) ? options : {\n        ...options,\n        body: encode(options.body),\n        headers: {\n          ...options.headers,\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        }\n      };\n    }\n  };\n}\nfunction buildKeepAlive(agent2) {\n  return function(config = {}) {\n    const ms2 = config.ms || 1e3, maxFree = config.maxFree || 256;\n    return agent2({\n      keepAlive: !0,\n      keepAliveMsecs: ms2,\n      maxFreeSockets: maxFree\n    });\n  };\n}\nconst keepAlive = buildKeepAlive(agent);\n\n//# sourceMappingURL=middleware.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBQ1k7QUFDdUM7QUFDbkQ7QUFDQztBQUNpQztBQUNsQjtBQUNOO0FBQ3ZDO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQUsseUJBQXlCLHdDQUFPLG1CQUFtQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYSxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYSxnQkFBZ0IsYUFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQVUsU0FBUyxpQ0FBVTtBQUM3QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0EscUVBQXFFLEVBQUUsc0JBQXNCLFdBQVcsSUFBSSxNQUFNO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVEQUF1RCxLQUFlO0FBQ3RFLHdEQUF3RCxnRUFBdUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCx3Q0FBd0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILHVEQUF1RDtBQUM5SztBQUNBO0FBQ0E7QUFDQSxtREFBbUQsc0JBQXNCO0FBQ3pFLGlCQUFpQixXQUFXLGNBQWMsY0FBYztBQUN4RCxtQkFBbUIsZ0JBQWdCLEVBQUUsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscU1BQXFNO0FBQ3JNO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixjQUFjLCtCQUErQjtBQUN2SSxLQUFLO0FBQ0wsaURBQWlEO0FBQ2pELCtCQUErQiw0QkFBNEI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQjtBQUNqRTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0Q0FBYyxHQUFHLFVBQVU7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCx1REFBdUQ7QUFDeEssNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0IsYUFBYSxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxlQUFlO0FBQ2hFO0FBQ0E7QUFDQSx5SkFBeUosNkNBQU87QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxpQ0FBaUMsYUFBYSxrQ0FBa0M7QUFDaEYsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQiwwQ0FBMEM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxHQUFHLE1BQU07QUFDaEM7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssR0FBRyxJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFzQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L21pZGRsZXdhcmUuanM/M2NmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZ2VudCB9IGZyb20gXCJodHRwXCI7XG5pbXBvcnQgeyBBZ2VudCBhcyBBZ2VudCQxIH0gZnJvbSBcImh0dHBzXCI7XG5pbXBvcnQgeyBnIGFzIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIH0gZnJvbSBcIi4vX2NodW5rcy1lcy9fY29tbW9uanNIZWxwZXJzLmpzXCI7XG5pbXBvcnQgcmVxdWlyZSQkMCBmcm9tIFwidHR5XCI7XG5pbXBvcnQgcmVxdWlyZSQkMSBmcm9tIFwidXRpbFwiO1xuaW1wb3J0IHsgcCwgdiB9IGZyb20gXCIuL19jaHVua3MtZXMvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IuanNcIjtcbmltcG9ydCBwcm9ncmVzc1N0cmVhbSBmcm9tIFwicHJvZ3Jlc3Mtc3RyZWFtXCI7XG5pbXBvcnQgYWxsb3dlZCBmcm9tIFwiaXMtcmV0cnktYWxsb3dlZFwiO1xuY29uc3QgaXNIdHRwc1Byb3RvID0gL15odHRwczovaTtcbmZ1bmN0aW9uIGFnZW50KG9wdHMpIHtcbiAgY29uc3QgaHR0cEFnZW50ID0gbmV3IEFnZW50KG9wdHMpLCBodHRwc0FnZW50ID0gbmV3IEFnZW50JDEob3B0cyksIGFnZW50cyA9IHsgaHR0cDogaHR0cEFnZW50LCBodHRwczogaHR0cHNBZ2VudCB9O1xuICByZXR1cm4ge1xuICAgIGZpbmFsaXplT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmFnZW50KVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLm1heFJlZGlyZWN0cyA+IDApXG4gICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIGFnZW50cyB9O1xuICAgICAgY29uc3QgaXNIdHRwcyA9IGlzSHR0cHNQcm90by50ZXN0KG9wdGlvbnMuaHJlZiB8fCBvcHRpb25zLnByb3RvY29sKTtcbiAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIGFnZW50OiBpc0h0dHBzID8gaHR0cHNBZ2VudCA6IGh0dHBBZ2VudCB9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGxlYWRpbmdTbGFzaCA9IC9eXFwvLywgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcbmZ1bmN0aW9uIGJhc2UoYmFzZVVybCkge1xuICBjb25zdCBiYXNlVXJpID0gYmFzZVVybC5yZXBsYWNlKHRyYWlsaW5nU2xhc2gsIFwiXCIpO1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3Qob3B0aW9ucy51cmwpKVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIGNvbnN0IHVybCA9IFtiYXNlVXJpLCBvcHRpb25zLnVybC5yZXBsYWNlKGxlYWRpbmdTbGFzaCwgXCJcIildLmpvaW4oXCIvXCIpO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdXJsIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBzcmMgPSB7IGV4cG9ydHM6IHt9IH0sIGJyb3dzZXIkMSA9IHsgZXhwb3J0czoge30gfSwgbXMsIGhhc1JlcXVpcmVkTXM7XG5mdW5jdGlvbiByZXF1aXJlTXMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZE1zKVxuICAgIHJldHVybiBtcztcbiAgaGFzUmVxdWlyZWRNcyA9IDE7XG4gIHZhciBzID0gMWUzLCBtID0gcyAqIDYwLCBoID0gbSAqIDYwLCBkID0gaCAqIDI0LCB3ID0gZCAqIDcsIHkgPSBkICogMzY1LjI1O1xuICBtcyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWwubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICAgIGlmICh0eXBlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbCkpXG4gICAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcInZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICAgKTtcbiAgfTtcbiAgZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gICAgaWYgKHN0ciA9IFN0cmluZyhzdHIpLCAhKHN0ci5sZW5ndGggPiAxMDApKSB7XG4gICAgICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgICAgIHN0clxuICAgICAgKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pLCB0eXBlID0gKG1hdGNoWzJdIHx8IFwibXNcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInllYXJzXCI6XG4gICAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgICBjYXNlIFwieXJzXCI6XG4gICAgICAgICAgY2FzZSBcInlyXCI6XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBuICogeTtcbiAgICAgICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgICAgICBjYXNlIFwid2Vla1wiOlxuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gbiAqIHc7XG4gICAgICAgICAgY2FzZSBcImRheXNcIjpcbiAgICAgICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBuICogZDtcbiAgICAgICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgICBjYXNlIFwiaG91clwiOlxuICAgICAgICAgIGNhc2UgXCJocnNcIjpcbiAgICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG4gKiBoO1xuICAgICAgICAgIGNhc2UgXCJtaW51dGVzXCI6XG4gICAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxuICAgICAgICAgIGNhc2UgXCJtaW5zXCI6XG4gICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gbiAqIG07XG4gICAgICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICAgICAgY2FzZSBcInNlY3NcIjpcbiAgICAgICAgICBjYXNlIFwic2VjXCI6XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBuICogcztcbiAgICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRzXCI6XG4gICAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XG4gICAgICAgICAgY2FzZSBcIm1zZWNzXCI6XG4gICAgICAgICAgY2FzZSBcIm1zZWNcIjpcbiAgICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZm10U2hvcnQobXMyKSB7XG4gICAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMyKTtcbiAgICByZXR1cm4gbXNBYnMgPj0gZCA/IE1hdGgucm91bmQobXMyIC8gZCkgKyBcImRcIiA6IG1zQWJzID49IGggPyBNYXRoLnJvdW5kKG1zMiAvIGgpICsgXCJoXCIgOiBtc0FicyA+PSBtID8gTWF0aC5yb3VuZChtczIgLyBtKSArIFwibVwiIDogbXNBYnMgPj0gcyA/IE1hdGgucm91bmQobXMyIC8gcykgKyBcInNcIiA6IG1zMiArIFwibXNcIjtcbiAgfVxuICBmdW5jdGlvbiBmbXRMb25nKG1zMikge1xuICAgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zMik7XG4gICAgcmV0dXJuIG1zQWJzID49IGQgPyBwbHVyYWwobXMyLCBtc0FicywgZCwgXCJkYXlcIikgOiBtc0FicyA+PSBoID8gcGx1cmFsKG1zMiwgbXNBYnMsIGgsIFwiaG91clwiKSA6IG1zQWJzID49IG0gPyBwbHVyYWwobXMyLCBtc0FicywgbSwgXCJtaW51dGVcIikgOiBtc0FicyA+PSBzID8gcGx1cmFsKG1zMiwgbXNBYnMsIHMsIFwic2Vjb25kXCIpIDogbXMyICsgXCIgbXNcIjtcbiAgfVxuICBmdW5jdGlvbiBwbHVyYWwobXMyLCBtc0FicywgbiwgbmFtZSkge1xuICAgIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMyIC8gbikgKyBcIiBcIiArIG5hbWUgKyAoaXNQbHVyYWwgPyBcInNcIiA6IFwiXCIpO1xuICB9XG4gIHJldHVybiBtcztcbn1cbnZhciBjb21tb24sIGhhc1JlcXVpcmVkQ29tbW9uO1xuZnVuY3Rpb24gcmVxdWlyZUNvbW1vbigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkQ29tbW9uKVxuICAgIHJldHVybiBjb21tb247XG4gIGhhc1JlcXVpcmVkQ29tbW9uID0gMTtcbiAgZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gICAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZywgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnLCBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2UsIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlLCBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGUsIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkLCBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmVNcygpLCBjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveSwgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgICB9KSwgY3JlYXRlRGVidWcubmFtZXMgPSBbXSwgY3JlYXRlRGVidWcuc2tpcHMgPSBbXSwgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAgIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgICAgbGV0IGhhc2ggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspXG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKSwgaGFzaCB8PSAwO1xuICAgICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICAgIH1cbiAgICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgICAgbGV0IHByZXZUaW1lLCBlbmFibGVPdmVycmlkZSA9IG51bGwsIG5hbWVzcGFjZXNDYWNoZSwgZW5hYmxlZENhY2hlO1xuICAgICAgZnVuY3Rpb24gZGVidWcyKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCFkZWJ1ZzIuZW5hYmxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNlbGYyID0gZGVidWcyLCBjdXJyID0gTnVtYmVyKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSwgbXMyID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgICAgc2VsZjIuZGlmZiA9IG1zMiwgc2VsZjIucHJldiA9IHByZXZUaW1lLCBzZWxmMi5jdXJyID0gY3VyciwgcHJldlRpbWUgPSBjdXJyLCBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pLCB0eXBlb2YgYXJnc1swXSAhPSBcInN0cmluZ1wiICYmIGFyZ3MudW5zaGlmdChcIiVPXCIpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IFwiJSVcIilcbiAgICAgICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmMiwgdmFsKSwgYXJncy5zcGxpY2UoaW5kZXgsIDEpLCBpbmRleC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH0pLCBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZjIsIGFyZ3MpLCAoc2VsZjIubG9nIHx8IGNyZWF0ZURlYnVnLmxvZykuYXBwbHkoc2VsZjIsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYnVnMi5uYW1lc3BhY2UgPSBuYW1lc3BhY2UsIGRlYnVnMi51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKSwgZGVidWcyLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKSwgZGVidWcyLmV4dGVuZCA9IGV4dGVuZCwgZGVidWcyLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcyLCBcImVuYWJsZWRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZ2V0OiAoKSA9PiBlbmFibGVPdmVycmlkZSAhPT0gbnVsbCA/IGVuYWJsZU92ZXJyaWRlIDogKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcyAmJiAobmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcywgZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpKSwgZW5hYmxlZENhY2hlKSxcbiAgICAgICAgc2V0OiAodjIpID0+IHtcbiAgICAgICAgICBlbmFibGVPdmVycmlkZSA9IHYyO1xuICAgICAgICB9XG4gICAgICB9KSwgdHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT0gXCJmdW5jdGlvblwiICYmIGNyZWF0ZURlYnVnLmluaXQoZGVidWcyKSwgZGVidWcyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA+IFwidVwiID8gXCI6XCIgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgICAgIHJldHVybiBuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZywgbmV3RGVidWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpLCBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcywgY3JlYXRlRGVidWcubmFtZXMgPSBbXSwgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICAgIGxldCBpO1xuICAgICAgY29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT0gXCJzdHJpbmdcIiA/IG5hbWVzcGFjZXMgOiBcIlwiKS5zcGxpdCgvW1xccyxdKy8pLCBsZW4gPSBzcGxpdC5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIHNwbGl0W2ldICYmIChuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csIFwiLio/XCIpLCBuYW1lc3BhY2VzWzBdID09PSBcIi1cIiA/IGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cChcIl5cIiArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyBcIiRcIikpIDogY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKFwiXlwiICsgbmFtZXNwYWNlcyArIFwiJFwiKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgY29uc3QgbmFtZXNwYWNlcyA9IFtcbiAgICAgICAgLi4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcbiAgICAgICAgLi4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAoKG5hbWVzcGFjZSkgPT4gXCItXCIgKyBuYW1lc3BhY2UpXG4gICAgICBdLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGNyZWF0ZURlYnVnLmVuYWJsZShcIlwiKSwgbmFtZXNwYWNlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSBcIipcIilcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgbGV0IGksIGxlbjtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcbiAgICAgIHJldHVybiByZWdleHAudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMikucmVwbGFjZSgvXFwuXFwqXFw/JC8sIFwiKlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEVycm9yID8gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlIDogdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpLCBjcmVhdGVEZWJ1ZztcbiAgfVxuICByZXR1cm4gY29tbW9uID0gc2V0dXAsIGNvbW1vbjtcbn1cbnZhciBoYXNSZXF1aXJlZEJyb3dzZXIkMTtcbmZ1bmN0aW9uIHJlcXVpcmVCcm93c2VyJDEoKSB7XG4gIHJldHVybiBoYXNSZXF1aXJlZEJyb3dzZXIkMSB8fCAoaGFzUmVxdWlyZWRCcm93c2VyJDEgPSAxLCBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzLCBleHBvcnRzLnNhdmUgPSBzYXZlLCBleHBvcnRzLmxvYWQgPSBsb2FkLCBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycywgZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCksIGV4cG9ydHMuZGVzdHJveSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgICAgbGV0IHdhcm5lZCA9ICExO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2FybmVkIHx8ICh3YXJuZWQgPSAhMCwgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKSk7XG4gICAgICB9O1xuICAgIH0pKCksIGV4cG9ydHMuY29sb3JzID0gW1xuICAgICAgXCIjMDAwMENDXCIsXG4gICAgICBcIiMwMDAwRkZcIixcbiAgICAgIFwiIzAwMzNDQ1wiLFxuICAgICAgXCIjMDAzM0ZGXCIsXG4gICAgICBcIiMwMDY2Q0NcIixcbiAgICAgIFwiIzAwNjZGRlwiLFxuICAgICAgXCIjMDA5OUNDXCIsXG4gICAgICBcIiMwMDk5RkZcIixcbiAgICAgIFwiIzAwQ0MwMFwiLFxuICAgICAgXCIjMDBDQzMzXCIsXG4gICAgICBcIiMwMENDNjZcIixcbiAgICAgIFwiIzAwQ0M5OVwiLFxuICAgICAgXCIjMDBDQ0NDXCIsXG4gICAgICBcIiMwMENDRkZcIixcbiAgICAgIFwiIzMzMDBDQ1wiLFxuICAgICAgXCIjMzMwMEZGXCIsXG4gICAgICBcIiMzMzMzQ0NcIixcbiAgICAgIFwiIzMzMzNGRlwiLFxuICAgICAgXCIjMzM2NkNDXCIsXG4gICAgICBcIiMzMzY2RkZcIixcbiAgICAgIFwiIzMzOTlDQ1wiLFxuICAgICAgXCIjMzM5OUZGXCIsXG4gICAgICBcIiMzM0NDMDBcIixcbiAgICAgIFwiIzMzQ0MzM1wiLFxuICAgICAgXCIjMzNDQzY2XCIsXG4gICAgICBcIiMzM0NDOTlcIixcbiAgICAgIFwiIzMzQ0NDQ1wiLFxuICAgICAgXCIjMzNDQ0ZGXCIsXG4gICAgICBcIiM2NjAwQ0NcIixcbiAgICAgIFwiIzY2MDBGRlwiLFxuICAgICAgXCIjNjYzM0NDXCIsXG4gICAgICBcIiM2NjMzRkZcIixcbiAgICAgIFwiIzY2Q0MwMFwiLFxuICAgICAgXCIjNjZDQzMzXCIsXG4gICAgICBcIiM5OTAwQ0NcIixcbiAgICAgIFwiIzk5MDBGRlwiLFxuICAgICAgXCIjOTkzM0NDXCIsXG4gICAgICBcIiM5OTMzRkZcIixcbiAgICAgIFwiIzk5Q0MwMFwiLFxuICAgICAgXCIjOTlDQzMzXCIsXG4gICAgICBcIiNDQzAwMDBcIixcbiAgICAgIFwiI0NDMDAzM1wiLFxuICAgICAgXCIjQ0MwMDY2XCIsXG4gICAgICBcIiNDQzAwOTlcIixcbiAgICAgIFwiI0NDMDBDQ1wiLFxuICAgICAgXCIjQ0MwMEZGXCIsXG4gICAgICBcIiNDQzMzMDBcIixcbiAgICAgIFwiI0NDMzMzM1wiLFxuICAgICAgXCIjQ0MzMzY2XCIsXG4gICAgICBcIiNDQzMzOTlcIixcbiAgICAgIFwiI0NDMzNDQ1wiLFxuICAgICAgXCIjQ0MzM0ZGXCIsXG4gICAgICBcIiNDQzY2MDBcIixcbiAgICAgIFwiI0NDNjYzM1wiLFxuICAgICAgXCIjQ0M5OTAwXCIsXG4gICAgICBcIiNDQzk5MzNcIixcbiAgICAgIFwiI0NDQ0MwMFwiLFxuICAgICAgXCIjQ0NDQzMzXCIsXG4gICAgICBcIiNGRjAwMDBcIixcbiAgICAgIFwiI0ZGMDAzM1wiLFxuICAgICAgXCIjRkYwMDY2XCIsXG4gICAgICBcIiNGRjAwOTlcIixcbiAgICAgIFwiI0ZGMDBDQ1wiLFxuICAgICAgXCIjRkYwMEZGXCIsXG4gICAgICBcIiNGRjMzMDBcIixcbiAgICAgIFwiI0ZGMzMzM1wiLFxuICAgICAgXCIjRkYzMzY2XCIsXG4gICAgICBcIiNGRjMzOTlcIixcbiAgICAgIFwiI0ZGMzNDQ1wiLFxuICAgICAgXCIjRkYzM0ZGXCIsXG4gICAgICBcIiNGRjY2MDBcIixcbiAgICAgIFwiI0ZGNjYzM1wiLFxuICAgICAgXCIjRkY5OTAwXCIsXG4gICAgICBcIiNGRjk5MzNcIixcbiAgICAgIFwiI0ZGQ0MwMFwiLFxuICAgICAgXCIjRkZDQzMzXCJcbiAgICBdO1xuICAgIGZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09IFwicmVuZGVyZXJcIiB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpID8gITAgOiB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykgPyAhMSA6IHR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICAgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHwgLy8gSXMgZmlyZWZveCA+PSB2MzE/XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gICAgICBpZiAoYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/IFwiJWNcIiA6IFwiXCIpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyBcIiAlY1wiIDogXCIgXCIpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/IFwiJWMgXCIgOiBcIiBcIikgKyBcIitcIiArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZiksICF0aGlzLnVzZUNvbG9ycylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYyA9IFwiY29sb3I6IFwiICsgdGhpcy5jb2xvcjtcbiAgICAgIGFyZ3Muc3BsaWNlKDEsIDAsIGMsIFwiY29sb3I6IGluaGVyaXRcIik7XG4gICAgICBsZXQgaW5kZXggPSAwLCBsYXN0QyA9IDA7XG4gICAgICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgKG1hdGNoKSA9PiB7XG4gICAgICAgIG1hdGNoICE9PSBcIiUlXCIgJiYgKGluZGV4KyssIG1hdGNoID09PSBcIiVjXCIgJiYgKGxhc3RDID0gaW5kZXgpKTtcbiAgICAgIH0pLCBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gICAgfVxuICAgIGV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmFtZXNwYWNlcyA/IGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKFwiZGVidWdcIiwgbmFtZXNwYWNlcykgOiBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbShcImRlYnVnXCIpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICBsZXQgcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICByZXR1cm4gIXIgJiYgdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiBcImVudlwiIGluIHByb2Nlc3MgJiYgKHIgPSBwcm9jZXNzLmVudi5ERUJVRyksIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlQ29tbW9uKCkoZXhwb3J0cyk7XG4gICAgY29uc3QgeyBmb3JtYXR0ZXJzIH0gPSBtb2R1bGUuZXhwb3J0cztcbiAgICBmb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2Mikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBcIltVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiBcIiArIGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfShicm93c2VyJDEsIGJyb3dzZXIkMS5leHBvcnRzKSksIGJyb3dzZXIkMS5leHBvcnRzO1xufVxudmFyIG5vZGUgPSB7IGV4cG9ydHM6IHt9IH0sIGJyb3dzZXIsIGhhc1JlcXVpcmVkQnJvd3NlcjtcbmZ1bmN0aW9uIHJlcXVpcmVCcm93c2VyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRCcm93c2VyKVxuICAgIHJldHVybiBicm93c2VyO1xuICBoYXNSZXF1aXJlZEJyb3dzZXIgPSAxO1xuICBmdW5jdGlvbiBnZXRDaHJvbWVWZXJzaW9uKCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSAvKENocm9tZXxDaHJvbWl1bSlcXC8oPzxjaHJvbWVWZXJzaW9uPlxcZCspXFwuLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIGlmIChtYXRjaGVzKVxuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaGVzLmdyb3Vwcy5jaHJvbWVWZXJzaW9uLCAxMCk7XG4gIH1cbiAgY29uc3QgY29sb3JTdXBwb3J0ID0gZ2V0Q2hyb21lVmVyc2lvbigpID49IDY5ID8ge1xuICAgIGxldmVsOiAxLFxuICAgIGhhc0Jhc2ljOiAhMCxcbiAgICBoYXMyNTY6ICExLFxuICAgIGhhczE2bTogITFcbiAgfSA6ICExO1xuICByZXR1cm4gYnJvd3NlciA9IHtcbiAgICBzdGRvdXQ6IGNvbG9yU3VwcG9ydCxcbiAgICBzdGRlcnI6IGNvbG9yU3VwcG9ydFxuICB9LCBicm93c2VyO1xufVxudmFyIGhhc1JlcXVpcmVkTm9kZTtcbmZ1bmN0aW9uIHJlcXVpcmVOb2RlKCkge1xuICByZXR1cm4gaGFzUmVxdWlyZWROb2RlIHx8IChoYXNSZXF1aXJlZE5vZGUgPSAxLCBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICBjb25zdCB0dHkgPSByZXF1aXJlJCQwLCB1dGlsID0gcmVxdWlyZSQkMTtcbiAgICBleHBvcnRzLmluaXQgPSBpbml0LCBleHBvcnRzLmxvZyA9IGxvZywgZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncywgZXhwb3J0cy5zYXZlID0gc2F2ZSwgZXhwb3J0cy5sb2FkID0gbG9hZCwgZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnMsIGV4cG9ydHMuZGVzdHJveSA9IHV0aWwuZGVwcmVjYXRlKFxuICAgICAgKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiXG4gICAgKSwgZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlQnJvd3NlcigpO1xuICAgICAgc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMiAmJiAoZXhwb3J0cy5jb2xvcnMgPSBbXG4gICAgICAgIDIwLFxuICAgICAgICAyMSxcbiAgICAgICAgMjYsXG4gICAgICAgIDI3LFxuICAgICAgICAzMixcbiAgICAgICAgMzMsXG4gICAgICAgIDM4LFxuICAgICAgICAzOSxcbiAgICAgICAgNDAsXG4gICAgICAgIDQxLFxuICAgICAgICA0MixcbiAgICAgICAgNDMsXG4gICAgICAgIDQ0LFxuICAgICAgICA0NSxcbiAgICAgICAgNTYsXG4gICAgICAgIDU3LFxuICAgICAgICA2MixcbiAgICAgICAgNjMsXG4gICAgICAgIDY4LFxuICAgICAgICA2OSxcbiAgICAgICAgNzQsXG4gICAgICAgIDc1LFxuICAgICAgICA3NixcbiAgICAgICAgNzcsXG4gICAgICAgIDc4LFxuICAgICAgICA3OSxcbiAgICAgICAgODAsXG4gICAgICAgIDgxLFxuICAgICAgICA5MixcbiAgICAgICAgOTMsXG4gICAgICAgIDk4LFxuICAgICAgICA5OSxcbiAgICAgICAgMTEyLFxuICAgICAgICAxMTMsXG4gICAgICAgIDEyOCxcbiAgICAgICAgMTI5LFxuICAgICAgICAxMzQsXG4gICAgICAgIDEzNSxcbiAgICAgICAgMTQ4LFxuICAgICAgICAxNDksXG4gICAgICAgIDE2MCxcbiAgICAgICAgMTYxLFxuICAgICAgICAxNjIsXG4gICAgICAgIDE2MyxcbiAgICAgICAgMTY0LFxuICAgICAgICAxNjUsXG4gICAgICAgIDE2NixcbiAgICAgICAgMTY3LFxuICAgICAgICAxNjgsXG4gICAgICAgIDE2OSxcbiAgICAgICAgMTcwLFxuICAgICAgICAxNzEsXG4gICAgICAgIDE3MixcbiAgICAgICAgMTczLFxuICAgICAgICAxNzgsXG4gICAgICAgIDE3OSxcbiAgICAgICAgMTg0LFxuICAgICAgICAxODUsXG4gICAgICAgIDE5NixcbiAgICAgICAgMTk3LFxuICAgICAgICAxOTgsXG4gICAgICAgIDE5OSxcbiAgICAgICAgMjAwLFxuICAgICAgICAyMDEsXG4gICAgICAgIDIwMixcbiAgICAgICAgMjAzLFxuICAgICAgICAyMDQsXG4gICAgICAgIDIwNSxcbiAgICAgICAgMjA2LFxuICAgICAgICAyMDcsXG4gICAgICAgIDIwOCxcbiAgICAgICAgMjA5LFxuICAgICAgICAyMTQsXG4gICAgICAgIDIxNSxcbiAgICAgICAgMjIwLFxuICAgICAgICAyMjFcbiAgICAgIF0pO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICBleHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcigoa2V5KSA9PiAvXmRlYnVnXy9pLnRlc3Qoa2V5KSkucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgY29uc3QgcHJvcCA9IGtleS5zdWJzdHJpbmcoNikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4gay50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIGxldCB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuICAgICAgcmV0dXJuIC9eKHllc3xvbnx0cnVlfGVuYWJsZWQpJC9pLnRlc3QodmFsKSA/IHZhbCA9ICEwIDogL14obm98b2ZmfGZhbHNlfGRpc2FibGVkKSQvaS50ZXN0KHZhbCkgPyB2YWwgPSAhMSA6IHZhbCA9PT0gXCJudWxsXCIgPyB2YWwgPSBudWxsIDogdmFsID0gTnVtYmVyKHZhbCksIG9ialtwcm9wXSA9IHZhbCwgb2JqO1xuICAgIH0sIHt9KTtcbiAgICBmdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gICAgICByZXR1cm4gXCJjb2xvcnNcIiBpbiBleHBvcnRzLmluc3BlY3RPcHRzID8gISFleHBvcnRzLmluc3BlY3RPcHRzLmNvbG9ycyA6IHR0eS5pc2F0dHkocHJvY2Vzcy5zdGRlcnIuZmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgICAgIGNvbnN0IHsgbmFtZXNwYWNlOiBuYW1lLCB1c2VDb2xvcnM6IHVzZUNvbG9yczIgfSA9IHRoaXM7XG4gICAgICBpZiAodXNlQ29sb3JzMikge1xuICAgICAgICBjb25zdCBjID0gdGhpcy5jb2xvciwgY29sb3JDb2RlID0gXCJcXHgxQlszXCIgKyAoYyA8IDggPyBjIDogXCI4OzU7XCIgKyBjKSwgcHJlZml4ID0gYCAgJHtjb2xvckNvZGV9OzFtJHtuYW1lfSBcXHgxQlswbWA7XG4gICAgICAgIGFyZ3NbMF0gPSBwcmVmaXggKyBhcmdzWzBdLnNwbGl0KGBcbmApLmpvaW4oYFxuYCArIHByZWZpeCksIGFyZ3MucHVzaChjb2xvckNvZGUgKyBcIm0rXCIgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgXCJcXHgxQlswbVwiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArIFwiIFwiICsgYXJnc1swXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlID8gXCJcIiA6ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkudG9JU09TdHJpbmcoKSArIFwiIFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2coLi4uYXJncykge1xuICAgICAgcmV0dXJuIHByb2Nlc3Muc3RkZXJyLndyaXRlKHV0aWwuZm9ybWF0KC4uLmFyZ3MpICsgYFxuYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICAgICAgbmFtZXNwYWNlcyA/IHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcyA6IGRlbGV0ZSBwcm9jZXNzLmVudi5ERUJVRztcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChkZWJ1ZzIpIHtcbiAgICAgIGRlYnVnMi5pbnNwZWN0T3B0cyA9IHt9O1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKVxuICAgICAgICBkZWJ1ZzIuaW5zcGVjdE9wdHNba2V5c1tpXV0gPSBleHBvcnRzLmluc3BlY3RPcHRzW2tleXNbaV1dO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmVDb21tb24oKShleHBvcnRzKTtcbiAgICBjb25zdCB7IGZvcm1hdHRlcnMgfSA9IG1vZHVsZS5leHBvcnRzO1xuICAgIGZvcm1hdHRlcnMubyA9IGZ1bmN0aW9uKHYyKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycywgdXRpbC5pbnNwZWN0KHYyLCB0aGlzLmluc3BlY3RPcHRzKS5zcGxpdChgXG5gKS5tYXAoKHN0cikgPT4gc3RyLnRyaW0oKSkuam9pbihcIiBcIik7XG4gICAgfSwgZm9ybWF0dGVycy5PID0gZnVuY3Rpb24odjIpIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzLCB1dGlsLmluc3BlY3QodjIsIHRoaXMuaW5zcGVjdE9wdHMpO1xuICAgIH07XG4gIH0obm9kZSwgbm9kZS5leHBvcnRzKSksIG5vZGUuZXhwb3J0cztcbn1cbnR5cGVvZiBwcm9jZXNzID4gXCJ1XCIgfHwgcHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIgfHwgcHJvY2Vzcy5icm93c2VyID09PSAhMCB8fCBwcm9jZXNzLl9fbndqcyA/IHNyYy5leHBvcnRzID0gcmVxdWlyZUJyb3dzZXIkMSgpIDogc3JjLmV4cG9ydHMgPSByZXF1aXJlTm9kZSgpO1xudmFyIHNyY0V4cG9ydHMgPSBzcmMuZXhwb3J0cywgZGVidWdJdCA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzcmNFeHBvcnRzKTtcbmNvbnN0IFNFTlNJVElWRV9IRUFERVJTID0gW1wiY29va2llXCIsIFwiYXV0aG9yaXphdGlvblwiXSwgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgcmVkYWN0S2V5cyA9IChzb3VyY2UsIHJlZGFjdGVkKSA9PiB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpXG4gICAgaGFzT3duLmNhbGwoc291cmNlLCBrZXkpICYmICh0YXJnZXRba2V5XSA9IHJlZGFjdGVkLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID4gLTEgPyBcIjxyZWRhY3RlZD5cIiA6IHNvdXJjZVtrZXldKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG5mdW5jdGlvbiBkZWJ1ZyhvcHRzID0ge30pIHtcbiAgY29uc3QgdmVyYm9zZSA9IG9wdHMudmVyYm9zZSwgbmFtZXNwYWNlID0gb3B0cy5uYW1lc3BhY2UgfHwgXCJnZXQtaXRcIiwgZGVmYXVsdExvZ2dlciA9IGRlYnVnSXQobmFtZXNwYWNlKSwgbG9nID0gb3B0cy5sb2cgfHwgZGVmYXVsdExvZ2dlciwgc2hvcnRDaXJjdWl0ID0gbG9nID09PSBkZWZhdWx0TG9nZ2VyICYmICFkZWJ1Z0l0LmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgbGV0IHJlcXVlc3RJZCA9IDA7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiAob3B0aW9ucy5kZWJ1ZyA9IGxvZywgb3B0aW9ucy5yZXF1ZXN0SWQgPSBvcHRpb25zLnJlcXVlc3RJZCB8fCArK3JlcXVlc3RJZCwgb3B0aW9ucyksXG4gICAgb25SZXF1ZXN0OiAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIWV2ZW50KVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQub3B0aW9ucztcbiAgICAgIGlmIChsb2coXCJbJXNdIEhUVFAgJXMgJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCksIHZlcmJvc2UgJiYgb3B0aW9ucy5ib2R5ICYmIHR5cGVvZiBvcHRpb25zLmJvZHkgPT0gXCJzdHJpbmdcIiAmJiBsb2coXCJbJXNdIFJlcXVlc3QgYm9keTogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMuYm9keSksIHZlcmJvc2UgJiYgb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMyID0gb3B0cy5yZWRhY3RTZW5zaXRpdmVIZWFkZXJzID09PSAhMSA/IG9wdGlvbnMuaGVhZGVycyA6IHJlZGFjdEtleXMob3B0aW9ucy5oZWFkZXJzLCBTRU5TSVRJVkVfSEVBREVSUyk7XG4gICAgICAgIGxvZyhcIlslc10gUmVxdWVzdCBoZWFkZXJzOiAlc1wiLCBvcHRpb25zLnJlcXVlc3RJZCwgSlNPTi5zdHJpbmdpZnkoaGVhZGVyczIsIG51bGwsIDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2U6IChyZXMsIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIXJlcylcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIHJldHVybiBsb2coXCJbJXNdIFJlc3BvbnNlIGNvZGU6ICVzICVzXCIsIHJlcUlkLCByZXMuc3RhdHVzQ29kZSwgcmVzLnN0YXR1c01lc3NhZ2UpLCB2ZXJib3NlICYmIHJlcy5ib2R5ICYmIGxvZyhcIlslc10gUmVzcG9uc2UgYm9keTogJXNcIiwgcmVxSWQsIHN0cmluZ2lmeUJvZHkocmVzKSksIHJlcztcbiAgICB9LFxuICAgIG9uRXJyb3I6IChlcnIsIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IHJlcUlkID0gY29udGV4dC5vcHRpb25zLnJlcXVlc3RJZDtcbiAgICAgIHJldHVybiBlcnIgPyAobG9nKFwiWyVzXSBFUlJPUjogJXNcIiwgcmVxSWQsIGVyci5tZXNzYWdlKSwgZXJyKSA6IChsb2coXCJbJXNdIEVycm9yIGVuY291bnRlcmVkLCBidXQgaGFuZGxlZCBieSBhbiBlYXJsaWVyIG1pZGRsZXdhcmVcIiwgcmVxSWQpLCBlcnIpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJvZHkocmVzKSB7XG4gIHJldHVybiAocmVzLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTEgPyB0cnlGb3JtYXQocmVzLmJvZHkpIDogcmVzLmJvZHk7XG59XG5mdW5jdGlvbiB0cnlGb3JtYXQoYm9keSkge1xuICB0cnkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHR5cGVvZiBib2R5ID09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGJvZHkpIDogYm9keTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkLCBudWxsLCAyKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhlYWRlcnMoX2hlYWRlcnMsIG9wdHMgPSB7fSkge1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiAob3B0aW9ucykgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICByZXR1cm4gb3B0aW9ucy5oZWFkZXJzID0gb3B0cy5vdmVycmlkZSA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBfaGVhZGVycykgOiBPYmplY3QuYXNzaWduKHt9LCBfaGVhZGVycywgZXhpc3RpbmcpLCBvcHRpb25zO1xuICAgIH1cbiAgfTtcbn1cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDEob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkJDEgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wJDEob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmNsYXNzIEh0dHBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzLCBjdHgpIHtcbiAgICBzdXBlcigpLCBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJyZXNwb25zZVwiKSwgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwicmVxdWVzdFwiKTtcbiAgICBjb25zdCB0cnVuY2F0ZWRVcmwgPSByZXMudXJsLmxlbmd0aCA+IDQwMCA/IGAke3Jlcy51cmwuc2xpY2UoMCwgMzk5KX1cXHUyMDI2YCA6IHJlcy51cmw7XG4gICAgbGV0IG1zZyA9IGAke3Jlcy5tZXRob2R9LXJlcXVlc3QgdG8gJHt0cnVuY2F0ZWRVcmx9IHJlc3VsdGVkIGluIGA7XG4gICAgbXNnICs9IGBIVFRQICR7cmVzLnN0YXR1c0NvZGV9ICR7cmVzLnN0YXR1c01lc3NhZ2V9YCwgdGhpcy5tZXNzYWdlID0gbXNnLnRyaW0oKSwgdGhpcy5yZXNwb25zZSA9IHJlcywgdGhpcy5yZXF1ZXN0ID0gY3R4Lm9wdGlvbnM7XG4gIH1cbn1cbmZ1bmN0aW9uIGh0dHBFcnJvcnMoKSB7XG4gIHJldHVybiB7XG4gICAgb25SZXNwb25zZTogKHJlcywgY3R4KSA9PiB7XG4gICAgICBpZiAoIShyZXMuc3RhdHVzQ29kZSA+PSA0MDApKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihyZXMsIGN0eCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5qZWN0UmVzcG9uc2Uob3B0cyA9IHt9KSB7XG4gIGlmICh0eXBlb2Ygb3B0cy5pbmplY3QgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImBpbmplY3RSZXNwb25zZWAgbWlkZGxld2FyZSByZXF1aXJlcyBhIGBpbmplY3RgIGZ1bmN0aW9uXCIpO1xuICByZXR1cm4geyBpbnRlcmNlcHRSZXF1ZXN0OiBmdW5jdGlvbihwcmV2VmFsdWUsIGV2ZW50KSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBvcHRzLmluamVjdChldmVudCwgcHJldlZhbHVlKTtcbiAgICBpZiAoIXJlc3BvbnNlKVxuICAgICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgICBjb25zdCBvcHRpb25zID0gZXZlbnQuY29udGV4dC5vcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICBib2R5OiBcIlwiLFxuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgIHN0YXR1c01lc3NhZ2U6IFwiT0tcIixcbiAgICAgIC4uLnJlc3BvbnNlXG4gICAgfTtcbiAgfSB9O1xufVxuY29uc3QgaXNCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID4gXCJ1XCIgPyAoKSA9PiAhMSA6IChvYmopID0+IEJ1ZmZlci5pc0J1ZmZlcihvYmopO1xuLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICBpZiAoaXNPYmplY3QobykgPT09ICExKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB2b2lkIDApXG4gICAgcmV0dXJuICEwO1xuICBjb25zdCBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIHJldHVybiAhKGlzT2JqZWN0KHByb3QpID09PSAhMSB8fCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHByb3QuaGFzT3duUHJvcGVydHkoXCJpc1Byb3RvdHlwZU9mXCIpID09PSAhMSk7XG59XG5jb25zdCBzZXJpYWxpemVUeXBlcyA9IFtcImJvb2xlYW5cIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIl07XG5mdW5jdGlvbiBqc29uUmVxdWVzdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICByZXR1cm4gIWJvZHkgfHwgISh0eXBlb2YgYm9keS5waXBlICE9IFwiZnVuY3Rpb25cIiAmJiAhaXNCdWZmZXIoYm9keSkgJiYgKHNlcmlhbGl6ZVR5cGVzLmluZGV4T2YodHlwZW9mIGJvZHkpICE9PSAtMSB8fCBBcnJheS5pc0FycmF5KGJvZHkpIHx8IGlzUGxhaW5PYmplY3QoYm9keSkpKSA/IG9wdGlvbnMgOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuYm9keSksXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBqc29uUmVzcG9uc2Uob3B0cykge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCIsIHNob3VsZERlY29kZSA9IG9wdHMgJiYgb3B0cy5mb3JjZSB8fCBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTE7XG4gICAgICByZXR1cm4gIXJlc3BvbnNlLmJvZHkgfHwgIWNvbnRlbnRUeXBlIHx8ICFzaG91bGREZWNvZGUgPyByZXNwb25zZSA6IE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlLCB7IGJvZHk6IHRyeVBhcnNlKHJlc3BvbnNlLmJvZHkpIH0pO1xuICAgIH0sXG4gICAgcHJvY2Vzc09wdGlvbnM6IChvcHRpb25zKSA9PiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBvcHRpb25zLmhlYWRlcnMpXG4gICAgfSlcbiAgfTtcbiAgZnVuY3Rpb24gdHJ5UGFyc2UoYm9keSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVyci5tZXNzYWdlID0gYEZhaWxlZCB0byBwYXJzZWQgcmVzcG9uc2UgYm9keSBhcyBKU09OOiAke2Vyci5tZXNzYWdlfWAsIGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQnJvd3Nlck9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT0gXCJvYmplY3RcIiAmJiBvcHRpb25zICE9PSBudWxsICYmICEoXCJwcm90b2NvbFwiIGluIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gbXRscyhjb25maWcgPSB7fSkge1xuICBpZiAoIWNvbmZpZy5jYSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwiY2FcIiBpcyBtaXNzaW5nJyk7XG4gIGlmICghY29uZmlnLmNlcnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNlcnRcIiBpcyBtaXNzaW5nJyk7XG4gIGlmICghY29uZmlnLmtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIG10bHMgb3B0aW9uIFwia2V5XCIgaXMgbWlzc2luZycpO1xuICByZXR1cm4ge1xuICAgIGZpbmFsaXplT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChpc0Jyb3dzZXJPcHRpb25zKG9wdGlvbnMpKVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIGNvbnN0IG10bHNPcHRzID0ge1xuICAgICAgICBjZXJ0OiBjb25maWcuY2VydCxcbiAgICAgICAga2V5OiBjb25maWcua2V5LFxuICAgICAgICBjYTogY29uZmlnLmNhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIG10bHNPcHRzKTtcbiAgICB9XG4gIH07XG59XG5sZXQgYWN0dWFsR2xvYmFsID0ge307XG50eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gYWN0dWFsR2xvYmFsID0gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IGFjdHVhbEdsb2JhbCA9IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGFjdHVhbEdsb2JhbCA9IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgJiYgKGFjdHVhbEdsb2JhbCA9IHNlbGYpO1xudmFyIGdsb2JhbCQxID0gYWN0dWFsR2xvYmFsO1xuZnVuY3Rpb24gb2JzZXJ2YWJsZShvcHRzID0ge30pIHtcbiAgY29uc3QgT2JzZXJ2YWJsZSA9IChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBAVE9ETyBjb25zaWRlciBkcm9wcGluZyBjaGVja2luZyBmb3IgYSBnbG9iYWwgT2JzZXJ2YWJsZSBzaW5jZSBpdCdzIG5vdCBvbiBhIHN0YW5kYXJkcyB0cmFja1xuICAgIG9wdHMuaW1wbGVtZW50YXRpb24gfHwgZ2xvYmFsJDEuT2JzZXJ2YWJsZVxuICApO1xuICBpZiAoIU9ic2VydmFibGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgT2JzZXJ2YWJsZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCJcbiAgICApO1xuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4gKGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZSgoZXJyKSA9PiBvYnNlcnZlci5lcnJvcihlcnIpKSwgY2hhbm5lbHMucHJvZ3Jlc3Muc3Vic2NyaWJlKFxuICAgICAgKGV2ZW50KSA9PiBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInByb2dyZXNzXCIgfSwgZXZlbnQpKVxuICAgICksIGNoYW5uZWxzLnJlc3BvbnNlLnN1YnNjcmliZSgocmVzcG9uc2UpID0+IHtcbiAgICAgIG9ic2VydmVyLm5leHQoT2JqZWN0LmFzc2lnbih7IHR5cGU6IFwicmVzcG9uc2VcIiB9LCByZXNwb25zZSkpLCBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH0pLCBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCksICgpID0+IGNoYW5uZWxzLmFib3J0LnB1Ymxpc2goKSkpXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVyKHN0YWdlKSB7XG4gIHJldHVybiAocHJvZykgPT4gKHtcbiAgICBzdGFnZSxcbiAgICBwZXJjZW50OiBwcm9nLnBlcmNlbnRhZ2UsXG4gICAgdG90YWw6IHByb2cubGVuZ3RoLFxuICAgIGxvYWRlZDogcHJvZy50cmFuc2ZlcnJlZCxcbiAgICBsZW5ndGhDb21wdXRhYmxlOiAhKHByb2cubGVuZ3RoID09PSAwICYmIHByb2cucGVyY2VudGFnZSA9PT0gMClcbiAgfSk7XG59XG5mdW5jdGlvbiBwcm9ncmVzcygpIHtcbiAgcmV0dXJuIHtcbiAgICBvbkhlYWRlcnM6IChyZXNwb25zZSwgZXZ0KSA9PiB7XG4gICAgICBjb25zdCBfcHJvZ3Jlc3MgPSBwcm9ncmVzc1N0cmVhbSh7IHRpbWU6IDE2IH0pLCBub3JtYWxpemUgPSBub3JtYWxpemVyKFwiZG93bmxvYWRcIiksIGNvbnRlbnRMZW5ndGggPSByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0sIGxlbmd0aCA9IGNvbnRlbnRMZW5ndGggPyBOdW1iZXIoY29udGVudExlbmd0aCkgOiAwO1xuICAgICAgcmV0dXJuICFpc05hTihsZW5ndGgpICYmIGxlbmd0aCA+IDAgJiYgX3Byb2dyZXNzLnNldExlbmd0aChsZW5ndGgpLCBfcHJvZ3Jlc3Mub24oXCJwcm9ncmVzc1wiLCAocHJvZykgPT4gZXZ0LmNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaChub3JtYWxpemUocHJvZykpKSwgcmVzcG9uc2UucGlwZShfcHJvZ3Jlc3MpO1xuICAgIH0sXG4gICAgb25SZXF1ZXN0OiAoZXZ0KSA9PiB7XG4gICAgICBpZiAoIWV2dC5wcm9ncmVzcylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3Qgbm9ybWFsaXplID0gbm9ybWFsaXplcihcInVwbG9hZFwiKTtcbiAgICAgIGV2dC5wcm9ncmVzcy5vbihcbiAgICAgICAgXCJwcm9ncmVzc1wiLFxuICAgICAgICAocHJvZykgPT4gZXZ0LmNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaChub3JtYWxpemUocHJvZykpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gKF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKSwgdmFsdWUpO1xuY29uc3QgcHJvbWlzZSA9IChvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgUHJvbWlzZUltcGxlbWVudGF0aW9uID0gb3B0aW9ucy5pbXBsZW1lbnRhdGlvbiB8fCBQcm9taXNlO1xuICBpZiAoIVByb21pc2VJbXBsZW1lbnRhdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgUHJvbWlzZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCIpO1xuICByZXR1cm4ge1xuICAgIG9uUmV0dXJuOiAoY2hhbm5lbHMsIGNvbnRleHQpID0+IG5ldyBQcm9taXNlSW1wbGVtZW50YXRpb24oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FuY2VsID0gY29udGV4dC5vcHRpb25zLmNhbmNlbFRva2VuO1xuICAgICAgY2FuY2VsICYmIGNhbmNlbC5wcm9taXNlLnRoZW4oKHJlYXNvbikgPT4ge1xuICAgICAgICBjaGFubmVscy5hYm9ydC5wdWJsaXNoKHJlYXNvbiksIHJlamVjdChyZWFzb24pO1xuICAgICAgfSksIGNoYW5uZWxzLmVycm9yLnN1YnNjcmliZShyZWplY3QpLCBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIHJlc29sdmUob3B0aW9ucy5vbmx5Qm9keSA/IHJlc3BvbnNlLmJvZHkgOiByZXNwb25zZSk7XG4gICAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfSlcbiAgfTtcbn07XG5jbGFzcyBDYW5jZWwge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIl9fQ0FOQ0VMX19cIiwgITApLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWVzc2FnZVwiKSwgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYENhbmNlbCR7dGhpcy5tZXNzYWdlID8gYDogJHt0aGlzLm1lc3NhZ2V9YCA6IFwiXCJ9YDtcbiAgfVxufVxuY29uc3QgX0NhbmNlbFRva2VuID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmIChfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvbWlzZVwiKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlYXNvblwiKSwgdHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIGxldCByZXNvbHZlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICB9KSwgZXhlY3V0b3IoKG1lc3NhZ2UpID0+IHtcbiAgICAgIHRoaXMucmVhc29uIHx8ICh0aGlzLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSksIHJlc29sdmVQcm9taXNlKHRoaXMucmVhc29uKSk7XG4gICAgfSk7XG4gIH1cbn07XG5fX3B1YmxpY0ZpZWxkKF9DYW5jZWxUb2tlbiwgXCJzb3VyY2VcIiwgKCkgPT4ge1xuICBsZXQgY2FuY2VsO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiBuZXcgX0NhbmNlbFRva2VuKChjYW4pID0+IHtcbiAgICAgIGNhbmNlbCA9IGNhbjtcbiAgICB9KSxcbiAgICBjYW5jZWxcbiAgfTtcbn0pO1xubGV0IENhbmNlbFRva2VuID0gX0NhbmNlbFRva2VuO1xuY29uc3QgaXNDYW5jZWwgPSAodmFsdWUpID0+ICEhKHZhbHVlICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG5wcm9taXNlLkNhbmNlbCA9IENhbmNlbDtcbnByb21pc2UuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbnByb21pc2UuaXNDYW5jZWwgPSBpc0NhbmNlbDtcbmZ1bmN0aW9uIHByb3h5KF9wcm94eSkge1xuICBpZiAoX3Byb3h5ICE9PSAhMSAmJiAoIV9wcm94eSB8fCAhX3Byb3h5Lmhvc3QpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IG1pZGRsZXdhcmUgdGFrZXMgYW4gb2JqZWN0IG9mIGhvc3QsIHBvcnQgYW5kIGF1dGggcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IE9iamVjdC5hc3NpZ24oeyBwcm94eTogX3Byb3h5IH0sIG9wdGlvbnMpXG4gIH07XG59XG52YXIgZGVmYXVsdFNob3VsZFJldHJ5ID0gKGVyciwgX251bSwgb3B0aW9ucykgPT4gb3B0aW9ucy5tZXRob2QgIT09IFwiR0VUXCIgJiYgb3B0aW9ucy5tZXRob2QgIT09IFwiSEVBRFwiIHx8IGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA/ICExIDogYWxsb3dlZChlcnIpO1xuY29uc3QgaXNTdHJlYW0gPSAoc3RyZWFtKSA9PiBzdHJlYW0gIT09IG51bGwgJiYgdHlwZW9mIHN0cmVhbSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBzdHJlYW0ucGlwZSA9PSBcImZ1bmN0aW9uXCI7XG52YXIgc2hhcmVkUmV0cnkgPSAob3B0cykgPT4ge1xuICBjb25zdCBtYXhSZXRyaWVzID0gb3B0cy5tYXhSZXRyaWVzIHx8IDUsIHJldHJ5RGVsYXkgPSBvcHRzLnJldHJ5RGVsYXkgfHwgZ2V0UmV0cnlEZWxheSwgYWxsb3dSZXRyeSA9IG9wdHMuc2hvdWxkUmV0cnk7XG4gIHJldHVybiB7XG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucywgbWF4ID0gb3B0aW9ucy5tYXhSZXRyaWVzIHx8IG1heFJldHJpZXMsIGRlbGF5ID0gb3B0aW9ucy5yZXRyeURlbGF5IHx8IHJldHJ5RGVsYXksIHNob3VsZFJldHJ5ID0gb3B0aW9ucy5zaG91bGRSZXRyeSB8fCBhbGxvd1JldHJ5LCBhdHRlbXB0TnVtYmVyID0gb3B0aW9ucy5hdHRlbXB0TnVtYmVyIHx8IDA7XG4gICAgICBpZiAoaXNTdHJlYW0ob3B0aW9ucy5ib2R5KSB8fCAhc2hvdWxkUmV0cnkoZXJyLCBhdHRlbXB0TnVtYmVyLCBvcHRpb25zKSB8fCBhdHRlbXB0TnVtYmVyID49IG1heClcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LCB7XG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgYXR0ZW1wdE51bWJlcjogYXR0ZW1wdE51bWJlciArIDEgfSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4gY29udGV4dC5jaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2gobmV3Q29udGV4dCksIGRlbGF5KGF0dGVtcHROdW1iZXIpKSwgbnVsbDtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheShhdHRlbXB0TnVtKSB7XG4gIHJldHVybiAxMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0TnVtKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG59XG5jb25zdCByZXRyeSA9IChvcHRzID0ge30pID0+IHNoYXJlZFJldHJ5KHsgc2hvdWxkUmV0cnk6IGRlZmF1bHRTaG91bGRSZXRyeSwgLi4ub3B0cyB9KTtcbnJldHJ5LnNob3VsZFJldHJ5ID0gZGVmYXVsdFNob3VsZFJldHJ5O1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIG5lc3QgPSAobmFtZSwgX3ZhbHVlKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBfdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBBcnJheS5mcm9tKF92YWx1ZSkgOiBfdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgaWYgKHZhbHVlLmxlbmd0aClcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiB2YWx1ZSlcbiAgICAgICAgICBuZXN0KGAke25hbWV9WyR7aW5kZXh9XWAsIHZhbHVlW2luZGV4XSk7XG4gICAgICBlbHNlXG4gICAgICAgIHF1ZXJ5LmFwcGVuZChgJHtuYW1lfVtdYCwgXCJcIik7XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIG9ial0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKVxuICAgICAgICBuZXN0KGAke25hbWV9WyR7a2V5fV1gLCBvYmopO1xuICAgIGVsc2VcbiAgICAgIHF1ZXJ5LmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gIH07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKVxuICAgIG5lc3Qoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiBxdWVyeS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdXJsRW5jb2RlZCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogKG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICByZXR1cm4gIWJvZHkgfHwgISh0eXBlb2YgYm9keS5waXBlICE9IFwiZnVuY3Rpb25cIiAmJiAhaXNCdWZmZXIoYm9keSkgJiYgaXNQbGFpbk9iamVjdChib2R5KSkgPyBvcHRpb25zIDoge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBib2R5OiBlbmNvZGUob3B0aW9ucy5ib2R5KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRLZWVwQWxpdmUoYWdlbnQyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IG1zMiA9IGNvbmZpZy5tcyB8fCAxZTMsIG1heEZyZWUgPSBjb25maWcubWF4RnJlZSB8fCAyNTY7XG4gICAgcmV0dXJuIGFnZW50Mih7XG4gICAgICBrZWVwQWxpdmU6ICEwLFxuICAgICAga2VlcEFsaXZlTXNlY3M6IG1zMixcbiAgICAgIG1heEZyZWVTb2NrZXRzOiBtYXhGcmVlXG4gICAgfSk7XG4gIH07XG59XG5jb25zdCBrZWVwQWxpdmUgPSBidWlsZEtlZXBBbGl2ZShhZ2VudCk7XG5leHBvcnQge1xuICBDYW5jZWwsXG4gIENhbmNlbFRva2VuLFxuICBhZ2VudCxcbiAgYmFzZSxcbiAgZGVidWcsXG4gIGhlYWRlcnMsXG4gIGh0dHBFcnJvcnMsXG4gIGluamVjdFJlc3BvbnNlLFxuICBqc29uUmVxdWVzdCxcbiAganNvblJlc3BvbnNlLFxuICBrZWVwQWxpdmUsXG4gIG10bHMsXG4gIG9ic2VydmFibGUsXG4gIHAgYXMgcHJvY2Vzc09wdGlvbnMsXG4gIHByb2dyZXNzLFxuICBwcm9taXNlLFxuICBwcm94eSxcbiAgcmV0cnksXG4gIHVybEVuY29kZWQsXG4gIHYgYXMgdmFsaWRhdGVPcHRpb25zXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/middleware.js\n");

/***/ })

};
;