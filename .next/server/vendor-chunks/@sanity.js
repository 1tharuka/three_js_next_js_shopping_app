/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity";
exports.ids = ["vendor-chunks/@sanity"];
exports.modules = {

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/builder.js":
/*!************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/builder.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ImageUrlBuilder = void 0;\nvar urlForImage_1 = __importStar(__webpack_require__(/*! ./urlForImage */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/urlForImage.js\"));\nvar validFits = ['clip', 'crop', 'fill', 'fillmax', 'max', 'scale', 'min'];\nvar validCrops = ['top', 'bottom', 'left', 'right', 'center', 'focalpoint', 'entropy'];\nvar validAutoModes = ['format'];\nfunction isSanityModernClientLike(client) {\n    return client && 'config' in client ? typeof client.config === 'function' : false;\n}\nfunction isSanityClientLike(client) {\n    return client && 'clientConfig' in client ? typeof client.clientConfig === 'object' : false;\n}\nfunction rewriteSpecName(key) {\n    var specs = urlForImage_1.SPEC_NAME_TO_URL_NAME_MAPPINGS;\n    for (var _i = 0, specs_1 = specs; _i < specs_1.length; _i++) {\n        var entry = specs_1[_i];\n        var specName = entry[0], param = entry[1];\n        if (key === specName || key === param) {\n            return specName;\n        }\n    }\n    return key;\n}\nfunction urlBuilder(options) {\n    // Did we get a modernish client?\n    if (isSanityModernClientLike(options)) {\n        // Inherit config from client\n        var _a = options.config(), apiUrl = _a.apiHost, projectId = _a.projectId, dataset = _a.dataset;\n        var apiHost = apiUrl || 'https://api.sanity.io';\n        return new ImageUrlBuilder(null, {\n            baseUrl: apiHost.replace(/^https:\\/\\/api\\./, 'https://cdn.'),\n            projectId: projectId,\n            dataset: dataset,\n        });\n    }\n    // Did we get a SanityClient?\n    var client = options;\n    if (isSanityClientLike(client)) {\n        // Inherit config from client\n        var _b = client.clientConfig, apiUrl = _b.apiHost, projectId = _b.projectId, dataset = _b.dataset;\n        var apiHost = apiUrl || 'https://api.sanity.io';\n        return new ImageUrlBuilder(null, {\n            baseUrl: apiHost.replace(/^https:\\/\\/api\\./, 'https://cdn.'),\n            projectId: projectId,\n            dataset: dataset,\n        });\n    }\n    // Or just accept the options as given\n    return new ImageUrlBuilder(null, options);\n}\nexports[\"default\"] = urlBuilder;\nvar ImageUrlBuilder = /** @class */ (function () {\n    function ImageUrlBuilder(parent, options) {\n        this.options = parent\n            ? __assign(__assign({}, (parent.options || {})), (options || {})) : __assign({}, (options || {})); // Copy options\n    }\n    ImageUrlBuilder.prototype.withOptions = function (options) {\n        var baseUrl = options.baseUrl || this.options.baseUrl;\n        var newOptions = { baseUrl: baseUrl };\n        for (var key in options) {\n            if (options.hasOwnProperty(key)) {\n                var specKey = rewriteSpecName(key);\n                newOptions[specKey] = options[key];\n            }\n        }\n        return new ImageUrlBuilder(this, __assign({ baseUrl: baseUrl }, newOptions));\n    };\n    // The image to be represented. Accepts a Sanity 'image'-document, 'asset'-document or\n    // _id of asset. To get the benefit of automatic hot-spot/crop integration with the content\n    // studio, the 'image'-document must be provided.\n    ImageUrlBuilder.prototype.image = function (source) {\n        return this.withOptions({ source: source });\n    };\n    // Specify the dataset\n    ImageUrlBuilder.prototype.dataset = function (dataset) {\n        return this.withOptions({ dataset: dataset });\n    };\n    // Specify the projectId\n    ImageUrlBuilder.prototype.projectId = function (projectId) {\n        return this.withOptions({ projectId: projectId });\n    };\n    // Specify background color\n    ImageUrlBuilder.prototype.bg = function (bg) {\n        return this.withOptions({ bg: bg });\n    };\n    // Set DPR scaling factor\n    ImageUrlBuilder.prototype.dpr = function (dpr) {\n        // A DPR of 1 is the default - so only include it if we have a different value\n        return this.withOptions(dpr && dpr !== 1 ? { dpr: dpr } : {});\n    };\n    // Specify the width of the image in pixels\n    ImageUrlBuilder.prototype.width = function (width) {\n        return this.withOptions({ width: width });\n    };\n    // Specify the height of the image in pixels\n    ImageUrlBuilder.prototype.height = function (height) {\n        return this.withOptions({ height: height });\n    };\n    // Specify focal point in fraction of image dimensions. Each component 0.0-1.0\n    ImageUrlBuilder.prototype.focalPoint = function (x, y) {\n        return this.withOptions({ focalPoint: { x: x, y: y } });\n    };\n    ImageUrlBuilder.prototype.maxWidth = function (maxWidth) {\n        return this.withOptions({ maxWidth: maxWidth });\n    };\n    ImageUrlBuilder.prototype.minWidth = function (minWidth) {\n        return this.withOptions({ minWidth: minWidth });\n    };\n    ImageUrlBuilder.prototype.maxHeight = function (maxHeight) {\n        return this.withOptions({ maxHeight: maxHeight });\n    };\n    ImageUrlBuilder.prototype.minHeight = function (minHeight) {\n        return this.withOptions({ minHeight: minHeight });\n    };\n    // Specify width and height in pixels\n    ImageUrlBuilder.prototype.size = function (width, height) {\n        return this.withOptions({ width: width, height: height });\n    };\n    // Specify blur between 0 and 100\n    ImageUrlBuilder.prototype.blur = function (blur) {\n        return this.withOptions({ blur: blur });\n    };\n    ImageUrlBuilder.prototype.sharpen = function (sharpen) {\n        return this.withOptions({ sharpen: sharpen });\n    };\n    // Specify the desired rectangle of the image\n    ImageUrlBuilder.prototype.rect = function (left, top, width, height) {\n        return this.withOptions({ rect: { left: left, top: top, width: width, height: height } });\n    };\n    // Specify the image format of the image. 'jpg', 'pjpg', 'png', 'webp'\n    ImageUrlBuilder.prototype.format = function (format) {\n        return this.withOptions({ format: format });\n    };\n    ImageUrlBuilder.prototype.invert = function (invert) {\n        return this.withOptions({ invert: invert });\n    };\n    // Rotation in degrees 0, 90, 180, 270\n    ImageUrlBuilder.prototype.orientation = function (orientation) {\n        return this.withOptions({ orientation: orientation });\n    };\n    // Compression quality 0-100\n    ImageUrlBuilder.prototype.quality = function (quality) {\n        return this.withOptions({ quality: quality });\n    };\n    // Make it a download link. Parameter is default filename.\n    ImageUrlBuilder.prototype.forceDownload = function (download) {\n        return this.withOptions({ download: download });\n    };\n    // Flip image horizontally\n    ImageUrlBuilder.prototype.flipHorizontal = function () {\n        return this.withOptions({ flipHorizontal: true });\n    };\n    // Flip image vertically\n    ImageUrlBuilder.prototype.flipVertical = function () {\n        return this.withOptions({ flipVertical: true });\n    };\n    // Ignore crop/hotspot from image record, even when present\n    ImageUrlBuilder.prototype.ignoreImageParams = function () {\n        return this.withOptions({ ignoreImageParams: true });\n    };\n    ImageUrlBuilder.prototype.fit = function (value) {\n        if (validFits.indexOf(value) === -1) {\n            throw new Error(\"Invalid fit mode \\\"\".concat(value, \"\\\"\"));\n        }\n        return this.withOptions({ fit: value });\n    };\n    ImageUrlBuilder.prototype.crop = function (value) {\n        if (validCrops.indexOf(value) === -1) {\n            throw new Error(\"Invalid crop mode \\\"\".concat(value, \"\\\"\"));\n        }\n        return this.withOptions({ crop: value });\n    };\n    // Saturation\n    ImageUrlBuilder.prototype.saturation = function (saturation) {\n        return this.withOptions({ saturation: saturation });\n    };\n    ImageUrlBuilder.prototype.auto = function (value) {\n        if (validAutoModes.indexOf(value) === -1) {\n            throw new Error(\"Invalid auto mode \\\"\".concat(value, \"\\\"\"));\n        }\n        return this.withOptions({ auto: value });\n    };\n    // Specify the number of pixels to pad the image\n    ImageUrlBuilder.prototype.pad = function (pad) {\n        return this.withOptions({ pad: pad });\n    };\n    // Gets the url based on the submitted parameters\n    ImageUrlBuilder.prototype.url = function () {\n        return (0, urlForImage_1.default)(this.options);\n    };\n    // Alias for url()\n    ImageUrlBuilder.prototype.toString = function () {\n        return this.url();\n    };\n    return ImageUrlBuilder;\n}());\nexports.ImageUrlBuilder = ImageUrlBuilder;\n//# sourceMappingURL=builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvYnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLGlDQUFpQyxtQkFBTyxDQUFDLHFGQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLElBQUk7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVcsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLGNBQWM7QUFDOUQ7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUSxzREFBc0Q7QUFDaEc7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0JBQXNCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvQkFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvaW1hZ2UtdXJsL2xpYi9ub2RlL2J1aWxkZXIuanM/NmIwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW1hZ2VVcmxCdWlsZGVyID0gdm9pZCAwO1xudmFyIHVybEZvckltYWdlXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXJsRm9ySW1hZ2VcIikpO1xudmFyIHZhbGlkRml0cyA9IFsnY2xpcCcsICdjcm9wJywgJ2ZpbGwnLCAnZmlsbG1heCcsICdtYXgnLCAnc2NhbGUnLCAnbWluJ107XG52YXIgdmFsaWRDcm9wcyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicsICdmb2NhbHBvaW50JywgJ2VudHJvcHknXTtcbnZhciB2YWxpZEF1dG9Nb2RlcyA9IFsnZm9ybWF0J107XG5mdW5jdGlvbiBpc1Nhbml0eU1vZGVybkNsaWVudExpa2UoY2xpZW50KSB7XG4gICAgcmV0dXJuIGNsaWVudCAmJiAnY29uZmlnJyBpbiBjbGllbnQgPyB0eXBlb2YgY2xpZW50LmNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTYW5pdHlDbGllbnRMaWtlKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQgJiYgJ2NsaWVudENvbmZpZycgaW4gY2xpZW50ID8gdHlwZW9mIGNsaWVudC5jbGllbnRDb25maWcgPT09ICdvYmplY3QnIDogZmFsc2U7XG59XG5mdW5jdGlvbiByZXdyaXRlU3BlY05hbWUoa2V5KSB7XG4gICAgdmFyIHNwZWNzID0gdXJsRm9ySW1hZ2VfMS5TUEVDX05BTUVfVE9fVVJMX05BTUVfTUFQUElOR1M7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzcGVjc18xID0gc3BlY3M7IF9pIDwgc3BlY3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gc3BlY3NfMVtfaV07XG4gICAgICAgIHZhciBzcGVjTmFtZSA9IGVudHJ5WzBdLCBwYXJhbSA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAoa2V5ID09PSBzcGVjTmFtZSB8fCBrZXkgPT09IHBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gc3BlY05hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHVybEJ1aWxkZXIob3B0aW9ucykge1xuICAgIC8vIERpZCB3ZSBnZXQgYSBtb2Rlcm5pc2ggY2xpZW50P1xuICAgIGlmIChpc1Nhbml0eU1vZGVybkNsaWVudExpa2Uob3B0aW9ucykpIHtcbiAgICAgICAgLy8gSW5oZXJpdCBjb25maWcgZnJvbSBjbGllbnRcbiAgICAgICAgdmFyIF9hID0gb3B0aW9ucy5jb25maWcoKSwgYXBpVXJsID0gX2EuYXBpSG9zdCwgcHJvamVjdElkID0gX2EucHJvamVjdElkLCBkYXRhc2V0ID0gX2EuZGF0YXNldDtcbiAgICAgICAgdmFyIGFwaUhvc3QgPSBhcGlVcmwgfHwgJ2h0dHBzOi8vYXBpLnNhbml0eS5pbyc7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKG51bGwsIHtcbiAgICAgICAgICAgIGJhc2VVcmw6IGFwaUhvc3QucmVwbGFjZSgvXmh0dHBzOlxcL1xcL2FwaVxcLi8sICdodHRwczovL2Nkbi4nKSxcbiAgICAgICAgICAgIHByb2plY3RJZDogcHJvamVjdElkLFxuICAgICAgICAgICAgZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIERpZCB3ZSBnZXQgYSBTYW5pdHlDbGllbnQ/XG4gICAgdmFyIGNsaWVudCA9IG9wdGlvbnM7XG4gICAgaWYgKGlzU2FuaXR5Q2xpZW50TGlrZShjbGllbnQpKSB7XG4gICAgICAgIC8vIEluaGVyaXQgY29uZmlnIGZyb20gY2xpZW50XG4gICAgICAgIHZhciBfYiA9IGNsaWVudC5jbGllbnRDb25maWcsIGFwaVVybCA9IF9iLmFwaUhvc3QsIHByb2plY3RJZCA9IF9iLnByb2plY3RJZCwgZGF0YXNldCA9IF9iLmRhdGFzZXQ7XG4gICAgICAgIHZhciBhcGlIb3N0ID0gYXBpVXJsIHx8ICdodHRwczovL2FwaS5zYW5pdHkuaW8nO1xuICAgICAgICByZXR1cm4gbmV3IEltYWdlVXJsQnVpbGRlcihudWxsLCB7XG4gICAgICAgICAgICBiYXNlVXJsOiBhcGlIb3N0LnJlcGxhY2UoL15odHRwczpcXC9cXC9hcGlcXC4vLCAnaHR0cHM6Ly9jZG4uJyksXG4gICAgICAgICAgICBwcm9qZWN0SWQ6IHByb2plY3RJZCxcbiAgICAgICAgICAgIGRhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBPciBqdXN0IGFjY2VwdCB0aGUgb3B0aW9ucyBhcyBnaXZlblxuICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKG51bGwsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gdXJsQnVpbGRlcjtcbnZhciBJbWFnZVVybEJ1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW1hZ2VVcmxCdWlsZGVyKHBhcmVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBwYXJlbnRcbiAgICAgICAgICAgID8gX19hc3NpZ24oX19hc3NpZ24oe30sIChwYXJlbnQub3B0aW9ucyB8fCB7fSkpLCAob3B0aW9ucyB8fCB7fSkpIDogX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSk7IC8vIENvcHkgb3B0aW9uc1xuICAgIH1cbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLndpdGhPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmwgfHwgdGhpcy5vcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIHZhciBuZXdPcHRpb25zID0geyBiYXNlVXJsOiBiYXNlVXJsIH07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWNLZXkgPSByZXdyaXRlU3BlY05hbWUoa2V5KTtcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zW3NwZWNLZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKHRoaXMsIF9fYXNzaWduKHsgYmFzZVVybDogYmFzZVVybCB9LCBuZXdPcHRpb25zKSk7XG4gICAgfTtcbiAgICAvLyBUaGUgaW1hZ2UgdG8gYmUgcmVwcmVzZW50ZWQuIEFjY2VwdHMgYSBTYW5pdHkgJ2ltYWdlJy1kb2N1bWVudCwgJ2Fzc2V0Jy1kb2N1bWVudCBvclxuICAgIC8vIF9pZCBvZiBhc3NldC4gVG8gZ2V0IHRoZSBiZW5lZml0IG9mIGF1dG9tYXRpYyBob3Qtc3BvdC9jcm9wIGludGVncmF0aW9uIHdpdGggdGhlIGNvbnRlbnRcbiAgICAvLyBzdHVkaW8sIHRoZSAnaW1hZ2UnLWRvY3VtZW50IG11c3QgYmUgcHJvdmlkZWQuXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5pbWFnZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBzb3VyY2U6IHNvdXJjZSB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgdGhlIGRhdGFzZXRcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmRhdGFzZXQgPSBmdW5jdGlvbiAoZGF0YXNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGRhdGFzZXQ6IGRhdGFzZXQgfSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IHRoZSBwcm9qZWN0SWRcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnByb2plY3RJZCA9IGZ1bmN0aW9uIChwcm9qZWN0SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBwcm9qZWN0SWQ6IHByb2plY3RJZCB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgYmFja2dyb3VuZCBjb2xvclxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuYmcgPSBmdW5jdGlvbiAoYmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBiZzogYmcgfSk7XG4gICAgfTtcbiAgICAvLyBTZXQgRFBSIHNjYWxpbmcgZmFjdG9yXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5kcHIgPSBmdW5jdGlvbiAoZHByKSB7XG4gICAgICAgIC8vIEEgRFBSIG9mIDEgaXMgdGhlIGRlZmF1bHQgLSBzbyBvbmx5IGluY2x1ZGUgaXQgaWYgd2UgaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyhkcHIgJiYgZHByICE9PSAxID8geyBkcHI6IGRwciB9IDoge30pO1xuICAgIH07XG4gICAgLy8gU3BlY2lmeSB0aGUgd2lkdGggb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyB3aWR0aDogd2lkdGggfSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IHRoZSBoZWlnaHQgb2YgdGhlIGltYWdlIGluIHBpeGVsc1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGhlaWdodDogaGVpZ2h0IH0pO1xuICAgIH07XG4gICAgLy8gU3BlY2lmeSBmb2NhbCBwb2ludCBpbiBmcmFjdGlvbiBvZiBpbWFnZSBkaW1lbnNpb25zLiBFYWNoIGNvbXBvbmVudCAwLjAtMS4wXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5mb2NhbFBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBmb2NhbFBvaW50OiB7IHg6IHgsIHk6IHkgfSB9KTtcbiAgICB9O1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUubWF4V2lkdGggPSBmdW5jdGlvbiAobWF4V2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBtYXhXaWR0aDogbWF4V2lkdGggfSk7XG4gICAgfTtcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLm1pbldpZHRoID0gZnVuY3Rpb24gKG1pbldpZHRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgbWluV2lkdGg6IG1pbldpZHRoIH0pO1xuICAgIH07XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5tYXhIZWlnaHQgPSBmdW5jdGlvbiAobWF4SGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfSk7XG4gICAgfTtcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLm1pbkhlaWdodCA9IGZ1bmN0aW9uIChtaW5IZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBtaW5IZWlnaHQ6IG1pbkhlaWdodCB9KTtcbiAgICB9O1xuICAgIC8vIFNwZWNpZnkgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHNcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IGJsdXIgYmV0d2VlbiAwIGFuZCAxMDBcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoYmx1cikge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGJsdXI6IGJsdXIgfSk7XG4gICAgfTtcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnNoYXJwZW4gPSBmdW5jdGlvbiAoc2hhcnBlbikge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IHNoYXJwZW46IHNoYXJwZW4gfSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IHRoZSBkZXNpcmVkIHJlY3RhbmdsZSBvZiB0aGUgaW1hZ2VcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnJlY3QgPSBmdW5jdGlvbiAobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgcmVjdDogeyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9IH0pO1xuICAgIH07XG4gICAgLy8gU3BlY2lmeSB0aGUgaW1hZ2UgZm9ybWF0IG9mIHRoZSBpbWFnZS4gJ2pwZycsICdwanBnJywgJ3BuZycsICd3ZWJwJ1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGZvcm1hdDogZm9ybWF0IH0pO1xuICAgIH07XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoaW52ZXJ0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgaW52ZXJ0OiBpbnZlcnQgfSk7XG4gICAgfTtcbiAgICAvLyBSb3RhdGlvbiBpbiBkZWdyZWVzIDAsIDkwLCAxODAsIDI3MFxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUub3JpZW50YXRpb24gPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBvcmllbnRhdGlvbjogb3JpZW50YXRpb24gfSk7XG4gICAgfTtcbiAgICAvLyBDb21wcmVzc2lvbiBxdWFsaXR5IDAtMTAwXG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5xdWFsaXR5ID0gZnVuY3Rpb24gKHF1YWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBxdWFsaXR5OiBxdWFsaXR5IH0pO1xuICAgIH07XG4gICAgLy8gTWFrZSBpdCBhIGRvd25sb2FkIGxpbmsuIFBhcmFtZXRlciBpcyBkZWZhdWx0IGZpbGVuYW1lLlxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuZm9yY2VEb3dubG9hZCA9IGZ1bmN0aW9uIChkb3dubG9hZCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGRvd25sb2FkOiBkb3dubG9hZCB9KTtcbiAgICB9O1xuICAgIC8vIEZsaXAgaW1hZ2UgaG9yaXpvbnRhbGx5XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5mbGlwSG9yaXpvbnRhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBmbGlwSG9yaXpvbnRhbDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIC8vIEZsaXAgaW1hZ2UgdmVydGljYWxseVxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuZmxpcFZlcnRpY2FsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGZsaXBWZXJ0aWNhbDogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIC8vIElnbm9yZSBjcm9wL2hvdHNwb3QgZnJvbSBpbWFnZSByZWNvcmQsIGV2ZW4gd2hlbiBwcmVzZW50XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5pZ25vcmVJbWFnZVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBpZ25vcmVJbWFnZVBhcmFtczogdHJ1ZSB9KTtcbiAgICB9O1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWxpZEZpdHMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZpdCBtb2RlIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBmaXQ6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgSW1hZ2VVcmxCdWlsZGVyLnByb3RvdHlwZS5jcm9wID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWxpZENyb3BzLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjcm9wIG1vZGUgXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7IGNyb3A6IHZhbHVlIH0pO1xuICAgIH07XG4gICAgLy8gU2F0dXJhdGlvblxuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuc2F0dXJhdGlvbiA9IGZ1bmN0aW9uIChzYXR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgc2F0dXJhdGlvbjogc2F0dXJhdGlvbiB9KTtcbiAgICB9O1xuICAgIEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGUuYXV0byA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsaWRBdXRvTW9kZXMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF1dG8gbW9kZSBcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHsgYXV0bzogdmFsdWUgfSk7XG4gICAgfTtcbiAgICAvLyBTcGVjaWZ5IHRoZSBudW1iZXIgb2YgcGl4ZWxzIHRvIHBhZCB0aGUgaW1hZ2VcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uIChwYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoeyBwYWQ6IHBhZCB9KTtcbiAgICB9O1xuICAgIC8vIEdldHMgdGhlIHVybCBiYXNlZCBvbiB0aGUgc3VibWl0dGVkIHBhcmFtZXRlcnNcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1cmxGb3JJbWFnZV8xLmRlZmF1bHQpKHRoaXMub3B0aW9ucyk7XG4gICAgfTtcbiAgICAvLyBBbGlhcyBmb3IgdXJsKClcbiAgICBJbWFnZVVybEJ1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmwoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVVybEJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5JbWFnZVVybEJ1aWxkZXIgPSBJbWFnZVVybEJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar builder_1 = __importDefault(__webpack_require__(/*! ./builder */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/builder.js\"));\nmodule.exports = builder_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDZFQUFXO0FBQ25EO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waW5nX2FwcC8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2ltYWdlLXVybC9saWIvbm9kZS9pbmRleC5qcz85MTk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIGJ1aWxkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9idWlsZGVyXCIpKTtcbm1vZHVsZS5leHBvcnRzID0gYnVpbGRlcl8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/parseAssetId.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/parseAssetId.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';\nfunction parseAssetId(ref) {\n    var _a = ref.split('-'), id = _a[1], dimensionString = _a[2], format = _a[3];\n    if (!id || !dimensionString || !format) {\n        throw new Error(\"Malformed asset _ref '\".concat(ref, \"'. Expected an id like \\\"\").concat(example, \"\\\".\"));\n    }\n    var _b = dimensionString.split('x'), imgWidthStr = _b[0], imgHeightStr = _b[1];\n    var width = +imgWidthStr;\n    var height = +imgHeightStr;\n    var isValidAssetId = isFinite(width) && isFinite(height);\n    if (!isValidAssetId) {\n        throw new Error(\"Malformed asset _ref '\".concat(ref, \"'. Expected an id like \\\"\").concat(example, \"\\\".\"));\n    }\n    return { id: id, width: width, height: height, format: format };\n}\nexports[\"default\"] = parseAssetId;\n//# sourceMappingURL=parseAssetId.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvcGFyc2VBc3NldElkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvaW1hZ2UtdXJsL2xpYi9ub2RlL3BhcnNlQXNzZXRJZC5qcz9kMDJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV4YW1wbGUgPSAnaW1hZ2UtVGI5RXc4Q1hJd2FZNlIxa2pNdkkwdVJSLTIwMDB4MzAwMC1qcGcnO1xuZnVuY3Rpb24gcGFyc2VBc3NldElkKHJlZikge1xuICAgIHZhciBfYSA9IHJlZi5zcGxpdCgnLScpLCBpZCA9IF9hWzFdLCBkaW1lbnNpb25TdHJpbmcgPSBfYVsyXSwgZm9ybWF0ID0gX2FbM107XG4gICAgaWYgKCFpZCB8fCAhZGltZW5zaW9uU3RyaW5nIHx8ICFmb3JtYXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGFzc2V0IF9yZWYgJ1wiLmNvbmNhdChyZWYsIFwiJy4gRXhwZWN0ZWQgYW4gaWQgbGlrZSBcXFwiXCIpLmNvbmNhdChleGFtcGxlLCBcIlxcXCIuXCIpKTtcbiAgICB9XG4gICAgdmFyIF9iID0gZGltZW5zaW9uU3RyaW5nLnNwbGl0KCd4JyksIGltZ1dpZHRoU3RyID0gX2JbMF0sIGltZ0hlaWdodFN0ciA9IF9iWzFdO1xuICAgIHZhciB3aWR0aCA9ICtpbWdXaWR0aFN0cjtcbiAgICB2YXIgaGVpZ2h0ID0gK2ltZ0hlaWdodFN0cjtcbiAgICB2YXIgaXNWYWxpZEFzc2V0SWQgPSBpc0Zpbml0ZSh3aWR0aCkgJiYgaXNGaW5pdGUoaGVpZ2h0KTtcbiAgICBpZiAoIWlzVmFsaWRBc3NldElkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBhc3NldCBfcmVmICdcIi5jb25jYXQocmVmLCBcIicuIEV4cGVjdGVkIGFuIGlkIGxpa2UgXFxcIlwiKS5jb25jYXQoZXhhbXBsZSwgXCJcXFwiLlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB7IGlkOiBpZCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgZm9ybWF0OiBmb3JtYXQgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlQXNzZXRJZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlQXNzZXRJZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/parseAssetId.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/parseSource.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/parseSource.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar isRef = function (src) {\n    var source = src;\n    return source ? typeof source._ref === 'string' : false;\n};\nvar isAsset = function (src) {\n    var source = src;\n    return source ? typeof source._id === 'string' : false;\n};\nvar isAssetStub = function (src) {\n    var source = src;\n    return source && source.asset ? typeof source.asset.url === 'string' : false;\n};\n// Convert an asset-id, asset or image to an image record suitable for processing\n// eslint-disable-next-line complexity\nfunction parseSource(source) {\n    if (!source) {\n        return null;\n    }\n    var image;\n    if (typeof source === 'string' && isUrl(source)) {\n        // Someone passed an existing image url?\n        image = {\n            asset: { _ref: urlToId(source) },\n        };\n    }\n    else if (typeof source === 'string') {\n        // Just an asset id\n        image = {\n            asset: { _ref: source },\n        };\n    }\n    else if (isRef(source)) {\n        // We just got passed an asset directly\n        image = {\n            asset: source,\n        };\n    }\n    else if (isAsset(source)) {\n        // If we were passed an image asset document\n        image = {\n            asset: {\n                _ref: source._id || '',\n            },\n        };\n    }\n    else if (isAssetStub(source)) {\n        // If we were passed a partial asset (`url`, but no `_id`)\n        image = {\n            asset: {\n                _ref: urlToId(source.asset.url),\n            },\n        };\n    }\n    else if (typeof source.asset === 'object') {\n        // Probably an actual image with materialized asset\n        image = __assign({}, source);\n    }\n    else {\n        // We got something that does not look like an image, or it is an image\n        // that currently isn't sporting an asset.\n        return null;\n    }\n    var img = source;\n    if (img.crop) {\n        image.crop = img.crop;\n    }\n    if (img.hotspot) {\n        image.hotspot = img.hotspot;\n    }\n    return applyDefaults(image);\n}\nexports[\"default\"] = parseSource;\nfunction isUrl(url) {\n    return /^https?:\\/\\//.test(\"\".concat(url));\n}\nfunction urlToId(url) {\n    var parts = url.split('/').slice(-1);\n    return \"image-\".concat(parts[0]).replace(/\\.([a-z]+)$/, '-$1');\n}\n// Mock crop and hotspot if image lacks it\nfunction applyDefaults(image) {\n    if (image.crop && image.hotspot) {\n        return image;\n    }\n    // We need to pad in default values for crop or hotspot\n    var result = __assign({}, image);\n    if (!result.crop) {\n        result.crop = {\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right: 0,\n        };\n    }\n    if (!result.hotspot) {\n        result.hotspot = {\n            x: 0.5,\n            y: 0.5,\n            height: 1.0,\n            width: 1.0,\n        };\n    }\n    return result;\n}\n//# sourceMappingURL=parseSource.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvcGFyc2VTb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waW5nX2FwcC8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2ltYWdlLXVybC9saWIvbm9kZS9wYXJzZVNvdXJjZS5qcz8yOTIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc1JlZiA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICB2YXIgc291cmNlID0gc3JjO1xuICAgIHJldHVybiBzb3VyY2UgPyB0eXBlb2Ygc291cmNlLl9yZWYgPT09ICdzdHJpbmcnIDogZmFsc2U7XG59O1xudmFyIGlzQXNzZXQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNyYztcbiAgICByZXR1cm4gc291cmNlID8gdHlwZW9mIHNvdXJjZS5faWQgPT09ICdzdHJpbmcnIDogZmFsc2U7XG59O1xudmFyIGlzQXNzZXRTdHViID0gZnVuY3Rpb24gKHNyYykge1xuICAgIHZhciBzb3VyY2UgPSBzcmM7XG4gICAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuYXNzZXQgPyB0eXBlb2Ygc291cmNlLmFzc2V0LnVybCA9PT0gJ3N0cmluZycgOiBmYWxzZTtcbn07XG4vLyBDb252ZXJ0IGFuIGFzc2V0LWlkLCBhc3NldCBvciBpbWFnZSB0byBhbiBpbWFnZSByZWNvcmQgc3VpdGFibGUgZm9yIHByb2Nlc3Npbmdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBwYXJzZVNvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGltYWdlO1xuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiBpc1VybChzb3VyY2UpKSB7XG4gICAgICAgIC8vIFNvbWVvbmUgcGFzc2VkIGFuIGV4aXN0aW5nIGltYWdlIHVybD9cbiAgICAgICAgaW1hZ2UgPSB7XG4gICAgICAgICAgICBhc3NldDogeyBfcmVmOiB1cmxUb0lkKHNvdXJjZSkgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSnVzdCBhbiBhc3NldCBpZFxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiB7IF9yZWY6IHNvdXJjZSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgICAgIC8vIFdlIGp1c3QgZ290IHBhc3NlZCBhbiBhc3NldCBkaXJlY3RseVxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiBzb3VyY2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXNzZXQoc291cmNlKSkge1xuICAgICAgICAvLyBJZiB3ZSB3ZXJlIHBhc3NlZCBhbiBpbWFnZSBhc3NldCBkb2N1bWVudFxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiB7XG4gICAgICAgICAgICAgICAgX3JlZjogc291cmNlLl9pZCB8fCAnJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXNzZXRTdHViKHNvdXJjZSkpIHtcbiAgICAgICAgLy8gSWYgd2Ugd2VyZSBwYXNzZWQgYSBwYXJ0aWFsIGFzc2V0IChgdXJsYCwgYnV0IG5vIGBfaWRgKVxuICAgICAgICBpbWFnZSA9IHtcbiAgICAgICAgICAgIGFzc2V0OiB7XG4gICAgICAgICAgICAgICAgX3JlZjogdXJsVG9JZChzb3VyY2UuYXNzZXQudXJsKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UuYXNzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIFByb2JhYmx5IGFuIGFjdHVhbCBpbWFnZSB3aXRoIG1hdGVyaWFsaXplZCBhc3NldFxuICAgICAgICBpbWFnZSA9IF9fYXNzaWduKHt9LCBzb3VyY2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gV2UgZ290IHNvbWV0aGluZyB0aGF0IGRvZXMgbm90IGxvb2sgbGlrZSBhbiBpbWFnZSwgb3IgaXQgaXMgYW4gaW1hZ2VcbiAgICAgICAgLy8gdGhhdCBjdXJyZW50bHkgaXNuJ3Qgc3BvcnRpbmcgYW4gYXNzZXQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgaW1nID0gc291cmNlO1xuICAgIGlmIChpbWcuY3JvcCkge1xuICAgICAgICBpbWFnZS5jcm9wID0gaW1nLmNyb3A7XG4gICAgfVxuICAgIGlmIChpbWcuaG90c3BvdCkge1xuICAgICAgICBpbWFnZS5ob3RzcG90ID0gaW1nLmhvdHNwb3Q7XG4gICAgfVxuICAgIHJldHVybiBhcHBseURlZmF1bHRzKGltYWdlKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlU291cmNlO1xuZnVuY3Rpb24gaXNVcmwodXJsKSB7XG4gICAgcmV0dXJuIC9eaHR0cHM/OlxcL1xcLy8udGVzdChcIlwiLmNvbmNhdCh1cmwpKTtcbn1cbmZ1bmN0aW9uIHVybFRvSWQodXJsKSB7XG4gICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCcvJykuc2xpY2UoLTEpO1xuICAgIHJldHVybiBcImltYWdlLVwiLmNvbmNhdChwYXJ0c1swXSkucmVwbGFjZSgvXFwuKFthLXpdKykkLywgJy0kMScpO1xufVxuLy8gTW9jayBjcm9wIGFuZCBob3RzcG90IGlmIGltYWdlIGxhY2tzIGl0XG5mdW5jdGlvbiBhcHBseURlZmF1bHRzKGltYWdlKSB7XG4gICAgaWYgKGltYWdlLmNyb3AgJiYgaW1hZ2UuaG90c3BvdCkge1xuICAgICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfVxuICAgIC8vIFdlIG5lZWQgdG8gcGFkIGluIGRlZmF1bHQgdmFsdWVzIGZvciBjcm9wIG9yIGhvdHNwb3RcbiAgICB2YXIgcmVzdWx0ID0gX19hc3NpZ24oe30sIGltYWdlKTtcbiAgICBpZiAoIXJlc3VsdC5jcm9wKSB7XG4gICAgICAgIHJlc3VsdC5jcm9wID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdC5ob3RzcG90KSB7XG4gICAgICAgIHJlc3VsdC5ob3RzcG90ID0ge1xuICAgICAgICAgICAgeDogMC41LFxuICAgICAgICAgICAgeTogMC41LFxuICAgICAgICAgICAgaGVpZ2h0OiAxLjAsXG4gICAgICAgICAgICB3aWR0aDogMS4wLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VTb3VyY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/parseSource.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/image-url/lib/node/urlForImage.js":
/*!****************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/node/urlForImage.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseSource = exports.SPEC_NAME_TO_URL_NAME_MAPPINGS = void 0;\nvar parseAssetId_1 = __importDefault(__webpack_require__(/*! ./parseAssetId */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/parseAssetId.js\"));\nvar parseSource_1 = __importDefault(__webpack_require__(/*! ./parseSource */ \"(ssr)/./node_modules/@sanity/image-url/lib/node/parseSource.js\"));\nexports.parseSource = parseSource_1.default;\nexports.SPEC_NAME_TO_URL_NAME_MAPPINGS = [\n    ['width', 'w'],\n    ['height', 'h'],\n    ['format', 'fm'],\n    ['download', 'dl'],\n    ['blur', 'blur'],\n    ['sharpen', 'sharp'],\n    ['invert', 'invert'],\n    ['orientation', 'or'],\n    ['minHeight', 'min-h'],\n    ['maxHeight', 'max-h'],\n    ['minWidth', 'min-w'],\n    ['maxWidth', 'max-w'],\n    ['quality', 'q'],\n    ['fit', 'fit'],\n    ['crop', 'crop'],\n    ['saturation', 'sat'],\n    ['auto', 'auto'],\n    ['dpr', 'dpr'],\n    ['pad', 'pad'],\n];\nfunction urlForImage(options) {\n    var spec = __assign({}, (options || {}));\n    var source = spec.source;\n    delete spec.source;\n    var image = (0, parseSource_1.default)(source);\n    if (!image) {\n        throw new Error(\"Unable to resolve image URL from source (\".concat(JSON.stringify(source), \")\"));\n    }\n    var id = image.asset._ref || image.asset._id || '';\n    var asset = (0, parseAssetId_1.default)(id);\n    // Compute crop rect in terms of pixel coordinates in the raw source image\n    var cropLeft = Math.round(image.crop.left * asset.width);\n    var cropTop = Math.round(image.crop.top * asset.height);\n    var crop = {\n        left: cropLeft,\n        top: cropTop,\n        width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),\n        height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop),\n    };\n    // Compute hot spot rect in terms of pixel coordinates\n    var hotSpotVerticalRadius = (image.hotspot.height * asset.height) / 2;\n    var hotSpotHorizontalRadius = (image.hotspot.width * asset.width) / 2;\n    var hotSpotCenterX = image.hotspot.x * asset.width;\n    var hotSpotCenterY = image.hotspot.y * asset.height;\n    var hotspot = {\n        left: hotSpotCenterX - hotSpotHorizontalRadius,\n        top: hotSpotCenterY - hotSpotVerticalRadius,\n        right: hotSpotCenterX + hotSpotHorizontalRadius,\n        bottom: hotSpotCenterY + hotSpotVerticalRadius,\n    };\n    // If irrelevant, or if we are requested to: don't perform crop/fit based on\n    // the crop/hotspot.\n    if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {\n        spec = __assign(__assign({}, spec), fit({ crop: crop, hotspot: hotspot }, spec));\n    }\n    return specToImageUrl(__assign(__assign({}, spec), { asset: asset }));\n}\nexports[\"default\"] = urlForImage;\n// eslint-disable-next-line complexity\nfunction specToImageUrl(spec) {\n    var cdnUrl = (spec.baseUrl || 'https://cdn.sanity.io').replace(/\\/+$/, '');\n    var filename = \"\".concat(spec.asset.id, \"-\").concat(spec.asset.width, \"x\").concat(spec.asset.height, \".\").concat(spec.asset.format);\n    var baseUrl = \"\".concat(cdnUrl, \"/images/\").concat(spec.projectId, \"/\").concat(spec.dataset, \"/\").concat(filename);\n    var params = [];\n    if (spec.rect) {\n        // Only bother url with a crop if it actually crops anything\n        var _a = spec.rect, left = _a.left, top_1 = _a.top, width = _a.width, height = _a.height;\n        var isEffectiveCrop = left !== 0 || top_1 !== 0 || height !== spec.asset.height || width !== spec.asset.width;\n        if (isEffectiveCrop) {\n            params.push(\"rect=\".concat(left, \",\").concat(top_1, \",\").concat(width, \",\").concat(height));\n        }\n    }\n    if (spec.bg) {\n        params.push(\"bg=\".concat(spec.bg));\n    }\n    if (spec.focalPoint) {\n        params.push(\"fp-x=\".concat(spec.focalPoint.x));\n        params.push(\"fp-y=\".concat(spec.focalPoint.y));\n    }\n    var flip = [spec.flipHorizontal && 'h', spec.flipVertical && 'v'].filter(Boolean).join('');\n    if (flip) {\n        params.push(\"flip=\".concat(flip));\n    }\n    // Map from spec name to url param name, and allow using the actual param name as an alternative\n    exports.SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function (mapping) {\n        var specName = mapping[0], param = mapping[1];\n        if (typeof spec[specName] !== 'undefined') {\n            params.push(\"\".concat(param, \"=\").concat(encodeURIComponent(spec[specName])));\n        }\n        else if (typeof spec[param] !== 'undefined') {\n            params.push(\"\".concat(param, \"=\").concat(encodeURIComponent(spec[param])));\n        }\n    });\n    if (params.length === 0) {\n        return baseUrl;\n    }\n    return \"\".concat(baseUrl, \"?\").concat(params.join('&'));\n}\nfunction fit(source, spec) {\n    var cropRect;\n    var imgWidth = spec.width;\n    var imgHeight = spec.height;\n    // If we are not constraining the aspect ratio, we'll just use the whole crop\n    if (!(imgWidth && imgHeight)) {\n        return { width: imgWidth, height: imgHeight, rect: source.crop };\n    }\n    var crop = source.crop;\n    var hotspot = source.hotspot;\n    // If we are here, that means aspect ratio is locked and fitting will be a bit harder\n    var desiredAspectRatio = imgWidth / imgHeight;\n    var cropAspectRatio = crop.width / crop.height;\n    if (cropAspectRatio > desiredAspectRatio) {\n        // The crop is wider than the desired aspect ratio. That means we are cutting from the sides\n        var height = Math.round(crop.height);\n        var width = Math.round(height * desiredAspectRatio);\n        var top_2 = Math.max(0, Math.round(crop.top));\n        // Center output horizontally over hotspot\n        var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);\n        var left = Math.max(0, Math.round(hotspotXCenter - width / 2));\n        // Keep output within crop\n        if (left < crop.left) {\n            left = crop.left;\n        }\n        else if (left + width > crop.left + crop.width) {\n            left = crop.left + crop.width - width;\n        }\n        cropRect = { left: left, top: top_2, width: width, height: height };\n    }\n    else {\n        // The crop is taller than the desired ratio, we are cutting from top and bottom\n        var width = crop.width;\n        var height = Math.round(width / desiredAspectRatio);\n        var left = Math.max(0, Math.round(crop.left));\n        // Center output vertically over hotspot\n        var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);\n        var top_3 = Math.max(0, Math.round(hotspotYCenter - height / 2));\n        // Keep output rect within crop\n        if (top_3 < crop.top) {\n            top_3 = crop.top;\n        }\n        else if (top_3 + height > crop.top + crop.height) {\n            top_3 = crop.top + crop.height - height;\n        }\n        cropRect = { left: left, top: top_3, width: width, height: height };\n    }\n    return {\n        width: imgWidth,\n        height: imgHeight,\n        rect: cropRect,\n    };\n}\n//# sourceMappingURL=urlForImage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9pbWFnZS11cmwvbGliL25vZGUvdXJsRm9ySW1hZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHNDQUFzQztBQUM1RCxxQ0FBcUMsbUJBQU8sQ0FBQyx1RkFBZ0I7QUFDN0Qsb0NBQW9DLG1CQUFPLENBQUMscUZBQWU7QUFDM0QsbUJBQW1CO0FBQ25CLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWUsOEJBQThCO0FBQ2hGO0FBQ0EsOENBQThDLFdBQVcsY0FBYztBQUN2RTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvaW1hZ2UtdXJsL2xpYi9ub2RlL3VybEZvckltYWdlLmpzPzdhOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVNvdXJjZSA9IGV4cG9ydHMuU1BFQ19OQU1FX1RPX1VSTF9OQU1FX01BUFBJTkdTID0gdm9pZCAwO1xudmFyIHBhcnNlQXNzZXRJZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlQXNzZXRJZFwiKSk7XG52YXIgcGFyc2VTb3VyY2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZVNvdXJjZVwiKSk7XG5leHBvcnRzLnBhcnNlU291cmNlID0gcGFyc2VTb3VyY2VfMS5kZWZhdWx0O1xuZXhwb3J0cy5TUEVDX05BTUVfVE9fVVJMX05BTUVfTUFQUElOR1MgPSBbXG4gICAgWyd3aWR0aCcsICd3J10sXG4gICAgWydoZWlnaHQnLCAnaCddLFxuICAgIFsnZm9ybWF0JywgJ2ZtJ10sXG4gICAgWydkb3dubG9hZCcsICdkbCddLFxuICAgIFsnYmx1cicsICdibHVyJ10sXG4gICAgWydzaGFycGVuJywgJ3NoYXJwJ10sXG4gICAgWydpbnZlcnQnLCAnaW52ZXJ0J10sXG4gICAgWydvcmllbnRhdGlvbicsICdvciddLFxuICAgIFsnbWluSGVpZ2h0JywgJ21pbi1oJ10sXG4gICAgWydtYXhIZWlnaHQnLCAnbWF4LWgnXSxcbiAgICBbJ21pbldpZHRoJywgJ21pbi13J10sXG4gICAgWydtYXhXaWR0aCcsICdtYXgtdyddLFxuICAgIFsncXVhbGl0eScsICdxJ10sXG4gICAgWydmaXQnLCAnZml0J10sXG4gICAgWydjcm9wJywgJ2Nyb3AnXSxcbiAgICBbJ3NhdHVyYXRpb24nLCAnc2F0J10sXG4gICAgWydhdXRvJywgJ2F1dG8nXSxcbiAgICBbJ2RwcicsICdkcHInXSxcbiAgICBbJ3BhZCcsICdwYWQnXSxcbl07XG5mdW5jdGlvbiB1cmxGb3JJbWFnZShvcHRpb25zKSB7XG4gICAgdmFyIHNwZWMgPSBfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKTtcbiAgICB2YXIgc291cmNlID0gc3BlYy5zb3VyY2U7XG4gICAgZGVsZXRlIHNwZWMuc291cmNlO1xuICAgIHZhciBpbWFnZSA9ICgwLCBwYXJzZVNvdXJjZV8xLmRlZmF1bHQpKHNvdXJjZSk7XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBpbWFnZSBVUkwgZnJvbSBzb3VyY2UgKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShzb3VyY2UpLCBcIilcIikpO1xuICAgIH1cbiAgICB2YXIgaWQgPSBpbWFnZS5hc3NldC5fcmVmIHx8IGltYWdlLmFzc2V0Ll9pZCB8fCAnJztcbiAgICB2YXIgYXNzZXQgPSAoMCwgcGFyc2VBc3NldElkXzEuZGVmYXVsdCkoaWQpO1xuICAgIC8vIENvbXB1dGUgY3JvcCByZWN0IGluIHRlcm1zIG9mIHBpeGVsIGNvb3JkaW5hdGVzIGluIHRoZSByYXcgc291cmNlIGltYWdlXG4gICAgdmFyIGNyb3BMZWZ0ID0gTWF0aC5yb3VuZChpbWFnZS5jcm9wLmxlZnQgKiBhc3NldC53aWR0aCk7XG4gICAgdmFyIGNyb3BUb3AgPSBNYXRoLnJvdW5kKGltYWdlLmNyb3AudG9wICogYXNzZXQuaGVpZ2h0KTtcbiAgICB2YXIgY3JvcCA9IHtcbiAgICAgICAgbGVmdDogY3JvcExlZnQsXG4gICAgICAgIHRvcDogY3JvcFRvcCxcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoYXNzZXQud2lkdGggLSBpbWFnZS5jcm9wLnJpZ2h0ICogYXNzZXQud2lkdGggLSBjcm9wTGVmdCksXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChhc3NldC5oZWlnaHQgLSBpbWFnZS5jcm9wLmJvdHRvbSAqIGFzc2V0LmhlaWdodCAtIGNyb3BUb3ApLFxuICAgIH07XG4gICAgLy8gQ29tcHV0ZSBob3Qgc3BvdCByZWN0IGluIHRlcm1zIG9mIHBpeGVsIGNvb3JkaW5hdGVzXG4gICAgdmFyIGhvdFNwb3RWZXJ0aWNhbFJhZGl1cyA9IChpbWFnZS5ob3RzcG90LmhlaWdodCAqIGFzc2V0LmhlaWdodCkgLyAyO1xuICAgIHZhciBob3RTcG90SG9yaXpvbnRhbFJhZGl1cyA9IChpbWFnZS5ob3RzcG90LndpZHRoICogYXNzZXQud2lkdGgpIC8gMjtcbiAgICB2YXIgaG90U3BvdENlbnRlclggPSBpbWFnZS5ob3RzcG90LnggKiBhc3NldC53aWR0aDtcbiAgICB2YXIgaG90U3BvdENlbnRlclkgPSBpbWFnZS5ob3RzcG90LnkgKiBhc3NldC5oZWlnaHQ7XG4gICAgdmFyIGhvdHNwb3QgPSB7XG4gICAgICAgIGxlZnQ6IGhvdFNwb3RDZW50ZXJYIC0gaG90U3BvdEhvcml6b250YWxSYWRpdXMsXG4gICAgICAgIHRvcDogaG90U3BvdENlbnRlclkgLSBob3RTcG90VmVydGljYWxSYWRpdXMsXG4gICAgICAgIHJpZ2h0OiBob3RTcG90Q2VudGVyWCArIGhvdFNwb3RIb3Jpem9udGFsUmFkaXVzLFxuICAgICAgICBib3R0b206IGhvdFNwb3RDZW50ZXJZICsgaG90U3BvdFZlcnRpY2FsUmFkaXVzLFxuICAgIH07XG4gICAgLy8gSWYgaXJyZWxldmFudCwgb3IgaWYgd2UgYXJlIHJlcXVlc3RlZCB0bzogZG9uJ3QgcGVyZm9ybSBjcm9wL2ZpdCBiYXNlZCBvblxuICAgIC8vIHRoZSBjcm9wL2hvdHNwb3QuXG4gICAgaWYgKCEoc3BlYy5yZWN0IHx8IHNwZWMuZm9jYWxQb2ludCB8fCBzcGVjLmlnbm9yZUltYWdlUGFyYW1zIHx8IHNwZWMuY3JvcCkpIHtcbiAgICAgICAgc3BlYyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzcGVjKSwgZml0KHsgY3JvcDogY3JvcCwgaG90c3BvdDogaG90c3BvdCB9LCBzcGVjKSk7XG4gICAgfVxuICAgIHJldHVybiBzcGVjVG9JbWFnZVVybChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3BlYyksIHsgYXNzZXQ6IGFzc2V0IH0pKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHVybEZvckltYWdlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHNwZWNUb0ltYWdlVXJsKHNwZWMpIHtcbiAgICB2YXIgY2RuVXJsID0gKHNwZWMuYmFzZVVybCB8fCAnaHR0cHM6Ly9jZG4uc2FuaXR5LmlvJykucmVwbGFjZSgvXFwvKyQvLCAnJyk7XG4gICAgdmFyIGZpbGVuYW1lID0gXCJcIi5jb25jYXQoc3BlYy5hc3NldC5pZCwgXCItXCIpLmNvbmNhdChzcGVjLmFzc2V0LndpZHRoLCBcInhcIikuY29uY2F0KHNwZWMuYXNzZXQuaGVpZ2h0LCBcIi5cIikuY29uY2F0KHNwZWMuYXNzZXQuZm9ybWF0KTtcbiAgICB2YXIgYmFzZVVybCA9IFwiXCIuY29uY2F0KGNkblVybCwgXCIvaW1hZ2VzL1wiKS5jb25jYXQoc3BlYy5wcm9qZWN0SWQsIFwiL1wiKS5jb25jYXQoc3BlYy5kYXRhc2V0LCBcIi9cIikuY29uY2F0KGZpbGVuYW1lKTtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgaWYgKHNwZWMucmVjdCkge1xuICAgICAgICAvLyBPbmx5IGJvdGhlciB1cmwgd2l0aCBhIGNyb3AgaWYgaXQgYWN0dWFsbHkgY3JvcHMgYW55dGhpbmdcbiAgICAgICAgdmFyIF9hID0gc3BlYy5yZWN0LCBsZWZ0ID0gX2EubGVmdCwgdG9wXzEgPSBfYS50b3AsIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcbiAgICAgICAgdmFyIGlzRWZmZWN0aXZlQ3JvcCA9IGxlZnQgIT09IDAgfHwgdG9wXzEgIT09IDAgfHwgaGVpZ2h0ICE9PSBzcGVjLmFzc2V0LmhlaWdodCB8fCB3aWR0aCAhPT0gc3BlYy5hc3NldC53aWR0aDtcbiAgICAgICAgaWYgKGlzRWZmZWN0aXZlQ3JvcCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goXCJyZWN0PVwiLmNvbmNhdChsZWZ0LCBcIixcIikuY29uY2F0KHRvcF8xLCBcIixcIikuY29uY2F0KHdpZHRoLCBcIixcIikuY29uY2F0KGhlaWdodCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzcGVjLmJnKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiYmc9XCIuY29uY2F0KHNwZWMuYmcpKTtcbiAgICB9XG4gICAgaWYgKHNwZWMuZm9jYWxQb2ludCkge1xuICAgICAgICBwYXJhbXMucHVzaChcImZwLXg9XCIuY29uY2F0KHNwZWMuZm9jYWxQb2ludC54KSk7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiZnAteT1cIi5jb25jYXQoc3BlYy5mb2NhbFBvaW50LnkpKTtcbiAgICB9XG4gICAgdmFyIGZsaXAgPSBbc3BlYy5mbGlwSG9yaXpvbnRhbCAmJiAnaCcsIHNwZWMuZmxpcFZlcnRpY2FsICYmICd2J10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJycpO1xuICAgIGlmIChmbGlwKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwiZmxpcD1cIi5jb25jYXQoZmxpcCkpO1xuICAgIH1cbiAgICAvLyBNYXAgZnJvbSBzcGVjIG5hbWUgdG8gdXJsIHBhcmFtIG5hbWUsIGFuZCBhbGxvdyB1c2luZyB0aGUgYWN0dWFsIHBhcmFtIG5hbWUgYXMgYW4gYWx0ZXJuYXRpdmVcbiAgICBleHBvcnRzLlNQRUNfTkFNRV9UT19VUkxfTkFNRV9NQVBQSU5HUy5mb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIHZhciBzcGVjTmFtZSA9IG1hcHBpbmdbMF0sIHBhcmFtID0gbWFwcGluZ1sxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjW3NwZWNOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKFwiXCIuY29uY2F0KHBhcmFtLCBcIj1cIikuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChzcGVjW3NwZWNOYW1lXSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3BlY1twYXJhbV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChcIlwiLmNvbmNhdChwYXJhbSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoc3BlY1twYXJhbV0pKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGJhc2VVcmwsIFwiP1wiKS5jb25jYXQocGFyYW1zLmpvaW4oJyYnKSk7XG59XG5mdW5jdGlvbiBmaXQoc291cmNlLCBzcGVjKSB7XG4gICAgdmFyIGNyb3BSZWN0O1xuICAgIHZhciBpbWdXaWR0aCA9IHNwZWMud2lkdGg7XG4gICAgdmFyIGltZ0hlaWdodCA9IHNwZWMuaGVpZ2h0O1xuICAgIC8vIElmIHdlIGFyZSBub3QgY29uc3RyYWluaW5nIHRoZSBhc3BlY3QgcmF0aW8sIHdlJ2xsIGp1c3QgdXNlIHRoZSB3aG9sZSBjcm9wXG4gICAgaWYgKCEoaW1nV2lkdGggJiYgaW1nSGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4geyB3aWR0aDogaW1nV2lkdGgsIGhlaWdodDogaW1nSGVpZ2h0LCByZWN0OiBzb3VyY2UuY3JvcCB9O1xuICAgIH1cbiAgICB2YXIgY3JvcCA9IHNvdXJjZS5jcm9wO1xuICAgIHZhciBob3RzcG90ID0gc291cmNlLmhvdHNwb3Q7XG4gICAgLy8gSWYgd2UgYXJlIGhlcmUsIHRoYXQgbWVhbnMgYXNwZWN0IHJhdGlvIGlzIGxvY2tlZCBhbmQgZml0dGluZyB3aWxsIGJlIGEgYml0IGhhcmRlclxuICAgIHZhciBkZXNpcmVkQXNwZWN0UmF0aW8gPSBpbWdXaWR0aCAvIGltZ0hlaWdodDtcbiAgICB2YXIgY3JvcEFzcGVjdFJhdGlvID0gY3JvcC53aWR0aCAvIGNyb3AuaGVpZ2h0O1xuICAgIGlmIChjcm9wQXNwZWN0UmF0aW8gPiBkZXNpcmVkQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgLy8gVGhlIGNyb3AgaXMgd2lkZXIgdGhhbiB0aGUgZGVzaXJlZCBhc3BlY3QgcmF0aW8uIFRoYXQgbWVhbnMgd2UgYXJlIGN1dHRpbmcgZnJvbSB0aGUgc2lkZXNcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgucm91bmQoY3JvcC5oZWlnaHQpO1xuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKGhlaWdodCAqIGRlc2lyZWRBc3BlY3RSYXRpbyk7XG4gICAgICAgIHZhciB0b3BfMiA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoY3JvcC50b3ApKTtcbiAgICAgICAgLy8gQ2VudGVyIG91dHB1dCBob3Jpem9udGFsbHkgb3ZlciBob3RzcG90XG4gICAgICAgIHZhciBob3RzcG90WENlbnRlciA9IE1hdGgucm91bmQoKGhvdHNwb3QucmlnaHQgLSBob3RzcG90LmxlZnQpIC8gMiArIGhvdHNwb3QubGVmdCk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChob3RzcG90WENlbnRlciAtIHdpZHRoIC8gMikpO1xuICAgICAgICAvLyBLZWVwIG91dHB1dCB3aXRoaW4gY3JvcFxuICAgICAgICBpZiAobGVmdCA8IGNyb3AubGVmdCkge1xuICAgICAgICAgICAgbGVmdCA9IGNyb3AubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0ICsgd2lkdGggPiBjcm9wLmxlZnQgKyBjcm9wLndpZHRoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gY3JvcC5sZWZ0ICsgY3JvcC53aWR0aCAtIHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGNyb3BSZWN0ID0geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcF8yLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgY3JvcCBpcyB0YWxsZXIgdGhhbiB0aGUgZGVzaXJlZCByYXRpbywgd2UgYXJlIGN1dHRpbmcgZnJvbSB0b3AgYW5kIGJvdHRvbVxuICAgICAgICB2YXIgd2lkdGggPSBjcm9wLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5yb3VuZCh3aWR0aCAvIGRlc2lyZWRBc3BlY3RSYXRpbyk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChjcm9wLmxlZnQpKTtcbiAgICAgICAgLy8gQ2VudGVyIG91dHB1dCB2ZXJ0aWNhbGx5IG92ZXIgaG90c3BvdFxuICAgICAgICB2YXIgaG90c3BvdFlDZW50ZXIgPSBNYXRoLnJvdW5kKChob3RzcG90LmJvdHRvbSAtIGhvdHNwb3QudG9wKSAvIDIgKyBob3RzcG90LnRvcCk7XG4gICAgICAgIHZhciB0b3BfMyA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoaG90c3BvdFlDZW50ZXIgLSBoZWlnaHQgLyAyKSk7XG4gICAgICAgIC8vIEtlZXAgb3V0cHV0IHJlY3Qgd2l0aGluIGNyb3BcbiAgICAgICAgaWYgKHRvcF8zIDwgY3JvcC50b3ApIHtcbiAgICAgICAgICAgIHRvcF8zID0gY3JvcC50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG9wXzMgKyBoZWlnaHQgPiBjcm9wLnRvcCArIGNyb3AuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3BfMyA9IGNyb3AudG9wICsgY3JvcC5oZWlnaHQgLSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3JvcFJlY3QgPSB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wXzMsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGltZ1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltZ0hlaWdodCxcbiAgICAgICAgcmVjdDogY3JvcFJlY3QsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybEZvckltYWdlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/image-url/lib/node/urlForImage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/eventsource/node.js":
/*!**************************************************!*\
  !*** ./node_modules/@sanity/eventsource/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! eventsource */ \"(ssr)/./node_modules/eventsource/lib/eventsource.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ldmVudHNvdXJjZS9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBLDhHQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZXZlbnRzb3VyY2Uvbm9kZS5qcz82N2Q0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/eventsource/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ stegaEncodeSourceMap$1),\n/* harmony export */   e: () => (/* binding */ encodeIntoResult),\n/* harmony export */   s: () => (/* binding */ stegaEncodeSourceMap)\n/* harmony export */ });\n/* harmony import */ var _vercelStegaCleanAll_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vercelStegaCleanAll.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/vercelStegaCleanAll.js\");\n\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\")\n      return `${target}[${segment}]`;\n    if (segmentType === \"string\")\n      return `${target}${i === 0 ? \"\" : \".\"}${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n}, UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": `\n`,\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return `$${path.map((segment) => typeof segment == \"string\" ? `['${segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => ESCAPE[match])}']` : typeof segment == \"number\" ? `[${segment}]` : segment._key !== \"\" ? `[?(@._key=='${segment._key.replace(/['\\\\]/g, (match) => ESCAPE[match])}')]` : `[${segment._index}]`).join(\"\")}`;\n}\nfunction parseJsonPath(path) {\n  const parsed = [], parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  for (; (match = parseRe.exec(path)) !== null; ) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => UNESCAPE[m]);\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => UNESCAPE[m]);\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._key !== \"\")\n      return { _key: segment._key };\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment == \"string\" || typeof segment == \"number\")\n      return segment;\n    if (segment._index !== -1)\n      return segment._index;\n    throw new Error(`invalid segment:${JSON.stringify(segment)}`);\n  });\n}\nfunction resolveMapping(resultPath, csm) {\n  if (!(csm != null && csm.mappings))\n    return;\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0)\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0)\n    return;\n  const [matchedPath, mapping] = mappings[0], pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null;\n}\nfunction walkMap(value, mappingFn, path = []) {\n  return isArray(value) ? value.map((v, idx) => {\n    if (isRecord(v)) {\n      const _key = v._key;\n      if (typeof _key == \"string\")\n        return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n    }\n    return walkMap(v, mappingFn, path.concat(idx));\n  }) : isRecord(value) ? Object.fromEntries(\n    Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n  ) : mappingFn(value, path);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n  return walkMap(result, (value, path) => {\n    if (typeof value != \"string\")\n      return value;\n    const resolveMappingResult = resolveMapping(path, csm);\n    if (!resolveMappingResult)\n      return value;\n    const { mapping, matchedPath } = resolveMappingResult;\n    if (mapping.type !== \"value\" || mapping.source.type !== \"documentValue\")\n      return value;\n    const sourceDocument = csm.documents[mapping.source.document], sourcePath = csm.paths[mapping.source.path], matchPathSegments = parseJsonPath(matchedPath), fullSourceSegments = parseJsonPath(sourcePath).concat(path.slice(matchPathSegments.length));\n    return encoder({\n      sourcePath: fullSourceSegments,\n      sourceDocument,\n      resultPath: path,\n      value\n    });\n  });\n}\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  return id.startsWith(DRAFTS_PREFIX) ? id.slice(DRAFTS_PREFIX.length) : id;\n}\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path,\n    projectId,\n    dataset\n  } = options;\n  if (!baseUrl)\n    throw new Error(\"baseUrl is required\");\n  if (!path)\n    throw new Error(\"path is required\");\n  if (!_id)\n    throw new Error(\"id is required\");\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\"))\n    throw new Error(\"baseUrl must not end with a slash\");\n  const workspace = _workspace === \"default\" ? void 0 : _workspace, tool = _tool === \"default\" ? void 0 : _tool, id = getPublishedId(_id), stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path, searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  workspace && searchParams.set(\"workspace\", workspace), tool && searchParams.set(\"tool\", tool), projectId && searchParams.set(\"projectId\", projectId), dataset && searchParams.set(\"dataset\", dataset), _id.startsWith(DRAFTS_PREFIX) && searchParams.set(\"isDraft\", \"\");\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  workspace && segments.push(workspace);\n  const routerParams = [\n    \"mode=presentation\",\n    `id=${id}`,\n    `type=${type}`,\n    `path=${encodeURIComponent(stringifiedPath)}`\n  ];\n  return tool && routerParams.push(`tool=${tool}`), segments.push(\"intent\", \"edit\", `${routerParams.join(\";\")}?${searchParams}`), segments.join(\"/\");\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl == \"string\" ? studioUrl : studioUrl.baseUrl;\n  return baseUrl !== \"/\" && (baseUrl = baseUrl.replace(/\\/$/, \"\")), typeof studioUrl == \"string\" ? { baseUrl } : { ...studioUrl, baseUrl };\n}\nconst filterDefault = ({ sourcePath, resultPath, value }) => {\n  if (isValidDate(value) || isValidURL(value))\n    return !1;\n  const endPath = sourcePath.at(-1);\n  return !(sourcePath.at(-2) === \"slug\" && endPath === \"current\" || typeof endPath == \"string\" && endPath.startsWith(\"_\") || typeof endPath == \"number\" && sourcePath.at(-2) === \"marks\" || endPath === \"href\" && typeof sourcePath.at(-2) == \"number\" && sourcePath.at(-3) === \"markDefs\" || endPath === \"style\" || endPath === \"listItem\" || sourcePath.some(\n    (path) => path === \"meta\" || path === \"metadata\" || path === \"openGraph\" || path === \"seo\"\n  ) || hasTypeLike(sourcePath) || hasTypeLike(resultPath) || typeof endPath == \"string\" && denylist.has(endPath));\n}, denylist = /* @__PURE__ */ new Set([\n  \"color\",\n  \"colour\",\n  \"currency\",\n  \"email\",\n  \"format\",\n  \"gid\",\n  \"hex\",\n  \"href\",\n  \"hsl\",\n  \"hsla\",\n  \"icon\",\n  \"id\",\n  \"index\",\n  \"key\",\n  \"language\",\n  \"layout\",\n  \"link\",\n  \"linkAction\",\n  \"locale\",\n  \"lqip\",\n  \"page\",\n  \"path\",\n  \"ref\",\n  \"rgb\",\n  \"rgba\",\n  \"route\",\n  \"secret\",\n  \"slug\",\n  \"status\",\n  \"tag\",\n  \"template\",\n  \"theme\",\n  \"type\",\n  \"unit\",\n  \"url\",\n  \"username\",\n  \"variant\",\n  \"website\"\n]);\nfunction isValidDate(dateString) {\n  return /^\\d{4}-\\d{2}-\\d{2}/.test(dateString) ? !!Date.parse(dateString) : !1;\n}\nfunction isValidURL(url) {\n  try {\n    new URL(url, url.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction hasTypeLike(path) {\n  return path.some((segment) => typeof segment == \"string\" && segment.match(/type/i) !== null);\n}\nconst TRUNCATE_LENGTH = 20;\nfunction stegaEncodeSourceMap(result, resultSourceMap, config) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i;\n  const { filter, logger, enabled } = config;\n  if (!enabled) {\n    const msg = \"config.enabled must be true, don't call this function otherwise\";\n    throw (_a = logger == null ? void 0 : logger.error) == null || _a.call(logger, `[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  if (!resultSourceMap)\n    return (_b = logger == null ? void 0 : logger.error) == null || _b.call(logger, \"[@sanity/client]: Missing Content Source Map from response body\", {\n      result,\n      resultSourceMap,\n      config\n    }), result;\n  if (!config.studioUrl) {\n    const msg = \"config.studioUrl must be defined\";\n    throw (_c = logger == null ? void 0 : logger.error) == null || _c.call(logger, `[@sanity/client]: ${msg}`, { result, resultSourceMap, config }), new TypeError(msg);\n  }\n  const report = {\n    encoded: [],\n    skipped: []\n  }, resultWithStega = encodeIntoResult(\n    result,\n    resultSourceMap,\n    ({ sourcePath, sourceDocument, resultPath, value }) => {\n      if ((typeof filter == \"function\" ? filter({ sourcePath, resultPath, filterDefault, sourceDocument, value }) : filterDefault({ sourcePath, resultPath, filterDefault, sourceDocument, value })) === !1)\n        return logger && report.skipped.push({\n          path: prettyPathForLogging(sourcePath),\n          value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n          length: value.length\n        }), value;\n      logger && report.encoded.push({\n        path: prettyPathForLogging(sourcePath),\n        value: `${value.slice(0, TRUNCATE_LENGTH)}${value.length > TRUNCATE_LENGTH ? \"...\" : \"\"}`,\n        length: value.length\n      });\n      const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n        typeof config.studioUrl == \"function\" ? config.studioUrl(sourceDocument) : config.studioUrl\n      );\n      if (!baseUrl)\n        return value;\n      const { _id: id, _type: type, _projectId: projectId, _dataset: dataset } = sourceDocument;\n      return (0,_vercelStegaCleanAll_js__WEBPACK_IMPORTED_MODULE_0__.b)(\n        value,\n        {\n          origin: \"sanity.io\",\n          href: createEditUrl({\n            baseUrl,\n            workspace,\n            tool,\n            id,\n            type,\n            path: sourcePath,\n            ...!config.omitCrossDatasetReferenceData && { dataset, projectId }\n          })\n        },\n        // We use custom logic to determine if we should skip encoding\n        !1\n      );\n    }\n  );\n  if (logger) {\n    const isSkipping = report.skipped.length, isEncoding = report.encoded.length;\n    if ((isSkipping || isEncoding) && ((_d = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null || _d(\"[@sanity/client]: Encoding source map into result\"), (_e = logger.log) == null || _e.call(\n      logger,\n      `[@sanity/client]: Paths encoded: ${report.encoded.length}, skipped: ${report.skipped.length}`\n    )), report.encoded.length > 0 && ((_f = logger == null ? void 0 : logger.log) == null || _f.call(logger, \"[@sanity/client]: Table of encoded paths\"), (_g = (logger == null ? void 0 : logger.table) || logger.log) == null || _g(report.encoded)), report.skipped.length > 0) {\n      const skipped = /* @__PURE__ */ new Set();\n      for (const { path } of report.skipped)\n        skipped.add(path.replace(reKeySegment, \"0\").replace(/\\[\\d+\\]/g, \"[]\"));\n      (_h = logger == null ? void 0 : logger.log) == null || _h.call(logger, \"[@sanity/client]: List of skipped paths\", [...skipped.values()]);\n    }\n    (isSkipping || isEncoding) && ((_i = logger == null ? void 0 : logger.groupEnd) == null || _i.call(logger));\n  }\n  return resultWithStega;\n}\nfunction prettyPathForLogging(path) {\n  return toString(jsonPathToStudioPath(path));\n}\nvar stegaEncodeSourceMap$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  stegaEncodeSourceMap\n});\n\n//# sourceMappingURL=stegaEncodeSourceMap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxHQUFHLFFBQVE7QUFDbEM7QUFDQSxnQkFBZ0IsT0FBTyxFQUFFLG1CQUFtQixFQUFFLFFBQVE7QUFDdEQ7QUFDQSxnQkFBZ0IsT0FBTyxVQUFVLGFBQWE7QUFDOUM7QUFDQTtBQUNBLGdCQUFnQixPQUFPLEdBQUcsS0FBSyxHQUFHLEdBQUc7QUFDckM7QUFDQSxrREFBa0Qsd0JBQXdCO0FBQzFFLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0RBQXdELDREQUE0RCx1Q0FBdUMsUUFBUSwwQ0FBMEMseURBQXlELFdBQVcsZUFBZSxhQUFhO0FBQzFUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1Q0FBdUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9ELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG1CQUFtQjtBQUN0RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYixZQUFZLEtBQUs7QUFDakIsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQSwyQ0FBMkMsS0FBSyx1Q0FBdUMsb0JBQW9CLEdBQUcsR0FBRyxhQUFhO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxVQUFVLElBQUk7QUFDbkg7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBLHdHQUF3RyxJQUFJLEtBQUssaUNBQWlDO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0dBQXdHLElBQUksS0FBSyxpQ0FBaUM7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE9BQU8sK0NBQStDO0FBQ3RELGtEQUFrRCw4REFBOEQsb0JBQW9CLDhEQUE4RDtBQUNsTTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQyxFQUFFLDRDQUE0QztBQUNsRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQyxFQUFFLDRDQUE0QztBQUNoRztBQUNBLE9BQU87QUFDUCxjQUFjLDJCQUEyQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FLGFBQWEsMERBQUM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsYUFBYSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waW5nX2FwcC8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvc3RlZ2FFbmNvZGVTb3VyY2VNYXAuanM/ZmIwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBiIH0gZnJvbSBcIi4vdmVyY2VsU3RlZ2FDbGVhbkFsbC5qc1wiO1xuY29uc3QgcmVLZXlTZWdtZW50ID0gL19rZXlcXHMqPT1cXHMqWydcIl0oLiopWydcIl0vO1xuZnVuY3Rpb24gaXNLZXlTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgPyByZUtleVNlZ21lbnQudGVzdChzZWdtZW50LnRyaW0oKSkgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm9iamVjdFwiICYmIFwiX2tleVwiIGluIHNlZ21lbnQ7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhwYXRoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgcmV0dXJuIHBhdGgucmVkdWNlKCh0YXJnZXQsIHNlZ21lbnQsIGkpID0+IHtcbiAgICBjb25zdCBzZWdtZW50VHlwZSA9IHR5cGVvZiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50VHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9WyR7c2VnbWVudH1dYDtcbiAgICBpZiAoc2VnbWVudFR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fSR7aSA9PT0gMCA/IFwiXCIgOiBcIi5cIn0ke3NlZ21lbnR9YDtcbiAgICBpZiAoaXNLZXlTZWdtZW50KHNlZ21lbnQpICYmIHNlZ21lbnQuX2tleSlcbiAgICAgIHJldHVybiBgJHt0YXJnZXR9W19rZXk9PVwiJHtzZWdtZW50Ll9rZXl9XCJdYDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IHNlZ21lbnQ7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0fVske2Zyb219OiR7dG99XWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0aCBzZWdtZW50IFxcYCR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9XFxgYCk7XG4gIH0sIFwiXCIpO1xufVxuY29uc3QgRVNDQVBFID0ge1xuICBcIlxcZlwiOiBcIlxcXFxmXCIsXG4gIFwiXFxuXCI6IFwiXFxcXG5cIixcbiAgXCJcXHJcIjogXCJcXFxcclwiLFxuICBcIlx0XCI6IFwiXFxcXHRcIixcbiAgXCInXCI6IFwiXFxcXCdcIixcbiAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxufSwgVU5FU0NBUEUgPSB7XG4gIFwiXFxcXGZcIjogXCJcXGZcIixcbiAgXCJcXFxcblwiOiBgXG5gLFxuICBcIlxcXFxyXCI6IFwiXFxyXCIsXG4gIFwiXFxcXHRcIjogXCJcdFwiLFxuICBcIlxcXFwnXCI6IFwiJ1wiLFxuICBcIlxcXFxcXFxcXCI6IFwiXFxcXFwiXG59O1xuZnVuY3Rpb24ganNvblBhdGgocGF0aCkge1xuICByZXR1cm4gYCQke3BhdGgubWFwKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiID8gYFsnJHtzZWdtZW50LnJlcGxhY2UoL1tcXGZcXG5cXHJcXHQnXFxcXF0vZywgKG1hdGNoKSA9PiBFU0NBUEVbbWF0Y2hdKX0nXWAgOiB0eXBlb2Ygc2VnbWVudCA9PSBcIm51bWJlclwiID8gYFske3NlZ21lbnR9XWAgOiBzZWdtZW50Ll9rZXkgIT09IFwiXCIgPyBgWz8oQC5fa2V5PT0nJHtzZWdtZW50Ll9rZXkucmVwbGFjZSgvWydcXFxcXS9nLCAobWF0Y2gpID0+IEVTQ0FQRVttYXRjaF0pfScpXWAgOiBgWyR7c2VnbWVudC5faW5kZXh9XWApLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIHBhcnNlSnNvblBhdGgocGF0aCkge1xuICBjb25zdCBwYXJzZWQgPSBbXSwgcGFyc2VSZSA9IC9cXFsnKC4qPyknXFxdfFxcWyhcXGQrKVxcXXxcXFtcXD9cXChAXFwuX2tleT09JyguKj8pJ1xcKVxcXS9nO1xuICBsZXQgbWF0Y2g7XG4gIGZvciAoOyAobWF0Y2ggPSBwYXJzZVJlLmV4ZWMocGF0aCkpICE9PSBudWxsOyApIHtcbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXChcXFxcfGZ8bnxyfHR8JykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKGtleSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdICE9PSB2b2lkIDApIHtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlSW50KG1hdGNoWzJdLCAxMCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaFszXSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBfa2V5ID0gbWF0Y2hbM10ucmVwbGFjZSgvXFxcXChcXFxcJykvZywgKG0pID0+IFVORVNDQVBFW21dKTtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgX2tleSxcbiAgICAgICAgX2luZGV4OiAtMVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGpzb25QYXRoVG9TdHVkaW9QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9rZXkgIT09IFwiXCIpXG4gICAgICByZXR1cm4geyBfa2V5OiBzZWdtZW50Ll9rZXkgfTtcbiAgICBpZiAoc2VnbWVudC5faW5kZXggIT09IC0xKVxuICAgICAgcmV0dXJuIHNlZ21lbnQuX2luZGV4O1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBzZWdtZW50OiR7SlNPTi5zdHJpbmdpZnkoc2VnbWVudCl9YCk7XG4gIH0pO1xufVxuZnVuY3Rpb24ganNvblBhdGhUb01hcHBpbmdQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHNlZ21lbnQgPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiBzZWdtZW50O1xuICAgIGlmIChzZWdtZW50Ll9pbmRleCAhPT0gLTEpXG4gICAgICByZXR1cm4gc2VnbWVudC5faW5kZXg7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNlZ21lbnQ6JHtKU09OLnN0cmluZ2lmeShzZWdtZW50KX1gKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTWFwcGluZyhyZXN1bHRQYXRoLCBjc20pIHtcbiAgaWYgKCEoY3NtICE9IG51bGwgJiYgY3NtLm1hcHBpbmdzKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHJlc3VsdE1hcHBpbmdQYXRoID0ganNvblBhdGgoanNvblBhdGhUb01hcHBpbmdQYXRoKHJlc3VsdFBhdGgpKTtcbiAgaWYgKGNzbS5tYXBwaW5nc1tyZXN1bHRNYXBwaW5nUGF0aF0gIT09IHZvaWQgMClcbiAgICByZXR1cm4ge1xuICAgICAgbWFwcGluZzogY3NtLm1hcHBpbmdzW3Jlc3VsdE1hcHBpbmdQYXRoXSxcbiAgICAgIG1hdGNoZWRQYXRoOiByZXN1bHRNYXBwaW5nUGF0aCxcbiAgICAgIHBhdGhTdWZmaXg6IFwiXCJcbiAgICB9O1xuICBjb25zdCBtYXBwaW5ncyA9IE9iamVjdC5lbnRyaWVzKGNzbS5tYXBwaW5ncykuZmlsdGVyKChba2V5XSkgPT4gcmVzdWx0TWFwcGluZ1BhdGguc3RhcnRzV2l0aChrZXkpKS5zb3J0KChba2V5MV0sIFtrZXkyXSkgPT4ga2V5Mi5sZW5ndGggLSBrZXkxLmxlbmd0aCk7XG4gIGlmIChtYXBwaW5ncy5sZW5ndGggPT0gMClcbiAgICByZXR1cm47XG4gIGNvbnN0IFttYXRjaGVkUGF0aCwgbWFwcGluZ10gPSBtYXBwaW5nc1swXSwgcGF0aFN1ZmZpeCA9IHJlc3VsdE1hcHBpbmdQYXRoLnN1YnN0cmluZyhtYXRjaGVkUGF0aC5sZW5ndGgpO1xuICByZXR1cm4geyBtYXBwaW5nLCBtYXRjaGVkUGF0aCwgcGF0aFN1ZmZpeCB9O1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc1JlY29yZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiB3YWxrTWFwKHZhbHVlLCBtYXBwaW5nRm4sIHBhdGggPSBbXSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKHYsIGlkeCkgPT4ge1xuICAgIGlmIChpc1JlY29yZCh2KSkge1xuICAgICAgY29uc3QgX2tleSA9IHYuX2tleTtcbiAgICAgIGlmICh0eXBlb2YgX2tleSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KHsgX2tleSwgX2luZGV4OiBpZHggfSkpO1xuICAgIH1cbiAgICByZXR1cm4gd2Fsa01hcCh2LCBtYXBwaW5nRm4sIHBhdGguY29uY2F0KGlkeCkpO1xuICB9KSA6IGlzUmVjb3JkKHZhbHVlKSA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbaywgdl0pID0+IFtrLCB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaykpXSlcbiAgKSA6IG1hcHBpbmdGbih2YWx1ZSwgcGF0aCk7XG59XG5mdW5jdGlvbiBlbmNvZGVJbnRvUmVzdWx0KHJlc3VsdCwgY3NtLCBlbmNvZGVyKSB7XG4gIHJldHVybiB3YWxrTWFwKHJlc3VsdCwgKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHJlc29sdmVNYXBwaW5nUmVzdWx0ID0gcmVzb2x2ZU1hcHBpbmcocGF0aCwgY3NtKTtcbiAgICBpZiAoIXJlc29sdmVNYXBwaW5nUmVzdWx0KVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IHsgbWFwcGluZywgbWF0Y2hlZFBhdGggfSA9IHJlc29sdmVNYXBwaW5nUmVzdWx0O1xuICAgIGlmIChtYXBwaW5nLnR5cGUgIT09IFwidmFsdWVcIiB8fCBtYXBwaW5nLnNvdXJjZS50eXBlICE9PSBcImRvY3VtZW50VmFsdWVcIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzb3VyY2VEb2N1bWVudCA9IGNzbS5kb2N1bWVudHNbbWFwcGluZy5zb3VyY2UuZG9jdW1lbnRdLCBzb3VyY2VQYXRoID0gY3NtLnBhdGhzW21hcHBpbmcuc291cmNlLnBhdGhdLCBtYXRjaFBhdGhTZWdtZW50cyA9IHBhcnNlSnNvblBhdGgobWF0Y2hlZFBhdGgpLCBmdWxsU291cmNlU2VnbWVudHMgPSBwYXJzZUpzb25QYXRoKHNvdXJjZVBhdGgpLmNvbmNhdChwYXRoLnNsaWNlKG1hdGNoUGF0aFNlZ21lbnRzLmxlbmd0aCkpO1xuICAgIHJldHVybiBlbmNvZGVyKHtcbiAgICAgIHNvdXJjZVBhdGg6IGZ1bGxTb3VyY2VTZWdtZW50cyxcbiAgICAgIHNvdXJjZURvY3VtZW50LFxuICAgICAgcmVzdWx0UGF0aDogcGF0aCxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH0pO1xufVxuY29uc3QgRFJBRlRTX1BSRUZJWCA9IFwiZHJhZnRzLlwiO1xuZnVuY3Rpb24gZ2V0UHVibGlzaGVkSWQoaWQpIHtcbiAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCkgPyBpZC5zbGljZShEUkFGVFNfUFJFRklYLmxlbmd0aCkgOiBpZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRVcmwob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYmFzZVVybCxcbiAgICB3b3Jrc3BhY2U6IF93b3Jrc3BhY2UgPSBcImRlZmF1bHRcIixcbiAgICB0b29sOiBfdG9vbCA9IFwiZGVmYXVsdFwiLFxuICAgIGlkOiBfaWQsXG4gICAgdHlwZSxcbiAgICBwYXRoLFxuICAgIHByb2plY3RJZCxcbiAgICBkYXRhc2V0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAoIWJhc2VVcmwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFwYXRoKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGggaXMgcmVxdWlyZWRcIik7XG4gIGlmICghX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICBpZiAoYmFzZVVybCAhPT0gXCIvXCIgJiYgYmFzZVVybC5lbmRzV2l0aChcIi9cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZVVybCBtdXN0IG5vdCBlbmQgd2l0aCBhIHNsYXNoXCIpO1xuICBjb25zdCB3b3Jrc3BhY2UgPSBfd29ya3NwYWNlID09PSBcImRlZmF1bHRcIiA/IHZvaWQgMCA6IF93b3Jrc3BhY2UsIHRvb2wgPSBfdG9vbCA9PT0gXCJkZWZhdWx0XCIgPyB2b2lkIDAgOiBfdG9vbCwgaWQgPSBnZXRQdWJsaXNoZWRJZChfaWQpLCBzdHJpbmdpZmllZFBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gdG9TdHJpbmcoanNvblBhdGhUb1N0dWRpb1BhdGgocGF0aCkpIDogcGF0aCwgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgYmFzZVVybCxcbiAgICBpZCxcbiAgICB0eXBlLFxuICAgIHBhdGg6IHN0cmluZ2lmaWVkUGF0aFxuICB9KTtcbiAgd29ya3NwYWNlICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJ3b3Jrc3BhY2VcIiwgd29ya3NwYWNlKSwgdG9vbCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwidG9vbFwiLCB0b29sKSwgcHJvamVjdElkICYmIHNlYXJjaFBhcmFtcy5zZXQoXCJwcm9qZWN0SWRcIiwgcHJvamVjdElkKSwgZGF0YXNldCAmJiBzZWFyY2hQYXJhbXMuc2V0KFwiZGF0YXNldFwiLCBkYXRhc2V0KSwgX2lkLnN0YXJ0c1dpdGgoRFJBRlRTX1BSRUZJWCkgJiYgc2VhcmNoUGFyYW1zLnNldChcImlzRHJhZnRcIiwgXCJcIik7XG4gIGNvbnN0IHNlZ21lbnRzID0gW2Jhc2VVcmwgPT09IFwiL1wiID8gXCJcIiA6IGJhc2VVcmxdO1xuICB3b3Jrc3BhY2UgJiYgc2VnbWVudHMucHVzaCh3b3Jrc3BhY2UpO1xuICBjb25zdCByb3V0ZXJQYXJhbXMgPSBbXG4gICAgXCJtb2RlPXByZXNlbnRhdGlvblwiLFxuICAgIGBpZD0ke2lkfWAsXG4gICAgYHR5cGU9JHt0eXBlfWAsXG4gICAgYHBhdGg9JHtlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZpZWRQYXRoKX1gXG4gIF07XG4gIHJldHVybiB0b29sICYmIHJvdXRlclBhcmFtcy5wdXNoKGB0b29sPSR7dG9vbH1gKSwgc2VnbWVudHMucHVzaChcImludGVudFwiLCBcImVkaXRcIiwgYCR7cm91dGVyUGFyYW1zLmpvaW4oXCI7XCIpfT8ke3NlYXJjaFBhcmFtc31gKSwgc2VnbWVudHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiByZXNvbHZlU3R1ZGlvQmFzZVJvdXRlKHN0dWRpb1VybCkge1xuICBsZXQgYmFzZVVybCA9IHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHN0dWRpb1VybCA6IHN0dWRpb1VybC5iYXNlVXJsO1xuICByZXR1cm4gYmFzZVVybCAhPT0gXCIvXCIgJiYgKGJhc2VVcmwgPSBiYXNlVXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSksIHR5cGVvZiBzdHVkaW9VcmwgPT0gXCJzdHJpbmdcIiA/IHsgYmFzZVVybCB9IDogeyAuLi5zdHVkaW9VcmwsIGJhc2VVcmwgfTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSAoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCB2YWx1ZSB9KSA9PiB7XG4gIGlmIChpc1ZhbGlkRGF0ZSh2YWx1ZSkgfHwgaXNWYWxpZFVSTCh2YWx1ZSkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlbmRQYXRoID0gc291cmNlUGF0aC5hdCgtMSk7XG4gIHJldHVybiAhKHNvdXJjZVBhdGguYXQoLTIpID09PSBcInNsdWdcIiAmJiBlbmRQYXRoID09PSBcImN1cnJlbnRcIiB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIGVuZFBhdGguc3RhcnRzV2l0aChcIl9cIikgfHwgdHlwZW9mIGVuZFBhdGggPT0gXCJudW1iZXJcIiAmJiBzb3VyY2VQYXRoLmF0KC0yKSA9PT0gXCJtYXJrc1wiIHx8IGVuZFBhdGggPT09IFwiaHJlZlwiICYmIHR5cGVvZiBzb3VyY2VQYXRoLmF0KC0yKSA9PSBcIm51bWJlclwiICYmIHNvdXJjZVBhdGguYXQoLTMpID09PSBcIm1hcmtEZWZzXCIgfHwgZW5kUGF0aCA9PT0gXCJzdHlsZVwiIHx8IGVuZFBhdGggPT09IFwibGlzdEl0ZW1cIiB8fCBzb3VyY2VQYXRoLnNvbWUoXG4gICAgKHBhdGgpID0+IHBhdGggPT09IFwibWV0YVwiIHx8IHBhdGggPT09IFwibWV0YWRhdGFcIiB8fCBwYXRoID09PSBcIm9wZW5HcmFwaFwiIHx8IHBhdGggPT09IFwic2VvXCJcbiAgKSB8fCBoYXNUeXBlTGlrZShzb3VyY2VQYXRoKSB8fCBoYXNUeXBlTGlrZShyZXN1bHRQYXRoKSB8fCB0eXBlb2YgZW5kUGF0aCA9PSBcInN0cmluZ1wiICYmIGRlbnlsaXN0LmhhcyhlbmRQYXRoKSk7XG59LCBkZW55bGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjb2xvclwiLFxuICBcImNvbG91clwiLFxuICBcImN1cnJlbmN5XCIsXG4gIFwiZW1haWxcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJnaWRcIixcbiAgXCJoZXhcIixcbiAgXCJocmVmXCIsXG4gIFwiaHNsXCIsXG4gIFwiaHNsYVwiLFxuICBcImljb25cIixcbiAgXCJpZFwiLFxuICBcImluZGV4XCIsXG4gIFwia2V5XCIsXG4gIFwibGFuZ3VhZ2VcIixcbiAgXCJsYXlvdXRcIixcbiAgXCJsaW5rXCIsXG4gIFwibGlua0FjdGlvblwiLFxuICBcImxvY2FsZVwiLFxuICBcImxxaXBcIixcbiAgXCJwYWdlXCIsXG4gIFwicGF0aFwiLFxuICBcInJlZlwiLFxuICBcInJnYlwiLFxuICBcInJnYmFcIixcbiAgXCJyb3V0ZVwiLFxuICBcInNlY3JldFwiLFxuICBcInNsdWdcIixcbiAgXCJzdGF0dXNcIixcbiAgXCJ0YWdcIixcbiAgXCJ0ZW1wbGF0ZVwiLFxuICBcInRoZW1lXCIsXG4gIFwidHlwZVwiLFxuICBcInVuaXRcIixcbiAgXCJ1cmxcIixcbiAgXCJ1c2VybmFtZVwiLFxuICBcInZhcmlhbnRcIixcbiAgXCJ3ZWJzaXRlXCJcbl0pO1xuZnVuY3Rpb24gaXNWYWxpZERhdGUoZGF0ZVN0cmluZykge1xuICByZXR1cm4gL15cXGR7NH0tXFxkezJ9LVxcZHsyfS8udGVzdChkYXRlU3RyaW5nKSA/ICEhRGF0ZS5wYXJzZShkYXRlU3RyaW5nKSA6ICExO1xufVxuZnVuY3Rpb24gaXNWYWxpZFVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICBuZXcgVVJMKHVybCwgdXJsLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJodHRwczovL2FjbWUuY29tXCIgOiB2b2lkIDApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gaGFzVHlwZUxpa2UocGF0aCkge1xuICByZXR1cm4gcGF0aC5zb21lKChzZWdtZW50KSA9PiB0eXBlb2Ygc2VnbWVudCA9PSBcInN0cmluZ1wiICYmIHNlZ21lbnQubWF0Y2goL3R5cGUvaSkgIT09IG51bGwpO1xufVxuY29uc3QgVFJVTkNBVEVfTEVOR1RIID0gMjA7XG5mdW5jdGlvbiBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXN1bHQsIHJlc3VsdFNvdXJjZU1hcCwgY29uZmlnKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pO1xuICBjb25zdCB7IGZpbHRlciwgbG9nZ2VyLCBlbmFibGVkIH0gPSBjb25maWc7XG4gIGlmICghZW5hYmxlZCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLmVuYWJsZWQgbXVzdCBiZSB0cnVlLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb3RoZXJ3aXNlXCI7XG4gICAgdGhyb3cgKF9hID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZXJyb3IpID09IG51bGwgfHwgX2EuY2FsbChsb2dnZXIsIGBbQHNhbml0eS9jbGllbnRdOiAke21zZ31gLCB7IHJlc3VsdCwgcmVzdWx0U291cmNlTWFwLCBjb25maWcgfSksIG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxuICBpZiAoIXJlc3VsdFNvdXJjZU1hcClcbiAgICByZXR1cm4gKF9iID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZXJyb3IpID09IG51bGwgfHwgX2IuY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvY2xpZW50XTogTWlzc2luZyBDb250ZW50IFNvdXJjZSBNYXAgZnJvbSByZXNwb25zZSBib2R5XCIsIHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHJlc3VsdFNvdXJjZU1hcCxcbiAgICAgIGNvbmZpZ1xuICAgIH0pLCByZXN1bHQ7XG4gIGlmICghY29uZmlnLnN0dWRpb1VybCkge1xuICAgIGNvbnN0IG1zZyA9IFwiY29uZmlnLnN0dWRpb1VybCBtdXN0IGJlIGRlZmluZWRcIjtcbiAgICB0aHJvdyAoX2MgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5lcnJvcikgPT0gbnVsbCB8fCBfYy5jYWxsKGxvZ2dlciwgYFtAc2FuaXR5L2NsaWVudF06ICR7bXNnfWAsIHsgcmVzdWx0LCByZXN1bHRTb3VyY2VNYXAsIGNvbmZpZyB9KSwgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG4gIGNvbnN0IHJlcG9ydCA9IHtcbiAgICBlbmNvZGVkOiBbXSxcbiAgICBza2lwcGVkOiBbXVxuICB9LCByZXN1bHRXaXRoU3RlZ2EgPSBlbmNvZGVJbnRvUmVzdWx0KFxuICAgIHJlc3VsdCxcbiAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgKHsgc291cmNlUGF0aCwgc291cmNlRG9jdW1lbnQsIHJlc3VsdFBhdGgsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmICgodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgPyBmaWx0ZXIoeyBzb3VyY2VQYXRoLCByZXN1bHRQYXRoLCBmaWx0ZXJEZWZhdWx0LCBzb3VyY2VEb2N1bWVudCwgdmFsdWUgfSkgOiBmaWx0ZXJEZWZhdWx0KHsgc291cmNlUGF0aCwgcmVzdWx0UGF0aCwgZmlsdGVyRGVmYXVsdCwgc291cmNlRG9jdW1lbnQsIHZhbHVlIH0pKSA9PT0gITEpXG4gICAgICAgIHJldHVybiBsb2dnZXIgJiYgcmVwb3J0LnNraXBwZWQucHVzaCh7XG4gICAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgICAgdmFsdWU6IGAke3ZhbHVlLnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCl9JHt2YWx1ZS5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIn1gLFxuICAgICAgICAgIGxlbmd0aDogdmFsdWUubGVuZ3RoXG4gICAgICAgIH0pLCB2YWx1ZTtcbiAgICAgIGxvZ2dlciAmJiByZXBvcnQuZW5jb2RlZC5wdXNoKHtcbiAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgIHZhbHVlOiBgJHt2YWx1ZS5zbGljZSgwLCBUUlVOQ0FURV9MRU5HVEgpfSR7dmFsdWUubGVuZ3RoID4gVFJVTkNBVEVfTEVOR1RIID8gXCIuLi5cIiA6IFwiXCJ9YCxcbiAgICAgICAgbGVuZ3RoOiB2YWx1ZS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgY29uc3QgeyBiYXNlVXJsLCB3b3Jrc3BhY2UsIHRvb2wgfSA9IHJlc29sdmVTdHVkaW9CYXNlUm91dGUoXG4gICAgICAgIHR5cGVvZiBjb25maWcuc3R1ZGlvVXJsID09IFwiZnVuY3Rpb25cIiA/IGNvbmZpZy5zdHVkaW9Vcmwoc291cmNlRG9jdW1lbnQpIDogY29uZmlnLnN0dWRpb1VybFxuICAgICAgKTtcbiAgICAgIGlmICghYmFzZVVybClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgY29uc3QgeyBfaWQ6IGlkLCBfdHlwZTogdHlwZSwgX3Byb2plY3RJZDogcHJvamVjdElkLCBfZGF0YXNldDogZGF0YXNldCB9ID0gc291cmNlRG9jdW1lbnQ7XG4gICAgICByZXR1cm4gYihcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHtcbiAgICAgICAgICBvcmlnaW46IFwic2FuaXR5LmlvXCIsXG4gICAgICAgICAgaHJlZjogY3JlYXRlRWRpdFVybCh7XG4gICAgICAgICAgICBiYXNlVXJsLFxuICAgICAgICAgICAgd29ya3NwYWNlLFxuICAgICAgICAgICAgdG9vbCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHBhdGg6IHNvdXJjZVBhdGgsXG4gICAgICAgICAgICAuLi4hY29uZmlnLm9taXRDcm9zc0RhdGFzZXRSZWZlcmVuY2VEYXRhICYmIHsgZGF0YXNldCwgcHJvamVjdElkIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvLyBXZSB1c2UgY3VzdG9tIGxvZ2ljIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgc2tpcCBlbmNvZGluZ1xuICAgICAgICAhMVxuICAgICAgKTtcbiAgICB9XG4gICk7XG4gIGlmIChsb2dnZXIpIHtcbiAgICBjb25zdCBpc1NraXBwaW5nID0gcmVwb3J0LnNraXBwZWQubGVuZ3RoLCBpc0VuY29kaW5nID0gcmVwb3J0LmVuY29kZWQubGVuZ3RoO1xuICAgIGlmICgoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSAmJiAoKF9kID0gKGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKSB8fCBsb2dnZXIubG9nKSA9PSBudWxsIHx8IF9kKFwiW0BzYW5pdHkvY2xpZW50XTogRW5jb2Rpbmcgc291cmNlIG1hcCBpbnRvIHJlc3VsdFwiKSwgKF9lID0gbG9nZ2VyLmxvZykgPT0gbnVsbCB8fCBfZS5jYWxsKFxuICAgICAgbG9nZ2VyLFxuICAgICAgYFtAc2FuaXR5L2NsaWVudF06IFBhdGhzIGVuY29kZWQ6ICR7cmVwb3J0LmVuY29kZWQubGVuZ3RofSwgc2tpcHBlZDogJHtyZXBvcnQuc2tpcHBlZC5sZW5ndGh9YFxuICAgICkpLCByZXBvcnQuZW5jb2RlZC5sZW5ndGggPiAwICYmICgoX2YgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5sb2cpID09IG51bGwgfHwgX2YuY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvY2xpZW50XTogVGFibGUgb2YgZW5jb2RlZCBwYXRoc1wiKSwgKF9nID0gKGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLnRhYmxlKSB8fCBsb2dnZXIubG9nKSA9PSBudWxsIHx8IF9nKHJlcG9ydC5lbmNvZGVkKSksIHJlcG9ydC5za2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNraXBwZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCB7IHBhdGggfSBvZiByZXBvcnQuc2tpcHBlZClcbiAgICAgICAgc2tpcHBlZC5hZGQocGF0aC5yZXBsYWNlKHJlS2V5U2VnbWVudCwgXCIwXCIpLnJlcGxhY2UoL1xcW1xcZCtcXF0vZywgXCJbXVwiKSk7XG4gICAgICAoX2ggPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5sb2cpID09IG51bGwgfHwgX2guY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvY2xpZW50XTogTGlzdCBvZiBza2lwcGVkIHBhdGhzXCIsIFsuLi5za2lwcGVkLnZhbHVlcygpXSk7XG4gICAgfVxuICAgIChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpICYmICgoX2kgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5ncm91cEVuZCkgPT0gbnVsbCB8fCBfaS5jYWxsKGxvZ2dlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHRXaXRoU3RlZ2E7XG59XG5mdW5jdGlvbiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhwYXRoKSB7XG4gIHJldHVybiB0b1N0cmluZyhqc29uUGF0aFRvU3R1ZGlvUGF0aChwYXRoKSk7XG59XG52YXIgc3RlZ2FFbmNvZGVTb3VyY2VNYXAkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBzdGVnYUVuY29kZVNvdXJjZU1hcFxufSk7XG5leHBvcnQge1xuICBzdGVnYUVuY29kZVNvdXJjZU1hcCQxIGFzIGEsXG4gIGVuY29kZUludG9SZXN1bHQgYXMgZSxcbiAgc3RlZ2FFbmNvZGVTb3VyY2VNYXAgYXMgc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0ZWdhRW5jb2RlU291cmNlTWFwLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/_chunks-es/vercelStegaCleanAll.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@sanity/client/dist/_chunks-es/vercelStegaCleanAll.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   b: () => (/* binding */ b),\n/* harmony export */   v: () => (/* binding */ vercelStegaCleanAll)\n/* harmony export */ });\nvar s = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, c = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, d = new Array(4).fill(String.fromCodePoint(c[0])).join(\"\");\nfunction E(t) {\n  let e = JSON.stringify(t);\n  return `${d}${Array.from(e).map((r) => {\n    let n = r.charCodeAt(0);\n    if (n > 255)\n      throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);\n    return Array.from(n.toString(4).padStart(4, \"0\")).map((o) => String.fromCodePoint(c[o])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction I(t) {\n  return Number.isNaN(Number(t)) ? !!Date.parse(t) : !1;\n}\nfunction x(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nfunction b(t, e, r = \"auto\") {\n  return r === !0 || r === \"auto\" && (I(t) || x(t)) ? t : `${t}${E(e)}`;\n}\nObject.fromEntries(Object.entries(c).map((t) => t.reverse()));\nObject.fromEntries(Object.entries(s).map((t) => t.reverse()));\nvar S = `${Object.values(s).map((t) => `\\\\u{${t.toString(16)}}`).join(\"\")}`, f = new RegExp(`[${S}]{4,}`, \"gu\");\nfunction X(t) {\n  var e;\n  return { cleaned: t.replace(f, \"\"), encoded: ((e = t.match(f)) == null ? void 0 : e[0]) || \"\" };\n}\nfunction vercelStegaCleanAll(result) {\n  try {\n    return JSON.parse(\n      JSON.stringify(result, (key, value) => typeof value != \"string\" ? value : X(value).cleaned)\n    );\n  } catch {\n    return result;\n  }\n}\n\n//# sourceMappingURL=vercelStegaCleanAll.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9fY2h1bmtzLWVzL3ZlcmNlbFN0ZWdhQ2xlYW5BbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxVQUFVLGlLQUFpSyxRQUFRLHFDQUFxQztBQUN4TjtBQUNBO0FBQ0EsWUFBWSxFQUFFLEVBQUU7QUFDaEI7QUFDQTtBQUNBLHlGQUF5RixHQUFHLGVBQWUsR0FBRyxHQUFHLEVBQUU7QUFDbkg7QUFDQSxHQUFHLFdBQVc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELEVBQUUsRUFBRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDLEVBQUUsZ0JBQWdCLFlBQVksc0JBQXNCLEVBQUUsRUFBRSxHQUFHO0FBQ3ZHO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zaG9waW5nX2FwcC8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2NsaWVudC9kaXN0L19jaHVua3MtZXMvdmVyY2VsU3RlZ2FDbGVhbkFsbC5qcz9kZGJkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzID0geyAwOiA4MjAzLCAxOiA4MjA0LCAyOiA4MjA1LCAzOiA4MjkwLCA0OiA4MjkxLCA1OiA4Mjg4LCA2OiA2NTI3OSwgNzogODI4OSwgODogMTE5MTU1LCA5OiAxMTkxNTYsIGE6IDExOTE1NywgYjogMTE5MTU4LCBjOiAxMTkxNTksIGQ6IDExOTE2MCwgZTogMTE5MTYxLCBmOiAxMTkxNjIgfSwgYyA9IHsgMDogODIwMywgMTogODIwNCwgMjogODIwNSwgMzogNjUyNzkgfSwgZCA9IG5ldyBBcnJheSg0KS5maWxsKFN0cmluZy5mcm9tQ29kZVBvaW50KGNbMF0pKS5qb2luKFwiXCIpO1xuZnVuY3Rpb24gRSh0KSB7XG4gIGxldCBlID0gSlNPTi5zdHJpbmdpZnkodCk7XG4gIHJldHVybiBgJHtkfSR7QXJyYXkuZnJvbShlKS5tYXAoKHIpID0+IHtcbiAgICBsZXQgbiA9IHIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAobiA+IDI1NSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBBU0NJSSBlZGl0IGluZm8gY2FuIGJlIGVuY29kZWQuIEVycm9yIGF0dGVtcHRpbmcgdG8gZW5jb2RlICR7ZX0gb24gY2hhcmFjdGVyICR7cn0gKCR7bn0pYCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obi50b1N0cmluZyg0KS5wYWRTdGFydCg0LCBcIjBcIikpLm1hcCgobykgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY1tvXSkpLmpvaW4oXCJcIik7XG4gIH0pLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIEkodCkge1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKE51bWJlcih0KSkgPyAhIURhdGUucGFyc2UodCkgOiAhMTtcbn1cbmZ1bmN0aW9uIHgodCkge1xuICB0cnkge1xuICAgIG5ldyBVUkwodCwgdC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiaHR0cHM6Ly9hY21lLmNvbVwiIDogdm9pZCAwKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGIodCwgZSwgciA9IFwiYXV0b1wiKSB7XG4gIHJldHVybiByID09PSAhMCB8fCByID09PSBcImF1dG9cIiAmJiAoSSh0KSB8fCB4KHQpKSA/IHQgOiBgJHt0fSR7RShlKX1gO1xufVxuT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGMpLm1hcCgodCkgPT4gdC5yZXZlcnNlKCkpKTtcbk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzKS5tYXAoKHQpID0+IHQucmV2ZXJzZSgpKSk7XG52YXIgUyA9IGAke09iamVjdC52YWx1ZXMocykubWFwKCh0KSA9PiBgXFxcXHV7JHt0LnRvU3RyaW5nKDE2KX19YCkuam9pbihcIlwiKX1gLCBmID0gbmV3IFJlZ0V4cChgWyR7U31dezQsfWAsIFwiZ3VcIik7XG5mdW5jdGlvbiBYKHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiB7IGNsZWFuZWQ6IHQucmVwbGFjZShmLCBcIlwiKSwgZW5jb2RlZDogKChlID0gdC5tYXRjaChmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGVbMF0pIHx8IFwiXCIgfTtcbn1cbmZ1bmN0aW9uIHZlcmNlbFN0ZWdhQ2xlYW5BbGwocmVzdWx0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeShyZXN1bHQsIChrZXksIHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogWCh2YWx1ZSkuY2xlYW5lZClcbiAgICApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5leHBvcnQge1xuICBiLFxuICB2ZXJjZWxTdGVnYUNsZWFuQWxsIGFzIHZcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJjZWxTdGVnYUNsZWFuQWxsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/_chunks-es/vercelStegaCleanAll.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@sanity/client/dist/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@sanity/client/dist/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePatch: () => (/* binding */ BasePatch),\n/* harmony export */   BaseTransaction: () => (/* binding */ BaseTransaction),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ObservablePatch: () => (/* binding */ ObservablePatch),\n/* harmony export */   ObservableSanityClient: () => (/* binding */ ObservableSanityClient),\n/* harmony export */   ObservableTransaction: () => (/* binding */ ObservableTransaction),\n/* harmony export */   Patch: () => (/* binding */ Patch),\n/* harmony export */   SanityClient: () => (/* binding */ SanityClient),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   \"default\": () => (/* binding */ deprecatedCreateClient),\n/* harmony export */   requester: () => (/* binding */ requester),\n/* harmony export */   unstable__adapter: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.adapter),\n/* harmony export */   unstable__environment: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.environment)\n/* harmony export */ });\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! get-it */ \"(ssr)/./node_modules/get-it/dist/index.js\");\n/* harmony import */ var get_it_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-it/middleware */ \"(ssr)/./node_modules/get-it/dist/middleware.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"(ssr)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n/* harmony import */ var _chunks_es_vercelStegaCleanAll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_chunks-es/vercelStegaCleanAll.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/vercelStegaCleanAll.js\");\n\n\n\n\n\n\nvar __defProp$3 = Object.defineProperty, __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$3 = (obj, key, value) => (__defNormalProp$3(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value);\nclass ClientError extends Error {\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), __publicField$3(this, \"response\"), __publicField$3(this, \"statusCode\", 400), __publicField$3(this, \"responseBody\"), __publicField$3(this, \"details\"), Object.assign(this, props);\n  }\n}\nclass ServerError extends Error {\n  constructor(res) {\n    const props = extractErrorProps(res);\n    super(props.message), __publicField$3(this, \"response\"), __publicField$3(this, \"statusCode\", 500), __publicField$3(this, \"responseBody\"), __publicField$3(this, \"details\"), Object.assign(this, props);\n  }\n}\nfunction extractErrorProps(res) {\n  const body = res.body, props = {\n    response: res,\n    statusCode: res.statusCode,\n    responseBody: stringifyBody(body, res),\n    message: \"\",\n    details: void 0\n  };\n  if (body.error && body.message)\n    return props.message = `${body.error} - ${body.message}`, props;\n  if (isMutationError(body)) {\n    const allItems = body.error.items || [], items = allItems.slice(0, 5).map((item) => {\n      var _a;\n      return (_a = item.error) == null ? void 0 : _a.description;\n    }).filter(Boolean);\n    let itemsStr = items.length ? `:\n- ${items.join(`\n- `)}` : \"\";\n    return allItems.length > 5 && (itemsStr += `\n...and ${allItems.length - 5} more`), props.message = `${body.error.description}${itemsStr}`, props.details = body.error, props;\n  }\n  return body.error && body.error.description ? (props.message = body.error.description, props.details = body.error, props) : (props.message = body.error || body.message || httpErrorMessage(res), props);\n}\nfunction isMutationError(body) {\n  return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"mutationError\" && typeof body.error.description == \"string\";\n}\nfunction isPlainObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction httpErrorMessage(res) {\n  const statusMessage = res.statusMessage ? ` ${res.statusMessage}` : \"\";\n  return `${res.method}-request to ${res.url} resulted in HTTP ${res.statusCode}${statusMessage}`;\n}\nfunction stringifyBody(body, res) {\n  return (res.headers[\"content-type\"] || \"\").toLowerCase().indexOf(\"application/json\") !== -1 ? JSON.stringify(body, null, 2) : body;\n}\nconst httpError = {\n  onResponse: (res) => {\n    if (res.statusCode >= 500)\n      throw new ServerError(res);\n    if (res.statusCode >= 400)\n      throw new ClientError(res);\n    return res;\n  }\n}, printWarnings = {\n  onResponse: (res) => {\n    const warn = res.headers[\"x-sanity-warning\"];\n    return (Array.isArray(warn) ? warn : [warn]).filter(Boolean).forEach((msg) => console.warn(msg)), res;\n  }\n};\nfunction defineHttpRequest(envMiddleware) {\n  return (0,get_it__WEBPACK_IMPORTED_MODULE_0__.getIt)([\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry)({ shouldRetry }),\n    ...envMiddleware,\n    printWarnings,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonRequest)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonResponse)(),\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.progress)(),\n    httpError,\n    (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.observable)({ implementation: rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable })\n  ]);\n}\nfunction shouldRetry(err, attempt, options) {\n  if (options.maxRetries === 0)\n    return !1;\n  const isSafe = options.method === \"GET\" || options.method === \"HEAD\", isQuery = (options.uri || options.url).startsWith(\"/data/query\"), isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);\n  return (isSafe || isQuery) && isRetriableResponse ? !0 : get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry.shouldRetry(err, attempt, options);\n}\nfunction getSelection(sel) {\n  if (typeof sel == \"string\")\n    return { id: sel };\n  if (Array.isArray(sel))\n    return { query: \"*[_id in $ids]\", params: { ids: sel } };\n  if (typeof sel == \"object\" && sel !== null && \"query\" in sel && typeof sel.query == \"string\")\n    return \"params\" in sel && typeof sel.params == \"object\" && sel.params !== null ? { query: sel.query, params: sel.params } : { query: sel.query };\n  const selectionOpts = [\n    \"* Document ID (<docId>)\",\n    \"* Array of document IDs\",\n    \"* Object containing `query`\"\n  ].join(`\n`);\n  throw new Error(`Unknown selection - must be one of:\n\n${selectionOpts}`);\n}\nconst VALID_ASSET_TYPES = [\"image\", \"file\"], VALID_INSERT_LOCATIONS = [\"before\", \"after\", \"replace\"], dataset = (name2) => {\n  if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name2))\n    throw new Error(\n      \"Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters\"\n    );\n}, projectId = (id) => {\n  if (!/^[-a-z0-9]+$/i.test(id))\n    throw new Error(\"`projectId` can only contain only a-z, 0-9 and dashes\");\n}, validateAssetType = (type) => {\n  if (VALID_ASSET_TYPES.indexOf(type) === -1)\n    throw new Error(`Invalid asset type: ${type}. Must be one of ${VALID_ASSET_TYPES.join(\", \")}`);\n}, validateObject = (op, val) => {\n  if (val === null || typeof val != \"object\" || Array.isArray(val))\n    throw new Error(`${op}() takes an object of properties`);\n}, validateDocumentId = (op, id) => {\n  if (typeof id != \"string\" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes(\"..\"))\n    throw new Error(`${op}(): \"${id}\" is not a valid document ID`);\n}, requireDocumentId = (op, doc) => {\n  if (!doc._id)\n    throw new Error(`${op}() requires that the document contains an ID (\"_id\" property)`);\n  validateDocumentId(op, doc._id);\n}, validateInsert = (at, selector, items) => {\n  const signature = \"insert(at, selector, items)\";\n  if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n    const valid = VALID_INSERT_LOCATIONS.map((loc) => `\"${loc}\"`).join(\", \");\n    throw new Error(`${signature} takes an \"at\"-argument which is one of: ${valid}`);\n  }\n  if (typeof selector != \"string\")\n    throw new Error(`${signature} takes a \"selector\"-argument which must be a string`);\n  if (!Array.isArray(items))\n    throw new Error(`${signature} takes an \"items\"-argument which must be an array`);\n}, hasDataset = (config) => {\n  if (!config.dataset)\n    throw new Error(\"`dataset` must be provided to perform queries\");\n  return config.dataset || \"\";\n}, requestTag = (tag) => {\n  if (typeof tag != \"string\" || !/^[a-z0-9._-]{1,75}$/i.test(tag))\n    throw new Error(\n      \"Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.\"\n    );\n  return tag;\n};\nvar __defProp$2 = Object.defineProperty, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$2 = (obj, key, value) => (__defNormalProp$2(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value), __accessCheck$6 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n}, __privateGet$6 = (obj, member, getter) => (__accessCheck$6(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd$6 = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n}, __privateSet$6 = (obj, member, value, setter) => (__accessCheck$6(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nclass BasePatch {\n  constructor(selection, operations = {}) {\n    __publicField$2(this, \"selection\"), __publicField$2(this, \"operations\"), this.selection = selection, this.operations = operations;\n  }\n  /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  set(attrs) {\n    return this._assign(\"set\", attrs);\n  }\n  /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */\n  setIfMissing(attrs) {\n    return this._assign(\"setIfMissing\", attrs);\n  }\n  /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */\n  diffMatchPatch(attrs) {\n    return validateObject(\"diffMatchPatch\", attrs), this._assign(\"diffMatchPatch\", attrs);\n  }\n  /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */\n  unset(attrs) {\n    if (!Array.isArray(attrs))\n      throw new Error(\"unset(attrs) takes an array of attributes to unset, non-array given\");\n    return this.operations = Object.assign({}, this.operations, { unset: attrs }), this;\n  }\n  /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */\n  inc(attrs) {\n    return this._assign(\"inc\", attrs);\n  }\n  /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */\n  dec(attrs) {\n    return this._assign(\"dec\", attrs);\n  }\n  /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */\n  insert(at, selector, items) {\n    return validateInsert(at, selector, items), this._assign(\"insert\", { [at]: selector, items });\n  }\n  /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */\n  append(selector, items) {\n    return this.insert(\"after\", `${selector}[-1]`, items);\n  }\n  /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */\n  prepend(selector, items) {\n    return this.insert(\"before\", `${selector}[0]`, items);\n  }\n  /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */\n  splice(selector, start, deleteCount, items) {\n    const delAll = typeof deleteCount > \"u\" || deleteCount === -1, startIndex = start < 0 ? start - 1 : start, delCount = delAll ? -1 : Math.max(0, start + deleteCount), delRange = startIndex < 0 && delCount >= 0 ? \"\" : delCount, rangeSelector = `${selector}[${startIndex}:${delRange}]`;\n    return this.insert(\"replace\", rangeSelector, items || []);\n  }\n  /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */\n  ifRevisionId(rev) {\n    return this.operations.ifRevisionID = rev, this;\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  serialize() {\n    return { ...getSelection(this.selection), ...this.operations };\n  }\n  /**\n   * Return a plain JSON representation of the patch\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the patch of all operations\n   */\n  reset() {\n    return this.operations = {}, this;\n  }\n  _assign(op, props, merge = !0) {\n    return validateObject(op, props), this.operations = Object.assign({}, this.operations, {\n      [op]: Object.assign({}, merge && this.operations[op] || {}, props)\n    }), this;\n  }\n  _set(op, props) {\n    return this._assign(op, props, !1);\n  }\n}\nvar _client$5;\nconst _ObservablePatch = class _ObservablePatch2 extends BasePatch {\n  constructor(selection, operations, client) {\n    super(selection, operations), __privateAdd$6(this, _client$5, void 0), __privateSet$6(this, _client$5, client);\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new _ObservablePatch2(this.selection, { ...this.operations }, __privateGet$6(this, _client$5));\n  }\n  commit(options) {\n    if (!__privateGet$6(this, _client$5))\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return __privateGet$6(this, _client$5).mutate({ patch: this.serialize() }, opts);\n  }\n};\n_client$5 = /* @__PURE__ */ new WeakMap();\nlet ObservablePatch = _ObservablePatch;\nvar _client2$5;\nconst _Patch = class _Patch2 extends BasePatch {\n  constructor(selection, operations, client) {\n    super(selection, operations), __privateAdd$6(this, _client2$5, void 0), __privateSet$6(this, _client2$5, client);\n  }\n  /**\n   * Clones the patch\n   */\n  clone() {\n    return new _Patch2(this.selection, { ...this.operations }, __privateGet$6(this, _client2$5));\n  }\n  commit(options) {\n    if (!__privateGet$6(this, _client2$5))\n      throw new Error(\n        \"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\"\n      );\n    const returnFirst = typeof this.selection == \"string\", opts = Object.assign({ returnFirst, returnDocuments: !0 }, options);\n    return __privateGet$6(this, _client2$5).mutate({ patch: this.serialize() }, opts);\n  }\n};\n_client2$5 = /* @__PURE__ */ new WeakMap();\nlet Patch = _Patch;\nvar __defProp$1 = Object.defineProperty, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField$1 = (obj, key, value) => (__defNormalProp$1(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value), __accessCheck$5 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n}, __privateGet$5 = (obj, member, getter) => (__accessCheck$5(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd$5 = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n}, __privateSet$5 = (obj, member, value, setter) => (__accessCheck$5(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nconst defaultMutateOptions = { returnDocuments: !1 };\nclass BaseTransaction {\n  constructor(operations = [], transactionId) {\n    __publicField$1(this, \"operations\"), __publicField$1(this, \"trxId\"), this.operations = operations, this.trxId = transactionId;\n  }\n  /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */\n  create(doc) {\n    return validateObject(\"create\", doc), this._add({ create: doc });\n  }\n  /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */\n  createIfNotExists(doc) {\n    const op = \"createIfNotExists\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */\n  createOrReplace(doc) {\n    const op = \"createOrReplace\";\n    return validateObject(op, doc), requireDocumentId(op, doc), this._add({ [op]: doc });\n  }\n  /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */\n  delete(documentId) {\n    return validateDocumentId(\"delete\", documentId), this._add({ delete: { id: documentId } });\n  }\n  transactionId(id) {\n    return id ? (this.trxId = id, this) : this.trxId;\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  serialize() {\n    return [...this.operations];\n  }\n  /**\n   * Return a plain JSON representation of the transaction\n   */\n  toJSON() {\n    return this.serialize();\n  }\n  /**\n   * Clears the transaction of all operations\n   */\n  reset() {\n    return this.operations = [], this;\n  }\n  _add(mut) {\n    return this.operations.push(mut), this;\n  }\n}\nvar _client$4;\nconst _Transaction = class _Transaction2 extends BaseTransaction {\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), __privateAdd$5(this, _client$4, void 0), __privateSet$5(this, _client$4, client);\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new _Transaction2([...this.operations], __privateGet$5(this, _client$4), this.trxId);\n  }\n  commit(options) {\n    if (!__privateGet$5(this, _client$4))\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return __privateGet$5(this, _client$4).mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof Patch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new Patch(patchOrDocumentId, {}, __privateGet$5(this, _client$4)));\n      if (!(patch instanceof Patch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n};\n_client$4 = /* @__PURE__ */ new WeakMap();\nlet Transaction = _Transaction;\nvar _client2$4;\nconst _ObservableTransaction = class _ObservableTransaction2 extends BaseTransaction {\n  constructor(operations, client, transactionId) {\n    super(operations, transactionId), __privateAdd$5(this, _client2$4, void 0), __privateSet$5(this, _client2$4, client);\n  }\n  /**\n   * Clones the transaction\n   */\n  clone() {\n    return new _ObservableTransaction2([...this.operations], __privateGet$5(this, _client2$4), this.trxId);\n  }\n  commit(options) {\n    if (!__privateGet$5(this, _client2$4))\n      throw new Error(\n        \"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\"\n      );\n    return __privateGet$5(this, _client2$4).mutate(\n      this.serialize(),\n      Object.assign({ transactionId: this.trxId }, defaultMutateOptions, options || {})\n    );\n  }\n  patch(patchOrDocumentId, patchOps) {\n    const isBuilder = typeof patchOps == \"function\";\n    if (typeof patchOrDocumentId != \"string\" && patchOrDocumentId instanceof ObservablePatch)\n      return this._add({ patch: patchOrDocumentId.serialize() });\n    if (isBuilder) {\n      const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, __privateGet$5(this, _client2$4)));\n      if (!(patch instanceof ObservablePatch))\n        throw new Error(\"function passed to `patch()` must return the patch\");\n      return this._add({ patch: patch.serialize() });\n    }\n    return this._add({ patch: { id: patchOrDocumentId, ...patchOps } });\n  }\n};\n_client2$4 = /* @__PURE__ */ new WeakMap();\nlet ObservableTransaction = _ObservableTransaction;\nconst BASE_URL = \"https://www.sanity.io/help/\";\nfunction generateHelpUrl(slug) {\n  return BASE_URL + slug;\n}\nfunction once(fn) {\n  let didCall = !1, returnValue;\n  return (...args) => (didCall || (returnValue = fn(...args), didCall = !0), returnValue);\n}\nconst createWarningPrinter = (message) => (\n  // eslint-disable-next-line no-console\n  once((...args) => console.warn(message.join(\" \"), ...args))\n), printCdnWarning = createWarningPrinter([\n  \"Since you haven't set a value for `useCdn`, we will deliver content using our\",\n  \"global, edge-cached API-CDN. If you wish to have content delivered faster, set\",\n  \"`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API.\"\n]), printCdnPreviewDraftsWarning = createWarningPrinter([\n  \"The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.\",\n  \"The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning.\"\n]), printBrowserTokenWarning = createWarningPrinter([\n  \"You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.\",\n  `See ${generateHelpUrl(\n    \"js-client-browser-token\"\n  )} for more information and how to hide this warning.`\n]), printNoApiVersionSpecifiedWarning = createWarningPrinter([\n  \"Using the Sanity client without specifying an API version is deprecated.\",\n  `See ${generateHelpUrl(\"js-client-api-version\")}`\n]), printNoDefaultExport = createWarningPrinter([\n  \"The default export of @sanity/client has been deprecated. Use the named export `createClient` instead.\"\n]), defaultCdnHost = \"apicdn.sanity.io\", defaultConfig = {\n  apiHost: \"https://api.sanity.io\",\n  apiVersion: \"1\",\n  useProjectHostname: !0,\n  stega: { enabled: !1 }\n}, LOCALHOSTS = [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"], isLocal = (host) => LOCALHOSTS.indexOf(host) !== -1;\nfunction validateApiVersion(apiVersion) {\n  if (apiVersion === \"1\" || apiVersion === \"X\")\n    return;\n  const apiDate = new Date(apiVersion);\n  if (!(/^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0))\n    throw new Error(\"Invalid API version string, expected `1` or date in format `YYYY-MM-DD`\");\n}\nconst validateApiPerspective = function(perspective) {\n  switch (perspective) {\n    case \"previewDrafts\":\n    case \"published\":\n    case \"raw\":\n      return;\n    default:\n      throw new TypeError(\n        \"Invalid API perspective string, expected `published`, `previewDrafts` or `raw`\"\n      );\n  }\n}, initConfig = (config, prevConfig) => {\n  const specifiedConfig = {\n    ...prevConfig,\n    ...config,\n    stega: {\n      ...typeof prevConfig.stega == \"boolean\" ? { enabled: prevConfig.stega } : prevConfig.stega || defaultConfig.stega,\n      ...typeof config.stega == \"boolean\" ? { enabled: config.stega } : config.stega || {}\n    }\n  };\n  specifiedConfig.apiVersion || printNoApiVersionSpecifiedWarning();\n  const newConfig = {\n    ...defaultConfig,\n    ...specifiedConfig\n  }, projectBased = newConfig.useProjectHostname;\n  if (typeof Promise > \"u\") {\n    const helpUrl = generateHelpUrl(\"js-client-promise-polyfill\");\n    throw new Error(`No native Promise-implementation found, polyfill needed - see ${helpUrl}`);\n  }\n  if (projectBased && !newConfig.projectId)\n    throw new Error(\"Configuration must contain `projectId`\");\n  if (typeof newConfig.perspective == \"string\" && validateApiPerspective(newConfig.perspective), \"encodeSourceMap\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMap' is not supported in '@sanity/client'. Did you mean 'stega.enabled'?\"\n    );\n  if (\"encodeSourceMapAtPath\" in newConfig)\n    throw new Error(\n      \"It looks like you're using options meant for '@sanity/preview-kit/client'. 'encodeSourceMapAtPath' is not supported in '@sanity/client'. Did you mean 'stega.filter'?\"\n    );\n  if (typeof newConfig.stega.enabled != \"boolean\")\n    throw new Error(`stega.enabled must be a boolean, received ${newConfig.stega.enabled}`);\n  if (newConfig.stega.enabled && newConfig.stega.studioUrl === void 0)\n    throw new Error(\"stega.studioUrl must be defined when stega.enabled is true\");\n  if (newConfig.stega.enabled && typeof newConfig.stega.studioUrl != \"string\" && typeof newConfig.stega.studioUrl != \"function\")\n    throw new Error(\n      `stega.studioUrl must be a string or a function, received ${newConfig.stega.studioUrl}`\n    );\n  const isBrowser = typeof window < \"u\" && window.location && window.location.hostname, isLocalhost = isBrowser && isLocal(window.location.hostname);\n  isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== !0 ? printBrowserTokenWarning() : typeof newConfig.useCdn > \"u\" && printCdnWarning(), projectBased && projectId(newConfig.projectId), newConfig.dataset && dataset(newConfig.dataset), \"requestTagPrefix\" in newConfig && (newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, \"\") : void 0), newConfig.apiVersion = `${newConfig.apiVersion}`.replace(/^v/, \"\"), newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost, newConfig.useCdn = newConfig.useCdn !== !1 && !newConfig.withCredentials, validateApiVersion(newConfig.apiVersion);\n  const hostParts = newConfig.apiHost.split(\"://\", 2), protocol = hostParts[0], host = hostParts[1], cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;\n  return newConfig.useProjectHostname ? (newConfig.url = `${protocol}://${newConfig.projectId}.${host}/v${newConfig.apiVersion}`, newConfig.cdnUrl = `${protocol}://${newConfig.projectId}.${cdnHost}/v${newConfig.apiVersion}`) : (newConfig.url = `${newConfig.apiHost}/v${newConfig.apiVersion}`, newConfig.cdnUrl = newConfig.url), newConfig;\n}, projectHeader = \"X-Sanity-Project-ID\";\nfunction requestOptions(config, overrides = {}) {\n  const headers2 = {}, token = overrides.token || config.token;\n  token && (headers2.Authorization = `Bearer ${token}`), !overrides.useGlobalApi && !config.useProjectHostname && config.projectId && (headers2[projectHeader] = config.projectId);\n  const withCredentials = !!(typeof overrides.withCredentials > \"u\" ? config.token || config.withCredentials : overrides.withCredentials), timeout = typeof overrides.timeout > \"u\" ? config.timeout : overrides.timeout;\n  return Object.assign({}, overrides, {\n    headers: Object.assign({}, headers2, overrides.headers || {}),\n    timeout: typeof timeout > \"u\" ? 5 * 60 * 1e3 : timeout,\n    proxy: overrides.proxy || config.proxy,\n    json: !0,\n    withCredentials,\n    fetch: typeof overrides.fetch == \"object\" && typeof config.fetch == \"object\" ? { ...config.fetch, ...overrides.fetch } : overrides.fetch || config.fetch\n  });\n}\nconst encodeQueryString = ({\n  query,\n  params = {},\n  options = {}\n}) => {\n  const searchParams = new URLSearchParams(), { tag, returnQuery, ...opts } = options;\n  tag && searchParams.append(\"tag\", tag), searchParams.append(\"query\", query);\n  for (const [key, value] of Object.entries(params))\n    searchParams.append(`$${key}`, JSON.stringify(value));\n  for (const [key, value] of Object.entries(opts))\n    value && searchParams.append(key, `${value}`);\n  return returnQuery === !1 && searchParams.append(\"returnQuery\", \"false\"), `?${searchParams}`;\n}, excludeFalsey = (param, defValue) => param === !1 ? void 0 : typeof param > \"u\" ? defValue : param, getMutationQuery = (options = {}) => ({\n  dryRun: options.dryRun,\n  returnIds: !0,\n  returnDocuments: excludeFalsey(options.returnDocuments, !0),\n  visibility: options.visibility || \"sync\",\n  autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n  skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation\n}), isResponse = (event) => event.type === \"response\", getBody = (event) => event.body, indexBy = (docs, attr) => docs.reduce((indexed, doc) => (indexed[attr(doc)] = doc, indexed), /* @__PURE__ */ Object.create(null)), getQuerySizeLimit = 11264;\nfunction _fetch(client, httpRequest, _stega, query, _params = {}, options = {}) {\n  const stega = \"stega\" in options ? {\n    ..._stega || {},\n    ...typeof options.stega == \"boolean\" ? { enabled: options.stega } : options.stega || {}\n  } : _stega, params = stega.enabled ? (0,_chunks_es_vercelStegaCleanAll_js__WEBPACK_IMPORTED_MODULE_3__.v)(_params) : _params, mapResponse = options.filterResponse === !1 ? (res) => res : (res) => res.result, { cache, next, ...opts } = {\n    // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.\n    // This is necessary in React Server Components to avoid opting out of Request Memoization.\n    useAbortSignal: typeof options.signal < \"u\",\n    // Set `resultSourceMap' when stega is enabled, as it's required for encoding.\n    resultSourceMap: stega.enabled ? \"withKeyArraySelector\" : options.resultSourceMap,\n    ...options,\n    // Default to not returning the query, unless `filterResponse` is `false`,\n    // or `returnQuery` is explicitly set. `true` is the default in Content Lake, so skip if truthy\n    returnQuery: options.filterResponse === !1 && options.returnQuery !== !1\n  }, reqOpts = typeof cache < \"u\" || typeof next < \"u\" ? { ...opts, fetch: { cache, next } } : opts, $request = _dataRequest(client, httpRequest, \"query\", { query, params }, reqOpts);\n  return stega.enabled ? $request.pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.combineLatestWith)(\n      (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.from)(\n        __webpack_require__.e(/*! import() */ \"vendor-chunks/@sanity\").then(__webpack_require__.bind(__webpack_require__, /*! ./_chunks-es/stegaEncodeSourceMap.js */ \"(ssr)/./node_modules/@sanity/client/dist/_chunks-es/stegaEncodeSourceMap.js\")).then(function(n) {\n          return n.a;\n        }).then(\n          ({ stegaEncodeSourceMap }) => stegaEncodeSourceMap\n        )\n      )\n    ),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n      ([res, stegaEncodeSourceMap]) => {\n        const result = stegaEncodeSourceMap(res.result, res.resultSourceMap, stega);\n        return mapResponse({ ...res, result });\n      }\n    )\n  ) : $request.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(mapResponse));\n}\nfunction _getDocument(client, httpRequest, id, opts = {}) {\n  const options = { uri: _getDataUrl(client, \"doc\", id), json: !0, tag: opts.tag };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body.documents && event.body.documents[0])\n  );\n}\nfunction _getDocuments(client, httpRequest, ids, opts = {}) {\n  const options = { uri: _getDataUrl(client, \"doc\", ids.join(\",\")), json: !0, tag: opts.tag };\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => {\n      const indexed = indexBy(event.body.documents || [], (doc) => doc._id);\n      return ids.map((id) => indexed[id] || null);\n    })\n  );\n}\nfunction _createIfNotExists(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createIfNotExists\", doc), _create(client, httpRequest, doc, \"createIfNotExists\", options);\n}\nfunction _createOrReplace(client, httpRequest, doc, options) {\n  return requireDocumentId(\"createOrReplace\", doc), _create(client, httpRequest, doc, \"createOrReplace\", options);\n}\nfunction _delete(client, httpRequest, selection, options) {\n  return _dataRequest(\n    client,\n    httpRequest,\n    \"mutate\",\n    { mutations: [{ delete: getSelection(selection) }] },\n    options\n  );\n}\nfunction _mutate(client, httpRequest, mutations, options) {\n  let mut;\n  mutations instanceof Patch || mutations instanceof ObservablePatch ? mut = { patch: mutations.serialize() } : mutations instanceof Transaction || mutations instanceof ObservableTransaction ? mut = mutations.serialize() : mut = mutations;\n  const muts = Array.isArray(mut) ? mut : [mut], transactionId = options && options.transactionId || void 0;\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: muts, transactionId }, options);\n}\nfunction _dataRequest(client, httpRequest, endpoint, body, options = {}) {\n  const isMutation = endpoint === \"mutate\", isQuery = endpoint === \"query\", strQuery = isMutation ? \"\" : encodeQueryString(body), useGet = !isMutation && strQuery.length < getQuerySizeLimit, stringQuery = useGet ? strQuery : \"\", returnFirst = options.returnFirst, { timeout, token, tag, headers: headers2, returnQuery } = options, uri = _getDataUrl(client, endpoint, stringQuery), reqOptions = {\n    method: useGet ? \"GET\" : \"POST\",\n    uri,\n    json: !0,\n    body: useGet ? void 0 : body,\n    query: isMutation && getMutationQuery(options),\n    timeout,\n    headers: headers2,\n    token,\n    tag,\n    returnQuery,\n    perspective: options.perspective,\n    resultSourceMap: options.resultSourceMap,\n    canUseCdn: isQuery,\n    signal: options.signal,\n    fetch: options.fetch,\n    useAbortSignal: options.useAbortSignal,\n    useCdn: options.useCdn\n  };\n  return _requestObservable(client, httpRequest, reqOptions).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(isResponse),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(getBody),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((res) => {\n      if (!isMutation)\n        return res;\n      const results = res.results || [];\n      if (options.returnDocuments)\n        return returnFirst ? results[0] && results[0].document : results.map((mut) => mut.document);\n      const key = returnFirst ? \"documentId\" : \"documentIds\", ids = returnFirst ? results[0] && results[0].id : results.map((mut) => mut.id);\n      return {\n        transactionId: res.transactionId,\n        results,\n        [key]: ids\n      };\n    })\n  );\n}\nfunction _create(client, httpRequest, doc, op, options = {}) {\n  const mutation = { [op]: doc }, opts = Object.assign({ returnFirst: !0, returnDocuments: !0 }, options);\n  return _dataRequest(client, httpRequest, \"mutate\", { mutations: [mutation] }, opts);\n}\nfunction _requestObservable(client, httpRequest, options) {\n  var _a, _b;\n  const uri = options.url || options.uri, config = client.config(), canUseCdn = typeof options.canUseCdn > \"u\" ? [\"GET\", \"HEAD\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/\") === 0 : options.canUseCdn;\n  let useCdn = ((_a = options.useCdn) != null ? _a : config.useCdn) && canUseCdn;\n  const tag = options.tag && config.requestTagPrefix ? [config.requestTagPrefix, options.tag].join(\".\") : options.tag || config.requestTagPrefix;\n  if (tag && options.tag !== null && (options.query = { tag: requestTag(tag), ...options.query }), [\"GET\", \"HEAD\", \"POST\"].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/query/\") === 0) {\n    const resultSourceMap = (_b = options.resultSourceMap) != null ? _b : config.resultSourceMap;\n    resultSourceMap !== void 0 && resultSourceMap !== !1 && (options.query = { resultSourceMap, ...options.query });\n    const perspective = options.perspective || config.perspective;\n    typeof perspective == \"string\" && perspective !== \"raw\" && (validateApiPerspective(perspective), options.query = { perspective, ...options.query }, perspective === \"previewDrafts\" && useCdn && (useCdn = !1, printCdnPreviewDraftsWarning())), options.returnQuery === !1 && (options.query = { returnQuery: \"false\", ...options.query });\n  }\n  const reqOptions = requestOptions(\n    config,\n    Object.assign({}, options, {\n      url: _getUrl(client, uri, useCdn)\n    })\n  ), request = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable(\n    (subscriber) => httpRequest(reqOptions, config.requester).subscribe(subscriber)\n  );\n  return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;\n}\nfunction _request(client, httpRequest, options) {\n  return _requestObservable(client, httpRequest, options).pipe(\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n    (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)((event) => event.body)\n  );\n}\nfunction _getDataUrl(client, operation, path) {\n  const config = client.config(), catalog = hasDataset(config), baseUri = `/${operation}/${catalog}`;\n  return `/data${path ? `${baseUri}/${path}` : baseUri}`.replace(/\\/($|\\?)/, \"$1\");\n}\nfunction _getUrl(client, uri, canUseCdn = !1) {\n  const { url, cdnUrl } = client.config();\n  return `${canUseCdn ? cdnUrl : url}/${uri.replace(/^\\//, \"\")}`;\n}\nfunction _withAbortSignal(signal) {\n  return (input) => new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    const abort = () => observer.error(_createAbortError(signal));\n    if (signal && signal.aborted) {\n      abort();\n      return;\n    }\n    const subscription = input.subscribe(observer);\n    return signal.addEventListener(\"abort\", abort), () => {\n      signal.removeEventListener(\"abort\", abort), subscription.unsubscribe();\n    };\n  });\n}\nconst isDomExceptionSupported = !!globalThis.DOMException;\nfunction _createAbortError(signal) {\n  var _a, _b;\n  if (isDomExceptionSupported)\n    return new DOMException((_a = signal == null ? void 0 : signal.reason) != null ? _a : \"The operation was aborted.\", \"AbortError\");\n  const error = new Error((_b = signal == null ? void 0 : signal.reason) != null ? _b : \"The operation was aborted.\");\n  return error.name = \"AbortError\", error;\n}\nvar __accessCheck$4 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n}, __privateGet$4 = (obj, member, getter) => (__accessCheck$4(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd$4 = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n}, __privateSet$4 = (obj, member, value, setter) => (__accessCheck$4(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value), _client$3, _httpRequest$4;\nclass ObservableAssetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$4(this, _client$3, void 0), __privateAdd$4(this, _httpRequest$4, void 0), __privateSet$4(this, _client$3, client), __privateSet$4(this, _httpRequest$4, httpRequest);\n  }\n  upload(assetType, body, options) {\n    return _upload(__privateGet$4(this, _client$3), __privateGet$4(this, _httpRequest$4), assetType, body, options);\n  }\n}\n_client$3 = /* @__PURE__ */ new WeakMap(), _httpRequest$4 = /* @__PURE__ */ new WeakMap();\nvar _client2$3, _httpRequest2$4;\nclass AssetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$4(this, _client2$3, void 0), __privateAdd$4(this, _httpRequest2$4, void 0), __privateSet$4(this, _client2$3, client), __privateSet$4(this, _httpRequest2$4, httpRequest);\n  }\n  upload(assetType, body, options) {\n    const observable2 = _upload(__privateGet$4(this, _client2$3), __privateGet$4(this, _httpRequest2$4), assetType, body, options);\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      observable2.pipe(\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)((event) => event.type === \"response\"),\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.map)(\n          (event) => event.body.document\n        )\n      )\n    );\n  }\n}\n_client2$3 = /* @__PURE__ */ new WeakMap(), _httpRequest2$4 = /* @__PURE__ */ new WeakMap();\nfunction _upload(client, httpRequest, assetType, body, opts = {}) {\n  validateAssetType(assetType);\n  let meta = opts.extract || void 0;\n  meta && !meta.length && (meta = [\"none\"]);\n  const dataset2 = hasDataset(client.config()), assetEndpoint = assetType === \"image\" ? \"images\" : \"files\", options = optionsFromFile(opts, body), { tag, label, title, description, creditLine, filename, source } = options, query = {\n    label,\n    title,\n    description,\n    filename,\n    meta,\n    creditLine\n  };\n  return source && (query.sourceId = source.id, query.sourceName = source.name, query.sourceUrl = source.url), _requestObservable(client, httpRequest, {\n    tag,\n    method: \"POST\",\n    timeout: options.timeout || 0,\n    uri: `/assets/${assetEndpoint}/${dataset2}`,\n    headers: options.contentType ? { \"Content-Type\": options.contentType } : {},\n    query,\n    body\n  });\n}\nfunction optionsFromFile(opts, file) {\n  return typeof File > \"u\" || !(file instanceof File) ? opts : Object.assign(\n    {\n      filename: opts.preserveFilename === !1 ? void 0 : file.name,\n      contentType: file.type\n    },\n    opts\n  );\n}\nvar defaults = (obj, defaults2) => Object.keys(defaults2).concat(Object.keys(obj)).reduce((target, prop) => (target[prop] = typeof obj[prop] > \"u\" ? defaults2[prop] : obj[prop], target), {});\nconst pick = (obj, props) => props.reduce((selection, prop) => (typeof obj[prop] > \"u\" || (selection[prop] = obj[prop]), selection), {}), MAX_URL_LENGTH = 14800, possibleOptions = [\n  \"includePreviousRevision\",\n  \"includeResult\",\n  \"visibility\",\n  \"effectFormat\",\n  \"tag\"\n], defaultOptions = {\n  includeResult: !0\n};\nfunction _listen(query, params, opts = {}) {\n  const { url, token, withCredentials, requestTagPrefix } = this.config(), tag = opts.tag && requestTagPrefix ? [requestTagPrefix, opts.tag].join(\".\") : opts.tag, options = { ...defaults(opts, defaultOptions), tag }, listenOpts = pick(options, possibleOptions), qs = encodeQueryString({ query, params, options: { tag, ...listenOpts } }), uri = `${url}${_getDataUrl(this, \"listen\", qs)}`;\n  if (uri.length > MAX_URL_LENGTH)\n    return new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => observer.error(new Error(\"Query too large for listener\")));\n  const listenFor = options.events ? options.events : [\"mutation\"], shouldEmitReconnect = listenFor.indexOf(\"reconnect\") !== -1, esOptions = {};\n  return (token || withCredentials) && (esOptions.withCredentials = !0), token && (esOptions.headers = {\n    Authorization: `Bearer ${token}`\n  }), new rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer) => {\n    let es;\n    getEventSource().then((eventSource) => {\n      es = eventSource;\n    }).catch((reason) => {\n      observer.error(reason), stop();\n    });\n    let reconnectTimer, stopped = !1;\n    function onError() {\n      stopped || (emitReconnect(), !stopped && es.readyState === es.CLOSED && (unsubscribe(), clearTimeout(reconnectTimer), reconnectTimer = setTimeout(open, 100)));\n    }\n    function onChannelError(err) {\n      observer.error(cooerceError(err));\n    }\n    function onMessage(evt) {\n      const event = parseEvent(evt);\n      return event instanceof Error ? observer.error(event) : observer.next(event);\n    }\n    function onDisconnect() {\n      stopped = !0, unsubscribe(), observer.complete();\n    }\n    function unsubscribe() {\n      es && (es.removeEventListener(\"error\", onError), es.removeEventListener(\"channelError\", onChannelError), es.removeEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => es.removeEventListener(type, onMessage)), es.close());\n    }\n    function emitReconnect() {\n      shouldEmitReconnect && observer.next({ type: \"reconnect\" });\n    }\n    async function getEventSource() {\n      const { default: EventSource } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(ssr)/./node_modules/@sanity/eventsource/node.js\", 19)), evs = new EventSource(uri, esOptions);\n      return evs.addEventListener(\"error\", onError), evs.addEventListener(\"channelError\", onChannelError), evs.addEventListener(\"disconnect\", onDisconnect), listenFor.forEach((type) => evs.addEventListener(type, onMessage)), evs;\n    }\n    function open() {\n      getEventSource().then((eventSource) => {\n        es = eventSource;\n      }).catch((reason) => {\n        observer.error(reason), stop();\n      });\n    }\n    function stop() {\n      stopped = !0, unsubscribe();\n    }\n    return stop;\n  });\n}\nfunction parseEvent(event) {\n  try {\n    const data = event.data && JSON.parse(event.data) || {};\n    return Object.assign({ type: event.type }, data);\n  } catch (err) {\n    return err;\n  }\n}\nfunction cooerceError(err) {\n  if (err instanceof Error)\n    return err;\n  const evt = parseEvent(err);\n  return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\nfunction extractErrorMessage(err) {\n  return err.error ? err.error.description ? err.error.description : typeof err.error == \"string\" ? err.error : JSON.stringify(err.error, null, 2) : err.message || \"Unknown listener error\";\n}\nvar __accessCheck$3 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n}, __privateGet$3 = (obj, member, getter) => (__accessCheck$3(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd$3 = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n}, __privateSet$3 = (obj, member, value, setter) => (__accessCheck$3(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value), _client$2, _httpRequest$3;\nclass ObservableDatasetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$3(this, _client$2, void 0), __privateAdd$3(this, _httpRequest$3, void 0), __privateSet$3(this, _client$2, client), __privateSet$3(this, _httpRequest$3, httpRequest);\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name2, options) {\n    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"PUT\", name2, options);\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name2, options) {\n    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"PATCH\", name2, options);\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name2) {\n    return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"DELETE\", name2);\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return _request(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), {\n      uri: \"/datasets\",\n      tag: null\n    });\n  }\n}\n_client$2 = /* @__PURE__ */ new WeakMap(), _httpRequest$3 = /* @__PURE__ */ new WeakMap();\nvar _client2$2, _httpRequest2$3;\nclass DatasetsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$3(this, _client2$2, void 0), __privateAdd$3(this, _httpRequest2$3, void 0), __privateSet$3(this, _client2$2, client), __privateSet$3(this, _httpRequest2$3, httpRequest);\n  }\n  /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */\n  create(name2, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"PUT\", name2, options)\n    );\n  }\n  /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */\n  edit(name2, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"PATCH\", name2, options)\n    );\n  }\n  /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */\n  delete(name2) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"DELETE\", name2));\n  }\n  /**\n   * Fetch a list of datasets for the configured project\n   */\n  list() {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), { uri: \"/datasets\", tag: null })\n    );\n  }\n}\n_client2$2 = /* @__PURE__ */ new WeakMap(), _httpRequest2$3 = /* @__PURE__ */ new WeakMap();\nfunction _modify(client, httpRequest, method, name2, options) {\n  return dataset(name2), _request(client, httpRequest, {\n    method,\n    uri: `/datasets/${name2}`,\n    body: options,\n    tag: null\n  });\n}\nvar __accessCheck$2 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n}, __privateGet$2 = (obj, member, getter) => (__accessCheck$2(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd$2 = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n}, __privateSet$2 = (obj, member, value, setter) => (__accessCheck$2(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value), _client$1, _httpRequest$2;\nclass ObservableProjectsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$2(this, _client$1, void 0), __privateAdd$2(this, _httpRequest$2, void 0), __privateSet$2(this, _client$1, client), __privateSet$2(this, _httpRequest$2, httpRequest);\n  }\n  list(options) {\n    const uri = (options == null ? void 0 : options.includeMembers) === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), { uri });\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), { uri: `/projects/${projectId2}` });\n  }\n}\n_client$1 = /* @__PURE__ */ new WeakMap(), _httpRequest$2 = /* @__PURE__ */ new WeakMap();\nvar _client2$1, _httpRequest2$2;\nclass ProjectsClient {\n  constructor(client, httpRequest) {\n    __privateAdd$2(this, _client2$1, void 0), __privateAdd$2(this, _httpRequest2$2, void 0), __privateSet$2(this, _client2$1, client), __privateSet$2(this, _httpRequest2$2, httpRequest);\n  }\n  list(options) {\n    const uri = (options == null ? void 0 : options.includeMembers) === !1 ? \"/projects?includeMembers=false\" : \"/projects\";\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), { uri }));\n  }\n  /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */\n  getById(projectId2) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), { uri: `/projects/${projectId2}` })\n    );\n  }\n}\n_client2$1 = /* @__PURE__ */ new WeakMap(), _httpRequest2$2 = /* @__PURE__ */ new WeakMap();\nvar __accessCheck$1 = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n}, __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd$1 = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n}, __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value), _client, _httpRequest$1;\nclass ObservableUsersClient {\n  constructor(client, httpRequest) {\n    __privateAdd$1(this, _client, void 0), __privateAdd$1(this, _httpRequest$1, void 0), __privateSet$1(this, _client, client), __privateSet$1(this, _httpRequest$1, httpRequest);\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return _request(\n      __privateGet$1(this, _client),\n      __privateGet$1(this, _httpRequest$1),\n      { uri: `/users/${id}` }\n    );\n  }\n}\n_client = /* @__PURE__ */ new WeakMap(), _httpRequest$1 = /* @__PURE__ */ new WeakMap();\nvar _client2, _httpRequest2$1;\nclass UsersClient {\n  constructor(client, httpRequest) {\n    __privateAdd$1(this, _client2, void 0), __privateAdd$1(this, _httpRequest2$1, void 0), __privateSet$1(this, _client2, client), __privateSet$1(this, _httpRequest2$1, httpRequest);\n  }\n  /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */\n  getById(id) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _request(__privateGet$1(this, _client2), __privateGet$1(this, _httpRequest2$1), {\n        uri: `/users/${id}`\n      })\n    );\n  }\n}\n_client2 = /* @__PURE__ */ new WeakMap(), _httpRequest2$1 = /* @__PURE__ */ new WeakMap();\nvar __defProp = Object.defineProperty, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value, __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value), __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n}, __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)), __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n}, __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value), _clientConfig, _httpRequest;\nconst _ObservableSanityClient = class _ObservableSanityClient2 {\n  constructor(httpRequest, config = defaultConfig) {\n    __publicField(this, \"assets\"), __publicField(this, \"datasets\"), __publicField(this, \"projects\"), __publicField(this, \"users\"), __privateAdd(this, _clientConfig, void 0), __privateAdd(this, _httpRequest, void 0), __publicField(this, \"listen\", _listen), this.config(config), __privateSet(this, _httpRequest, httpRequest), this.assets = new ObservableAssetsClient(this, __privateGet(this, _httpRequest)), this.datasets = new ObservableDatasetsClient(this, __privateGet(this, _httpRequest)), this.projects = new ObservableProjectsClient(this, __privateGet(this, _httpRequest)), this.users = new ObservableUsersClient(this, __privateGet(this, _httpRequest));\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new _ObservableSanityClient2(__privateGet(this, _httpRequest), this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...__privateGet(this, _clientConfig) };\n    if (__privateGet(this, _clientConfig) && __privateGet(this, _clientConfig).allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return __privateSet(this, _clientConfig, initConfig(newConfig, __privateGet(this, _clientConfig) || {})), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new _ObservableSanityClient2(__privateGet(this, _httpRequest), {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof (newConfig == null ? void 0 : newConfig.stega) == \"boolean\" ? { enabled: newConfig.stega } : (newConfig == null ? void 0 : newConfig.stega) || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return _fetch(\n      this,\n      __privateGet(this, _httpRequest),\n      __privateGet(this, _clientConfig).stega,\n      query,\n      params,\n      options\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return _getDocument(this, __privateGet(this, _httpRequest), id, options);\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return _getDocuments(this, __privateGet(this, _httpRequest), ids, options);\n  }\n  create(document, options) {\n    return _create(this, __privateGet(this, _httpRequest), document, \"create\", options);\n  }\n  createIfNotExists(document, options) {\n    return _createIfNotExists(this, __privateGet(this, _httpRequest), document, options);\n  }\n  createOrReplace(document, options) {\n    return _createOrReplace(this, __privateGet(this, _httpRequest), document, options);\n  }\n  delete(selection, options) {\n    return _delete(this, __privateGet(this, _httpRequest), selection, options);\n  }\n  mutate(operations, options) {\n    return _mutate(this, __privateGet(this, _httpRequest), operations, options);\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(selection, operations) {\n    return new ObservablePatch(selection, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new ObservableTransaction(operations, this);\n  }\n  /**\n   * Perform an HTTP request against the Sanity API\n   *\n   * @param options - Request options\n   */\n  request(options) {\n    return _request(this, __privateGet(this, _httpRequest), options);\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n};\n_clientConfig = /* @__PURE__ */ new WeakMap(), _httpRequest = /* @__PURE__ */ new WeakMap();\nlet ObservableSanityClient = _ObservableSanityClient;\nvar _clientConfig2, _httpRequest2;\nconst _SanityClient = class _SanityClient2 {\n  constructor(httpRequest, config = defaultConfig) {\n    __publicField(this, \"assets\"), __publicField(this, \"datasets\"), __publicField(this, \"projects\"), __publicField(this, \"users\"), __publicField(this, \"observable\"), __privateAdd(this, _clientConfig2, void 0), __privateAdd(this, _httpRequest2, void 0), __publicField(this, \"listen\", _listen), this.config(config), __privateSet(this, _httpRequest2, httpRequest), this.assets = new AssetsClient(this, __privateGet(this, _httpRequest2)), this.datasets = new DatasetsClient(this, __privateGet(this, _httpRequest2)), this.projects = new ProjectsClient(this, __privateGet(this, _httpRequest2)), this.users = new UsersClient(this, __privateGet(this, _httpRequest2)), this.observable = new ObservableSanityClient(httpRequest, config);\n  }\n  /**\n   * Clone the client - returns a new instance\n   */\n  clone() {\n    return new _SanityClient2(__privateGet(this, _httpRequest2), this.config());\n  }\n  config(newConfig) {\n    if (newConfig === void 0)\n      return { ...__privateGet(this, _clientConfig2) };\n    if (__privateGet(this, _clientConfig2) && __privateGet(this, _clientConfig2).allowReconfigure === !1)\n      throw new Error(\n        \"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\"\n      );\n    return this.observable && this.observable.config(newConfig), __privateSet(this, _clientConfig2, initConfig(newConfig, __privateGet(this, _clientConfig2) || {})), this;\n  }\n  /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */\n  withConfig(newConfig) {\n    const thisConfig = this.config();\n    return new _SanityClient2(__privateGet(this, _httpRequest2), {\n      ...thisConfig,\n      ...newConfig,\n      stega: {\n        ...thisConfig.stega || {},\n        ...typeof (newConfig == null ? void 0 : newConfig.stega) == \"boolean\" ? { enabled: newConfig.stega } : (newConfig == null ? void 0 : newConfig.stega) || {}\n      }\n    });\n  }\n  fetch(query, params, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _fetch(\n        this,\n        __privateGet(this, _httpRequest2),\n        __privateGet(this, _clientConfig2).stega,\n        query,\n        params,\n        options\n      )\n    );\n  }\n  /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */\n  getDocument(id, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocument(this, __privateGet(this, _httpRequest2), id, options));\n  }\n  /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */\n  getDocuments(ids, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_getDocuments(this, __privateGet(this, _httpRequest2), ids, options));\n  }\n  create(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _create(this, __privateGet(this, _httpRequest2), document, \"create\", options)\n    );\n  }\n  createIfNotExists(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createIfNotExists(this, __privateGet(this, _httpRequest2), document, options)\n    );\n  }\n  createOrReplace(document, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(\n      _createOrReplace(this, __privateGet(this, _httpRequest2), document, options)\n    );\n  }\n  delete(selection, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_delete(this, __privateGet(this, _httpRequest2), selection, options));\n  }\n  mutate(operations, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_mutate(this, __privateGet(this, _httpRequest2), operations, options));\n  }\n  /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */\n  patch(documentId, operations) {\n    return new Patch(documentId, operations, this);\n  }\n  /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */\n  transaction(operations) {\n    return new Transaction(operations, this);\n  }\n  /**\n   * Perform a request against the Sanity API\n   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!\n   *\n   * @param options - Request options\n   * @returns Promise resolving to the response body\n   */\n  request(options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_request(this, __privateGet(this, _httpRequest2), options));\n  }\n  /**\n   * Perform an HTTP request a `/data` sub-endpoint\n   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.\n   *\n   * @deprecated - Use `request()` or your own HTTP library instead\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   * @internal\n   */\n  dataRequest(endpoint, body, options) {\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.lastValueFrom)(_dataRequest(this, __privateGet(this, _httpRequest2), endpoint, body, options));\n  }\n  /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */\n  getUrl(uri, canUseCdn) {\n    return _getUrl(this, uri, canUseCdn);\n  }\n  /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */\n  getDataUrl(operation, path) {\n    return _getDataUrl(this, operation, path);\n  }\n};\n_clientConfig2 = /* @__PURE__ */ new WeakMap(), _httpRequest2 = /* @__PURE__ */ new WeakMap();\nlet SanityClient = _SanityClient;\nfunction defineCreateClientExports(envMiddleware, ClassConstructor) {\n  const defaultRequester = defineHttpRequest(envMiddleware);\n  return { requester: defaultRequester, createClient: (config) => new ClassConstructor(\n    (options, requester2) => (requester2 || defaultRequester)({\n      maxRedirects: 0,\n      maxRetries: config.maxRetries,\n      retryDelay: config.retryDelay,\n      ...options\n    }),\n    config\n  ) };\n}\nfunction defineDeprecatedCreateClient(createClient2) {\n  return function(config) {\n    return printNoDefaultExport(), createClient2(config);\n  };\n}\nvar name = \"@sanity/client\", version = \"6.15.19\";\nconst middleware = [\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.debug)({ verbose: !0, namespace: \"sanity:client\" }),\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.headers)({ \"User-Agent\": `${name} ${version}` }),\n  // Enable keep-alive, and in addition limit the number of sockets that can be opened.\n  // This avoids opening too many connections to the server if someone tries to execute\n  // a bunch of requests in parallel. It's recommended to have a concurrency limit\n  // at a \"higher limit\" (i.e. you shouldn't actually execute hundreds of requests in parallel),\n  // and this is mainly to minimize the impact for the network and server.\n  //\n  // We're currently matching the same defaults as browsers:\n  // https://stackoverflow.com/questions/26003756/is-there-a-limit-practical-or-otherwise-to-the-number-of-web-sockets-a-page-op\n  (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.agent)({\n    keepAlive: !0,\n    maxSockets: 30,\n    maxTotalSockets: 256\n  })\n], exp = defineCreateClientExports(middleware, SanityClient), requester = exp.requester, createClient = exp.createClient, deprecatedCreateClient = defineDeprecatedCreateClient(createClient);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ2U7QUFDb0U7QUFDM0Q7QUFDUztBQUNlO0FBQy9FLHVIQUF1SCx1REFBdUQ7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVksSUFBSSxhQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKLEtBQUs7QUFDTDtBQUNBLFNBQVMscUJBQXFCLDJCQUEyQix1QkFBdUIsRUFBRSxTQUFTO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRSxZQUFZLFdBQVcsY0FBYyxTQUFTLG1CQUFtQixlQUFlLEVBQUUsY0FBYztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2Q0FBSztBQUNkLElBQUksd0RBQUssR0FBRyxhQUFhO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLDhEQUFXO0FBQ2YsSUFBSSwrREFBWTtBQUNoQixJQUFJLDJEQUFRO0FBQ1o7QUFDQSxJQUFJLDZEQUFVLEdBQUcsZ0JBQWdCLDRDQUFVLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG9EQUFLO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0EsdUZBQXVGLHVDQUF1QyxJQUFJO0FBQ2xJO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtREFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1EQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3REFBSyxHQUFHLHlDQUF5QztBQUNuRCxFQUFFLDBEQUFPLEdBQUcsaUJBQWlCLE1BQU0sRUFBRSxRQUFRLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0RBQUs7QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFpQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nob3BpbmdfYXBwLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvY2xpZW50L2Rpc3QvaW5kZXguanM/ODZlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRJdCB9IGZyb20gXCJnZXQtaXRcIjtcbmltcG9ydCB7IGFkYXB0ZXIsIGVudmlyb25tZW50IH0gZnJvbSBcImdldC1pdFwiO1xuaW1wb3J0IHsgcmV0cnksIGpzb25SZXF1ZXN0LCBqc29uUmVzcG9uc2UsIHByb2dyZXNzLCBvYnNlcnZhYmxlLCBkZWJ1ZywgaGVhZGVycywgYWdlbnQgfSBmcm9tIFwiZ2V0LWl0L21pZGRsZXdhcmVcIjtcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIGxhc3RWYWx1ZUZyb20gfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdFdpdGgsIG1hcCwgZmlsdGVyIH0gZnJvbSBcInJ4anMvb3BlcmF0b3JzXCI7XG5pbXBvcnQgeyB2IGFzIHZlcmNlbFN0ZWdhQ2xlYW5BbGwgfSBmcm9tIFwiLi9fY2h1bmtzLWVzL3ZlcmNlbFN0ZWdhQ2xlYW5BbGwuanNcIjtcbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wJDMgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDMob2JqLCBrZXksIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlLCBfX3B1YmxpY0ZpZWxkJDMgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wJDMob2JqLCB0eXBlb2Yga2V5ICE9IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSksIHZhbHVlKTtcbmNsYXNzIENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICBjb25zdCBwcm9wcyA9IGV4dHJhY3RFcnJvclByb3BzKHJlcyk7XG4gICAgc3VwZXIocHJvcHMubWVzc2FnZSksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInJlc3BvbnNlXCIpLCBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJzdGF0dXNDb2RlXCIsIDQwMCksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInJlc3BvbnNlQm9keVwiKSwgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGV0YWlsc1wiKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gIH1cbn1cbmNsYXNzIFNlcnZlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICBjb25zdCBwcm9wcyA9IGV4dHJhY3RFcnJvclByb3BzKHJlcyk7XG4gICAgc3VwZXIocHJvcHMubWVzc2FnZSksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInJlc3BvbnNlXCIpLCBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJzdGF0dXNDb2RlXCIsIDUwMCksIF9fcHVibGljRmllbGQkMyh0aGlzLCBcInJlc3BvbnNlQm9keVwiKSwgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGV0YWlsc1wiKSwgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RFcnJvclByb3BzKHJlcykge1xuICBjb25zdCBib2R5ID0gcmVzLmJvZHksIHByb3BzID0ge1xuICAgIHJlc3BvbnNlOiByZXMsXG4gICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VCb2R5OiBzdHJpbmdpZnlCb2R5KGJvZHksIHJlcyksXG4gICAgbWVzc2FnZTogXCJcIixcbiAgICBkZXRhaWxzOiB2b2lkIDBcbiAgfTtcbiAgaWYgKGJvZHkuZXJyb3IgJiYgYm9keS5tZXNzYWdlKVxuICAgIHJldHVybiBwcm9wcy5tZXNzYWdlID0gYCR7Ym9keS5lcnJvcn0gLSAke2JvZHkubWVzc2FnZX1gLCBwcm9wcztcbiAgaWYgKGlzTXV0YXRpb25FcnJvcihib2R5KSkge1xuICAgIGNvbnN0IGFsbEl0ZW1zID0gYm9keS5lcnJvci5pdGVtcyB8fCBbXSwgaXRlbXMgPSBhbGxJdGVtcy5zbGljZSgwLCA1KS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBpdGVtLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVzY3JpcHRpb247XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGxldCBpdGVtc1N0ciA9IGl0ZW1zLmxlbmd0aCA/IGA6XG4tICR7aXRlbXMuam9pbihgXG4tIGApfWAgOiBcIlwiO1xuICAgIHJldHVybiBhbGxJdGVtcy5sZW5ndGggPiA1ICYmIChpdGVtc1N0ciArPSBgXG4uLi5hbmQgJHthbGxJdGVtcy5sZW5ndGggLSA1fSBtb3JlYCksIHByb3BzLm1lc3NhZ2UgPSBgJHtib2R5LmVycm9yLmRlc2NyaXB0aW9ufSR7aXRlbXNTdHJ9YCwgcHJvcHMuZGV0YWlscyA9IGJvZHkuZXJyb3IsIHByb3BzO1xuICB9XG4gIHJldHVybiBib2R5LmVycm9yICYmIGJvZHkuZXJyb3IuZGVzY3JpcHRpb24gPyAocHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IuZGVzY3JpcHRpb24sIHByb3BzLmRldGFpbHMgPSBib2R5LmVycm9yLCBwcm9wcykgOiAocHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IgfHwgYm9keS5tZXNzYWdlIHx8IGh0dHBFcnJvck1lc3NhZ2UocmVzKSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gaXNNdXRhdGlvbkVycm9yKGJvZHkpIHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoYm9keSkgJiYgaXNQbGFpbk9iamVjdChib2R5LmVycm9yKSAmJiBib2R5LmVycm9yLnR5cGUgPT09IFwibXV0YXRpb25FcnJvclwiICYmIHR5cGVvZiBib2R5LmVycm9yLmRlc2NyaXB0aW9uID09IFwic3RyaW5nXCI7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufVxuZnVuY3Rpb24gaHR0cEVycm9yTWVzc2FnZShyZXMpIHtcbiAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IHJlcy5zdGF0dXNNZXNzYWdlID8gYCAke3Jlcy5zdGF0dXNNZXNzYWdlfWAgOiBcIlwiO1xuICByZXR1cm4gYCR7cmVzLm1ldGhvZH0tcmVxdWVzdCB0byAke3Jlcy51cmx9IHJlc3VsdGVkIGluIEhUVFAgJHtyZXMuc3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2V9YDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJvZHkoYm9keSwgcmVzKSB7XG4gIHJldHVybiAocmVzLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTEgPyBKU09OLnN0cmluZ2lmeShib2R5LCBudWxsLCAyKSA6IGJvZHk7XG59XG5jb25zdCBodHRwRXJyb3IgPSB7XG4gIG9uUmVzcG9uc2U6IChyZXMpID0+IHtcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gNTAwKVxuICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKHJlcyk7XG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMClcbiAgICAgIHRocm93IG5ldyBDbGllbnRFcnJvcihyZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn0sIHByaW50V2FybmluZ3MgPSB7XG4gIG9uUmVzcG9uc2U6IChyZXMpID0+IHtcbiAgICBjb25zdCB3YXJuID0gcmVzLmhlYWRlcnNbXCJ4LXNhbml0eS13YXJuaW5nXCJdO1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh3YXJuKSA/IHdhcm4gOiBbd2Fybl0pLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKChtc2cpID0+IGNvbnNvbGUud2Fybihtc2cpKSwgcmVzO1xuICB9XG59O1xuZnVuY3Rpb24gZGVmaW5lSHR0cFJlcXVlc3QoZW52TWlkZGxld2FyZSkge1xuICByZXR1cm4gZ2V0SXQoW1xuICAgIHJldHJ5KHsgc2hvdWxkUmV0cnkgfSksXG4gICAgLi4uZW52TWlkZGxld2FyZSxcbiAgICBwcmludFdhcm5pbmdzLFxuICAgIGpzb25SZXF1ZXN0KCksXG4gICAganNvblJlc3BvbnNlKCksXG4gICAgcHJvZ3Jlc3MoKSxcbiAgICBodHRwRXJyb3IsXG4gICAgb2JzZXJ2YWJsZSh7IGltcGxlbWVudGF0aW9uOiBPYnNlcnZhYmxlIH0pXG4gIF0pO1xufVxuZnVuY3Rpb24gc2hvdWxkUmV0cnkoZXJyLCBhdHRlbXB0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLm1heFJldHJpZXMgPT09IDApXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBpc1NhZmUgPSBvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBvcHRpb25zLm1ldGhvZCA9PT0gXCJIRUFEXCIsIGlzUXVlcnkgPSAob3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmwpLnN0YXJ0c1dpdGgoXCIvZGF0YS9xdWVyeVwiKSwgaXNSZXRyaWFibGVSZXNwb25zZSA9IGVyci5yZXNwb25zZSAmJiAoZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSB8fCBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNTAyIHx8IGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA1MDMpO1xuICByZXR1cm4gKGlzU2FmZSB8fCBpc1F1ZXJ5KSAmJiBpc1JldHJpYWJsZVJlc3BvbnNlID8gITAgOiByZXRyeS5zaG91bGRSZXRyeShlcnIsIGF0dGVtcHQsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKHNlbCkge1xuICBpZiAodHlwZW9mIHNlbCA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB7IGlkOiBzZWwgfTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VsKSlcbiAgICByZXR1cm4geyBxdWVyeTogXCIqW19pZCBpbiAkaWRzXVwiLCBwYXJhbXM6IHsgaWRzOiBzZWwgfSB9O1xuICBpZiAodHlwZW9mIHNlbCA9PSBcIm9iamVjdFwiICYmIHNlbCAhPT0gbnVsbCAmJiBcInF1ZXJ5XCIgaW4gc2VsICYmIHR5cGVvZiBzZWwucXVlcnkgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gXCJwYXJhbXNcIiBpbiBzZWwgJiYgdHlwZW9mIHNlbC5wYXJhbXMgPT0gXCJvYmplY3RcIiAmJiBzZWwucGFyYW1zICE9PSBudWxsID8geyBxdWVyeTogc2VsLnF1ZXJ5LCBwYXJhbXM6IHNlbC5wYXJhbXMgfSA6IHsgcXVlcnk6IHNlbC5xdWVyeSB9O1xuICBjb25zdCBzZWxlY3Rpb25PcHRzID0gW1xuICAgIFwiKiBEb2N1bWVudCBJRCAoPGRvY0lkPilcIixcbiAgICBcIiogQXJyYXkgb2YgZG9jdW1lbnQgSURzXCIsXG4gICAgXCIqIE9iamVjdCBjb250YWluaW5nIGBxdWVyeWBcIlxuICBdLmpvaW4oYFxuYCk7XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzZWxlY3Rpb24gLSBtdXN0IGJlIG9uZSBvZjpcblxuJHtzZWxlY3Rpb25PcHRzfWApO1xufVxuY29uc3QgVkFMSURfQVNTRVRfVFlQRVMgPSBbXCJpbWFnZVwiLCBcImZpbGVcIl0sIFZBTElEX0lOU0VSVF9MT0NBVElPTlMgPSBbXCJiZWZvcmVcIiwgXCJhZnRlclwiLCBcInJlcGxhY2VcIl0sIGRhdGFzZXQgPSAobmFtZTIpID0+IHtcbiAgaWYgKCEvXih+W2EtejAtOV17MX1bLVxcd117MCw2M318W2EtejAtOV17MX1bLVxcd117MCw2M30pJC8udGVzdChuYW1lMikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJEYXRhc2V0cyBjYW4gb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzLCBudW1iZXJzLCB1bmRlcnNjb3JlcyBhbmQgZGFzaGVzLCBhbmQgc3RhcnQgd2l0aCB0aWxkZSwgYW5kIGJlIG1heGltdW0gNjQgY2hhcmFjdGVyc1wiXG4gICAgKTtcbn0sIHByb2plY3RJZCA9IChpZCkgPT4ge1xuICBpZiAoIS9eWy1hLXowLTldKyQvaS50ZXN0KGlkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgcHJvamVjdElkYCBjYW4gb25seSBjb250YWluIG9ubHkgYS16LCAwLTkgYW5kIGRhc2hlc1wiKTtcbn0sIHZhbGlkYXRlQXNzZXRUeXBlID0gKHR5cGUpID0+IHtcbiAgaWYgKFZBTElEX0FTU0VUX1RZUEVTLmluZGV4T2YodHlwZSkgPT09IC0xKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3NldCB0eXBlOiAke3R5cGV9LiBNdXN0IGJlIG9uZSBvZiAke1ZBTElEX0FTU0VUX1RZUEVTLmpvaW4oXCIsIFwiKX1gKTtcbn0sIHZhbGlkYXRlT2JqZWN0ID0gKG9wLCB2YWwpID0+IHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcH0oKSB0YWtlcyBhbiBvYmplY3Qgb2YgcHJvcGVydGllc2ApO1xufSwgdmFsaWRhdGVEb2N1bWVudElkID0gKG9wLCBpZCkgPT4ge1xuICBpZiAodHlwZW9mIGlkICE9IFwic3RyaW5nXCIgfHwgIS9eW2EtejAtOV9dW2EtejAtOV8uLV17MCwxMjd9JC9pLnRlc3QoaWQpIHx8IGlkLmluY2x1ZGVzKFwiLi5cIikpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke29wfSgpOiBcIiR7aWR9XCIgaXMgbm90IGEgdmFsaWQgZG9jdW1lbnQgSURgKTtcbn0sIHJlcXVpcmVEb2N1bWVudElkID0gKG9wLCBkb2MpID0+IHtcbiAgaWYgKCFkb2MuX2lkKVxuICAgIHRocm93IG5ldyBFcnJvcihgJHtvcH0oKSByZXF1aXJlcyB0aGF0IHRoZSBkb2N1bWVudCBjb250YWlucyBhbiBJRCAoXCJfaWRcIiBwcm9wZXJ0eSlgKTtcbiAgdmFsaWRhdGVEb2N1bWVudElkKG9wLCBkb2MuX2lkKTtcbn0sIHZhbGlkYXRlSW5zZXJ0ID0gKGF0LCBzZWxlY3RvciwgaXRlbXMpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gXCJpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcylcIjtcbiAgaWYgKFZBTElEX0lOU0VSVF9MT0NBVElPTlMuaW5kZXhPZihhdCkgPT09IC0xKSB7XG4gICAgY29uc3QgdmFsaWQgPSBWQUxJRF9JTlNFUlRfTE9DQVRJT05TLm1hcCgobG9jKSA9PiBgXCIke2xvY31cImApLmpvaW4oXCIsIFwiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2lnbmF0dXJlfSB0YWtlcyBhbiBcImF0XCItYXJndW1lbnQgd2hpY2ggaXMgb25lIG9mOiAke3ZhbGlkfWApO1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c2lnbmF0dXJlfSB0YWtlcyBhIFwic2VsZWN0b3JcIi1hcmd1bWVudCB3aGljaCBtdXN0IGJlIGEgc3RyaW5nYCk7XG4gIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpZ25hdHVyZX0gdGFrZXMgYW4gXCJpdGVtc1wiLWFyZ3VtZW50IHdoaWNoIG11c3QgYmUgYW4gYXJyYXlgKTtcbn0sIGhhc0RhdGFzZXQgPSAoY29uZmlnKSA9PiB7XG4gIGlmICghY29uZmlnLmRhdGFzZXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGRhdGFzZXRgIG11c3QgYmUgcHJvdmlkZWQgdG8gcGVyZm9ybSBxdWVyaWVzXCIpO1xuICByZXR1cm4gY29uZmlnLmRhdGFzZXQgfHwgXCJcIjtcbn0sIHJlcXVlc3RUYWcgPSAodGFnKSA9PiB7XG4gIGlmICh0eXBlb2YgdGFnICE9IFwic3RyaW5nXCIgfHwgIS9eW2EtejAtOS5fLV17MSw3NX0kL2kudGVzdCh0YWcpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiVGFnIGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsIHVuZGVyc2NvcmVzLCBkYXNoZXMgYW5kIGRvdHMsIGFuZCBiZSBiZXR3ZWVuIG9uZSBhbmQgNzUgY2hhcmFjdGVycyBsb25nLlwiXG4gICAgKTtcbiAgcmV0dXJuIHRhZztcbn07XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZGVmTm9ybWFsUHJvcCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQyKG9iaiwga2V5LCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZSwgX19wdWJsaWNGaWVsZCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gKF9fZGVmTm9ybWFsUHJvcCQyKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpLCB2YWx1ZSksIF9fYWNjZXNzQ2hlY2skNiA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59LCBfX3ByaXZhdGVHZXQkNiA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayQ2KG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKSwgX19wcml2YXRlQWRkJDYgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59LCBfX3ByaXZhdGVTZXQkNiA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2skNihvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKTtcbmNsYXNzIEJhc2VQYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgb3BlcmF0aW9ucyA9IHt9KSB7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwic2VsZWN0aW9uXCIpLCBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJvcGVyYXRpb25zXCIpLCB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbiwgdGhpcy5vcGVyYXRpb25zID0gb3BlcmF0aW9ucztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gYXR0cmlidXRlcyB0byB0aGUgZG9jdW1lbnQuIERvZXMgTk9UIG1lcmdlIG9iamVjdHMuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgcGF0Y2gsIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gQXR0cmlidXRlcyB0byBzZXQuIFRvIHNldCBhIGRlZXAgYXR0cmlidXRlLCB1c2UgSlNPTk1hdGNoLCBlZzogXFx7XCJuZXN0ZWQucHJvcFwiOiBcInZhbHVlXCJcXH1cbiAgICovXG4gIHNldChhdHRycykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJzZXRcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudCBpZiB0aGV5IGFyZSBub3QgY3VycmVudGx5IHNldC4gRG9lcyBOT1QgbWVyZ2Ugb2JqZWN0cy5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGVzIHRvIHNldC4gVG8gc2V0IGEgZGVlcCBhdHRyaWJ1dGUsIHVzZSBKU09OTWF0Y2gsIGVnOiBcXHtcIm5lc3RlZC5wcm9wXCI6IFwidmFsdWVcIlxcfVxuICAgKi9cbiAgc2V0SWZNaXNzaW5nKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcInNldElmTWlzc2luZ1wiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgXCJkaWZmLW1hdGNoLXBhdGNoXCIgb3BlcmF0aW9uIG9uIHRoZSBzdHJpbmcgYXR0cmlidXRlcyBwcm92aWRlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGVzIHRvIHBlcmZvcm0gb3BlcmF0aW9uIG9uLiBUbyBzZXQgYSBkZWVwIGF0dHJpYnV0ZSwgdXNlIEpTT05NYXRjaCwgZWc6IFxce1wibmVzdGVkLnByb3BcIjogXCJkbXBcIlxcfVxuICAgKi9cbiAgZGlmZk1hdGNoUGF0Y2goYXR0cnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoXCJkaWZmTWF0Y2hQYXRjaFwiLCBhdHRycyksIHRoaXMuX2Fzc2lnbihcImRpZmZNYXRjaFBhdGNoXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogVW5zZXRzIHRoZSBhdHRyaWJ1dGUgcGF0aHMgcHJvdmlkZWQuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgcGF0Y2gsIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGF0dHJzIC0gQXR0cmlidXRlIHBhdGhzIHRvIHVuc2V0LlxuICAgKi9cbiAgdW5zZXQoYXR0cnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXR0cnMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zZXQoYXR0cnMpIHRha2VzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gdW5zZXQsIG5vbi1hcnJheSBnaXZlblwiKTtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcGVyYXRpb25zLCB7IHVuc2V0OiBhdHRycyB9KSwgdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5jcmVtZW50IGEgbnVtZXJpYyB2YWx1ZS4gRWFjaCBlbnRyeSBpbiB0aGUgYXJndW1lbnQgaXMgZWl0aGVyIGFuIGF0dHJpYnV0ZSBvciBhIEpTT04gcGF0aC4gVGhlIHZhbHVlIG1heSBiZSBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuIFRoZSBvcGVyYXRpb24gd2lsbCBmYWlsIGlmIHRhcmdldCB2YWx1ZSBpcyBub3QgYSBudW1lcmljIHZhbHVlLCBvciBkb2Vzbid0IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBPYmplY3Qgb2YgYXR0cmlidXRlIHBhdGhzIHRvIGluY3JlbWVudCwgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIHRvIGluY3JlbWVudCBieS5cbiAgICovXG4gIGluYyhhdHRycykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJpbmNcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNyZW1lbnQgYSBudW1lcmljIHZhbHVlLiBFYWNoIGVudHJ5IGluIHRoZSBhcmd1bWVudCBpcyBlaXRoZXIgYW4gYXR0cmlidXRlIG9yIGEgSlNPTiBwYXRoLiBUaGUgdmFsdWUgbWF5IGJlIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS4gVGhlIG9wZXJhdGlvbiB3aWxsIGZhaWwgaWYgdGFyZ2V0IHZhbHVlIGlzIG5vdCBhIG51bWVyaWMgdmFsdWUsIG9yIGRvZXNuJ3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIE9iamVjdCBvZiBhdHRyaWJ1dGUgcGF0aHMgdG8gZGVjcmVtZW50LCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgdG8gZGVjcmVtZW50IGJ5LlxuICAgKi9cbiAgZGVjKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcImRlY1wiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIG1vZGlmeWluZyBhcnJheXMsIGJ5IGluc2VydGluZywgYXBwZW5kaW5nIGFuZCByZXBsYWNpbmcgZWxlbWVudHMgdmlhIGEgSlNPTlBhdGggZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGF0IC0gTG9jYXRpb24gdG8gaW5zZXJ0IGF0LCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gc2VsZWN0b3IsIG9yICdyZXBsYWNlJyB0aGUgbWF0Y2hlZCBwYXRoXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEpTT05QYXRoIGV4cHJlc3Npb24sIGVnIGBjb21tZW50c1stMV1gIG9yIGBibG9ja3NbX2tleT09XCJhYmMxMjNcIl1gXG4gICAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGl0ZW1zIHRvIGluc2VydC9yZXBsYWNlXG4gICAqL1xuICBpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB2YWxpZGF0ZUluc2VydChhdCwgc2VsZWN0b3IsIGl0ZW1zKSwgdGhpcy5fYXNzaWduKFwiaW5zZXJ0XCIsIHsgW2F0XTogc2VsZWN0b3IsIGl0ZW1zIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIGdpdmVuIGl0ZW1zIHRvIHRoZSBhcnJheSBhdCB0aGUgZ2l2ZW4gSlNPTlBhdGhcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gQXR0cmlidXRlL3BhdGggdG8gYXBwZW5kIHRvLCBlZyBgY29tbWVudHNgIG9yIGBwZXJzb24uaG9iYmllc2BcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gYXBwZW5kIHRvIHRoZSBhcnJheVxuICAgKi9cbiAgYXBwZW5kKHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB0aGlzLmluc2VydChcImFmdGVyXCIsIGAke3NlbGVjdG9yfVstMV1gLCBpdGVtcyk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBlbmQgdGhlIGdpdmVuIGl0ZW1zIHRvIHRoZSBhcnJheSBhdCB0aGUgZ2l2ZW4gSlNPTlBhdGhcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gQXR0cmlidXRlL3BhdGggdG8gcHJlcGVuZCB0bywgZWcgYGNvbW1lbnRzYCBvciBgcGVyc29uLmhvYmJpZXNgXG4gICAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGl0ZW1zIHRvIHByZXBlbmQgdG8gdGhlIGFycmF5XG4gICAqL1xuICBwcmVwZW5kKHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB0aGlzLmluc2VydChcImJlZm9yZVwiLCBgJHtzZWxlY3Rvcn1bMF1gLCBpdGVtcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgY29udGVudHMgb2YgYW4gYXJyYXkgYnkgcmVtb3ZpbmcgZXhpc3RpbmcgZWxlbWVudHMgYW5kL29yIGFkZGluZyBuZXcgZWxlbWVudHMuXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEF0dHJpYnV0ZSBvciBKU09OUGF0aCBleHByZXNzaW9uIGZvciBhcnJheVxuICAgKiBAcGFyYW0gc3RhcnQgLSBJbmRleCBhdCB3aGljaCB0byBzdGFydCBjaGFuZ2luZyB0aGUgYXJyYXkgKHdpdGggb3JpZ2luIDApLiBJZiBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIGFjdHVhbCBzdGFydGluZyBpbmRleCB3aWxsIGJlIHNldCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS4gSWYgbmVnYXRpdmUsIHdpbGwgYmVnaW4gdGhhdCBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkgKHdpdGggb3JpZ2luIC0xKSBhbmQgd2lsbCBiZSBzZXQgdG8gMCBpZiBhYnNvbHV0ZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkueFxuICAgKiBAcGFyYW0gZGVsZXRlQ291bnQgLSBBbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG51bWJlciBvZiBvbGQgYXJyYXkgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gaXRlbXMgLSBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBhcnJheSwgYmVnaW5uaW5nIGF0IHRoZSBzdGFydCBpbmRleC4gSWYgeW91IGRvbid0IHNwZWNpZnkgYW55IGVsZW1lbnRzLCBzcGxpY2UoKSB3aWxsIG9ubHkgcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGFycmF5LlxuICAgKi9cbiAgc3BsaWNlKHNlbGVjdG9yLCBzdGFydCwgZGVsZXRlQ291bnQsIGl0ZW1zKSB7XG4gICAgY29uc3QgZGVsQWxsID0gdHlwZW9mIGRlbGV0ZUNvdW50ID4gXCJ1XCIgfHwgZGVsZXRlQ291bnQgPT09IC0xLCBzdGFydEluZGV4ID0gc3RhcnQgPCAwID8gc3RhcnQgLSAxIDogc3RhcnQsIGRlbENvdW50ID0gZGVsQWxsID8gLTEgOiBNYXRoLm1heCgwLCBzdGFydCArIGRlbGV0ZUNvdW50KSwgZGVsUmFuZ2UgPSBzdGFydEluZGV4IDwgMCAmJiBkZWxDb3VudCA+PSAwID8gXCJcIiA6IGRlbENvdW50LCByYW5nZVNlbGVjdG9yID0gYCR7c2VsZWN0b3J9WyR7c3RhcnRJbmRleH06JHtkZWxSYW5nZX1dYDtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoXCJyZXBsYWNlXCIsIHJhbmdlU2VsZWN0b3IsIGl0ZW1zIHx8IFtdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJldmlzaW9uIGNsYXVzZSwgcHJldmVudGluZyB0aGUgZG9jdW1lbnQgZnJvbSBiZWluZyBwYXRjaGVkIGlmIHRoZSBgX3JldmAgcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggdGhlIGdpdmVuIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSByZXYgLSBSZXZpc2lvbiB0byBsb2NrIHRoZSBwYXRjaCB0b1xuICAgKi9cbiAgaWZSZXZpc2lvbklkKHJldikge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbnMuaWZSZXZpc2lvbklEID0gcmV2LCB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXRjaFxuICAgKi9cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB7IC4uLmdldFNlbGVjdGlvbih0aGlzLnNlbGVjdGlvbiksIC4uLnRoaXMub3BlcmF0aW9ucyB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXRjaFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHBhdGNoIG9mIGFsbCBvcGVyYXRpb25zXG4gICAqL1xuICByZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zID0ge30sIHRoaXM7XG4gIH1cbiAgX2Fzc2lnbihvcCwgcHJvcHMsIG1lcmdlID0gITApIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qob3AsIHByb3BzKSwgdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcGVyYXRpb25zLCB7XG4gICAgICBbb3BdOiBPYmplY3QuYXNzaWduKHt9LCBtZXJnZSAmJiB0aGlzLm9wZXJhdGlvbnNbb3BdIHx8IHt9LCBwcm9wcylcbiAgICB9KSwgdGhpcztcbiAgfVxuICBfc2V0KG9wLCBwcm9wcykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24ob3AsIHByb3BzLCAhMSk7XG4gIH1cbn1cbnZhciBfY2xpZW50JDU7XG5jb25zdCBfT2JzZXJ2YWJsZVBhdGNoID0gY2xhc3MgX09ic2VydmFibGVQYXRjaDIgZXh0ZW5kcyBCYXNlUGF0Y2gge1xuICBjb25zdHJ1Y3RvcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMsIGNsaWVudCkge1xuICAgIHN1cGVyKHNlbGVjdGlvbiwgb3BlcmF0aW9ucyksIF9fcHJpdmF0ZUFkZCQ2KHRoaXMsIF9jbGllbnQkNSwgdm9pZCAwKSwgX19wcml2YXRlU2V0JDYodGhpcywgX2NsaWVudCQ1LCBjbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHBhdGNoXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlUGF0Y2gyKHRoaXMuc2VsZWN0aW9uLCB7IC4uLnRoaXMub3BlcmF0aW9ucyB9LCBfX3ByaXZhdGVHZXQkNih0aGlzLCBfY2xpZW50JDUpKTtcbiAgfVxuICBjb21taXQob3B0aW9ucykge1xuICAgIGlmICghX19wcml2YXRlR2V0JDYodGhpcywgX2NsaWVudCQ1KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJObyBgY2xpZW50YCBwYXNzZWQgdG8gcGF0Y2gsIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSBwYXRjaCB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2RcIlxuICAgICAgKTtcbiAgICBjb25zdCByZXR1cm5GaXJzdCA9IHR5cGVvZiB0aGlzLnNlbGVjdGlvbiA9PSBcInN0cmluZ1wiLCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHJldHVybkZpcnN0LCByZXR1cm5Eb2N1bWVudHM6ICEwIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQkNih0aGlzLCBfY2xpZW50JDUpLm11dGF0ZSh7IHBhdGNoOiB0aGlzLnNlcmlhbGl6ZSgpIH0sIG9wdHMpO1xuICB9XG59O1xuX2NsaWVudCQ1ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgT2JzZXJ2YWJsZVBhdGNoID0gX09ic2VydmFibGVQYXRjaDtcbnZhciBfY2xpZW50MiQ1O1xuY29uc3QgX1BhdGNoID0gY2xhc3MgX1BhdGNoMiBleHRlbmRzIEJhc2VQYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgb3BlcmF0aW9ucywgY2xpZW50KSB7XG4gICAgc3VwZXIoc2VsZWN0aW9uLCBvcGVyYXRpb25zKSwgX19wcml2YXRlQWRkJDYodGhpcywgX2NsaWVudDIkNSwgdm9pZCAwKSwgX19wcml2YXRlU2V0JDYodGhpcywgX2NsaWVudDIkNSwgY2xpZW50KTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBwYXRjaFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfUGF0Y2gyKHRoaXMuc2VsZWN0aW9uLCB7IC4uLnRoaXMub3BlcmF0aW9ucyB9LCBfX3ByaXZhdGVHZXQkNih0aGlzLCBfY2xpZW50MiQ1KSk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCQ2KHRoaXMsIF9jbGllbnQyJDUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGBjbGllbnRgIHBhc3NlZCB0byBwYXRjaCwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHBhdGNoIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiXG4gICAgICApO1xuICAgIGNvbnN0IHJldHVybkZpcnN0ID0gdHlwZW9mIHRoaXMuc2VsZWN0aW9uID09IFwic3RyaW5nXCIsIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgcmV0dXJuRmlyc3QsIHJldHVybkRvY3VtZW50czogITAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCQ2KHRoaXMsIF9jbGllbnQyJDUpLm11dGF0ZSh7IHBhdGNoOiB0aGlzLnNlcmlhbGl6ZSgpIH0sIG9wdHMpO1xuICB9XG59O1xuX2NsaWVudDIkNSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IFBhdGNoID0gX1BhdGNoO1xudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IChfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKSwgdmFsdWUpLCBfX2FjY2Vzc0NoZWNrJDUgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufSwgX19wcml2YXRlR2V0JDUgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2skNShvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSksIF9fcHJpdmF0ZUFkZCQ1ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufSwgX19wcml2YXRlU2V0JDUgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrJDUob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSk7XG5jb25zdCBkZWZhdWx0TXV0YXRlT3B0aW9ucyA9IHsgcmV0dXJuRG9jdW1lbnRzOiAhMSB9O1xuY2xhc3MgQmFzZVRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob3BlcmF0aW9ucyA9IFtdLCB0cmFuc2FjdGlvbklkKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwib3BlcmF0aW9uc1wiKSwgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwidHJ4SWRcIiksIHRoaXMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnMsIHRoaXMudHJ4SWQgPSB0cmFuc2FjdGlvbklkO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNhbml0eSBkb2N1bWVudC4gSWYgYF9pZGAgaXMgcHJvdmlkZWQgYW5kIGFscmVhZHkgZXhpc3RzLCB0aGUgbXV0YXRpb24gd2lsbCBmYWlsLiBJZiBubyBgX2lkYCBpcyBnaXZlbiwgb25lIHdpbGwgYXV0b21hdGljYWxseSBiZSBnZW5lcmF0ZWQgYnkgdGhlIGRhdGFiYXNlLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2MgLSBEb2N1bWVudCB0byBjcmVhdGUuIFJlcXVpcmVzIGEgYF90eXBlYCBwcm9wZXJ0eS5cbiAgICovXG4gIGNyZWF0ZShkb2MpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoXCJjcmVhdGVcIiwgZG9jKSwgdGhpcy5fYWRkKHsgY3JlYXRlOiBkb2MgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LiBJZiBhIGRvY3VtZW50IHdpdGggdGhlIHNhbWUgYF9pZGAgYWxyZWFkeSBleGlzdHMsIHRoZSBjcmVhdGUgb3BlcmF0aW9uIHdpbGwgYmUgaWdub3JlZC5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gZG9jIC0gRG9jdW1lbnQgdG8gY3JlYXRlIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuIFJlcXVpcmVzIGBfaWRgIGFuZCBgX3R5cGVgIHByb3BlcnRpZXMuXG4gICAqL1xuICBjcmVhdGVJZk5vdEV4aXN0cyhkb2MpIHtcbiAgICBjb25zdCBvcCA9IFwiY3JlYXRlSWZOb3RFeGlzdHNcIjtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qob3AsIGRvYyksIHJlcXVpcmVEb2N1bWVudElkKG9wLCBkb2MpLCB0aGlzLl9hZGQoeyBbb3BdOiBkb2MgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LCBvciByZXBsYWNlcyBhbiBleGlzdGluZyBvbmUgaWYgdGhlIHNhbWUgYF9pZGAgaXMgYWxyZWFkeSB1c2VkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2MgLSBEb2N1bWVudCB0byBjcmVhdGUgb3IgcmVwbGFjZS4gUmVxdWlyZXMgYF9pZGAgYW5kIGBfdHlwZWAgcHJvcGVydGllcy5cbiAgICovXG4gIGNyZWF0ZU9yUmVwbGFjZShkb2MpIHtcbiAgICBjb25zdCBvcCA9IFwiY3JlYXRlT3JSZXBsYWNlXCI7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KG9wLCBkb2MpLCByZXF1aXJlRG9jdW1lbnRJZChvcCwgZG9jKSwgdGhpcy5fYWRkKHsgW29wXTogZG9jIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudCBJRFxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2N1bWVudElkIC0gRG9jdW1lbnQgSUQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoZG9jdW1lbnRJZCkge1xuICAgIHJldHVybiB2YWxpZGF0ZURvY3VtZW50SWQoXCJkZWxldGVcIiwgZG9jdW1lbnRJZCksIHRoaXMuX2FkZCh7IGRlbGV0ZTogeyBpZDogZG9jdW1lbnRJZCB9IH0pO1xuICB9XG4gIHRyYW5zYWN0aW9uSWQoaWQpIHtcbiAgICByZXR1cm4gaWQgPyAodGhpcy50cnhJZCA9IGlkLCB0aGlzKSA6IHRoaXMudHJ4SWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLm9wZXJhdGlvbnNdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHRyYW5zYWN0aW9uIG9mIGFsbCBvcGVyYXRpb25zXG4gICAqL1xuICByZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zID0gW10sIHRoaXM7XG4gIH1cbiAgX2FkZChtdXQpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25zLnB1c2gobXV0KSwgdGhpcztcbiAgfVxufVxudmFyIF9jbGllbnQkNDtcbmNvbnN0IF9UcmFuc2FjdGlvbiA9IGNsYXNzIF9UcmFuc2FjdGlvbjIgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25zLCBjbGllbnQsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICBzdXBlcihvcGVyYXRpb25zLCB0cmFuc2FjdGlvbklkKSwgX19wcml2YXRlQWRkJDUodGhpcywgX2NsaWVudCQ0LCB2b2lkIDApLCBfX3ByaXZhdGVTZXQkNSh0aGlzLCBfY2xpZW50JDQsIGNsaWVudCk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX1RyYW5zYWN0aW9uMihbLi4udGhpcy5vcGVyYXRpb25zXSwgX19wcml2YXRlR2V0JDUodGhpcywgX2NsaWVudCQ0KSwgdGhpcy50cnhJZCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCQ1KHRoaXMsIF9jbGllbnQkNCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHRyYW5zYWN0aW9uLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgdHJhbnNhY3Rpb24gdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCJcbiAgICAgICk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCQ1KHRoaXMsIF9jbGllbnQkNCkubXV0YXRlKFxuICAgICAgdGhpcy5zZXJpYWxpemUoKSxcbiAgICAgIE9iamVjdC5hc3NpZ24oeyB0cmFuc2FjdGlvbklkOiB0aGlzLnRyeElkIH0sIGRlZmF1bHRNdXRhdGVPcHRpb25zLCBvcHRpb25zIHx8IHt9KVxuICAgICk7XG4gIH1cbiAgcGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHBhdGNoT3BzKSB7XG4gICAgY29uc3QgaXNCdWlsZGVyID0gdHlwZW9mIHBhdGNoT3BzID09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodHlwZW9mIHBhdGNoT3JEb2N1bWVudElkICE9IFwic3RyaW5nXCIgJiYgcGF0Y2hPckRvY3VtZW50SWQgaW5zdGFuY2VvZiBQYXRjaClcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2hPckRvY3VtZW50SWQuc2VyaWFsaXplKCkgfSk7XG4gICAgaWYgKGlzQnVpbGRlcikge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgUGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHt9LCBfX3ByaXZhdGVHZXQkNSh0aGlzLCBfY2xpZW50JDQpKSk7XG4gICAgICBpZiAoIShwYXRjaCBpbnN0YW5jZW9mIFBhdGNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZnVuY3Rpb24gcGFzc2VkIHRvIGBwYXRjaCgpYCBtdXN0IHJldHVybiB0aGUgcGF0Y2hcIik7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoLnNlcmlhbGl6ZSgpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHsgaWQ6IHBhdGNoT3JEb2N1bWVudElkLCAuLi5wYXRjaE9wcyB9IH0pO1xuICB9XG59O1xuX2NsaWVudCQ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgVHJhbnNhY3Rpb24gPSBfVHJhbnNhY3Rpb247XG52YXIgX2NsaWVudDIkNDtcbmNvbnN0IF9PYnNlcnZhYmxlVHJhbnNhY3Rpb24gPSBjbGFzcyBfT2JzZXJ2YWJsZVRyYW5zYWN0aW9uMiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvbnMsIGNsaWVudCwgdHJhbnNhY3Rpb25JZCkge1xuICAgIHN1cGVyKG9wZXJhdGlvbnMsIHRyYW5zYWN0aW9uSWQpLCBfX3ByaXZhdGVBZGQkNSh0aGlzLCBfY2xpZW50MiQ0LCB2b2lkIDApLCBfX3ByaXZhdGVTZXQkNSh0aGlzLCBfY2xpZW50MiQ0LCBjbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlVHJhbnNhY3Rpb24yKFsuLi50aGlzLm9wZXJhdGlvbnNdLCBfX3ByaXZhdGVHZXQkNSh0aGlzLCBfY2xpZW50MiQ0KSwgdGhpcy50cnhJZCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCQ1KHRoaXMsIF9jbGllbnQyJDQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIk5vIGBjbGllbnRgIHBhc3NlZCB0byB0cmFuc2FjdGlvbiwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHRyYW5zYWN0aW9uIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiXG4gICAgICApO1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQkNSh0aGlzLCBfY2xpZW50MiQ0KS5tdXRhdGUoXG4gICAgICB0aGlzLnNlcmlhbGl6ZSgpLFxuICAgICAgT2JqZWN0LmFzc2lnbih7IHRyYW5zYWN0aW9uSWQ6IHRoaXMudHJ4SWQgfSwgZGVmYXVsdE11dGF0ZU9wdGlvbnMsIG9wdGlvbnMgfHwge30pXG4gICAgKTtcbiAgfVxuICBwYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwgcGF0Y2hPcHMpIHtcbiAgICBjb25zdCBpc0J1aWxkZXIgPSB0eXBlb2YgcGF0Y2hPcHMgPT0gXCJmdW5jdGlvblwiO1xuICAgIGlmICh0eXBlb2YgcGF0Y2hPckRvY3VtZW50SWQgIT0gXCJzdHJpbmdcIiAmJiBwYXRjaE9yRG9jdW1lbnRJZCBpbnN0YW5jZW9mIE9ic2VydmFibGVQYXRjaClcbiAgICAgIHJldHVybiB0aGlzLl9hZGQoeyBwYXRjaDogcGF0Y2hPckRvY3VtZW50SWQuc2VyaWFsaXplKCkgfSk7XG4gICAgaWYgKGlzQnVpbGRlcikge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgT2JzZXJ2YWJsZVBhdGNoKHBhdGNoT3JEb2N1bWVudElkLCB7fSwgX19wcml2YXRlR2V0JDUodGhpcywgX2NsaWVudDIkNCkpKTtcbiAgICAgIGlmICghKHBhdGNoIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVBhdGNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZnVuY3Rpb24gcGFzc2VkIHRvIGBwYXRjaCgpYCBtdXN0IHJldHVybiB0aGUgcGF0Y2hcIik7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHBhdGNoLnNlcmlhbGl6ZSgpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkKHsgcGF0Y2g6IHsgaWQ6IHBhdGNoT3JEb2N1bWVudElkLCAuLi5wYXRjaE9wcyB9IH0pO1xuICB9XG59O1xuX2NsaWVudDIkNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IE9ic2VydmFibGVUcmFuc2FjdGlvbiA9IF9PYnNlcnZhYmxlVHJhbnNhY3Rpb247XG5jb25zdCBCQVNFX1VSTCA9IFwiaHR0cHM6Ly93d3cuc2FuaXR5LmlvL2hlbHAvXCI7XG5mdW5jdGlvbiBnZW5lcmF0ZUhlbHBVcmwoc2x1Zykge1xuICByZXR1cm4gQkFTRV9VUkwgKyBzbHVnO1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICBsZXQgZGlkQ2FsbCA9ICExLCByZXR1cm5WYWx1ZTtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiAoZGlkQ2FsbCB8fCAocmV0dXJuVmFsdWUgPSBmbiguLi5hcmdzKSwgZGlkQ2FsbCA9ICEwKSwgcmV0dXJuVmFsdWUpO1xufVxuY29uc3QgY3JlYXRlV2FybmluZ1ByaW50ZXIgPSAobWVzc2FnZSkgPT4gKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBvbmNlKCguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4obWVzc2FnZS5qb2luKFwiIFwiKSwgLi4uYXJncykpXG4pLCBwcmludENkbldhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiU2luY2UgeW91IGhhdmVuJ3Qgc2V0IGEgdmFsdWUgZm9yIGB1c2VDZG5gLCB3ZSB3aWxsIGRlbGl2ZXIgY29udGVudCB1c2luZyBvdXJcIixcbiAgXCJnbG9iYWwsIGVkZ2UtY2FjaGVkIEFQSS1DRE4uIElmIHlvdSB3aXNoIHRvIGhhdmUgY29udGVudCBkZWxpdmVyZWQgZmFzdGVyLCBzZXRcIixcbiAgXCJgdXNlQ2RuOiBmYWxzZWAgdG8gdXNlIHRoZSBMaXZlIEFQSS4gTm90ZTogWW91IG1heSBpbmN1ciBoaWdoZXIgY29zdHMgdXNpbmcgdGhlIGxpdmUgQVBJLlwiXG5dKSwgcHJpbnRDZG5QcmV2aWV3RHJhZnRzV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJUaGUgU2FuaXR5IGNsaWVudCBpcyBjb25maWd1cmVkIHdpdGggdGhlIGBwZXJzcGVjdGl2ZWAgc2V0IHRvIGBwcmV2aWV3RHJhZnRzYCwgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHRoZSBBUEktQ0ROLlwiLFxuICBcIlRoZSBMaXZlIEFQSSB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gU2V0IGB1c2VDZG46IGZhbHNlYCBpbiB5b3VyIGNvbmZpZ3VyYXRpb24gdG8gaGlkZSB0aGlzIHdhcm5pbmcuXCJcbl0pLCBwcmludEJyb3dzZXJUb2tlbldhcm5pbmcgPSBjcmVhdGVXYXJuaW5nUHJpbnRlcihbXG4gIFwiWW91IGhhdmUgY29uZmlndXJlZCBTYW5pdHkgY2xpZW50IHRvIHVzZSBhIHRva2VuIGluIHRoZSBicm93c2VyLiBUaGlzIG1heSBjYXVzZSB1bmludGVudGlvbmFsIHNlY3VyaXR5IGlzc3Vlcy5cIixcbiAgYFNlZSAke2dlbmVyYXRlSGVscFVybChcbiAgICBcImpzLWNsaWVudC1icm93c2VyLXRva2VuXCJcbiAgKX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gYW5kIGhvdyB0byBoaWRlIHRoaXMgd2FybmluZy5gXG5dKSwgcHJpbnROb0FwaVZlcnNpb25TcGVjaWZpZWRXYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1xuICBcIlVzaW5nIHRoZSBTYW5pdHkgY2xpZW50IHdpdGhvdXQgc3BlY2lmeWluZyBhbiBBUEkgdmVyc2lvbiBpcyBkZXByZWNhdGVkLlwiLFxuICBgU2VlICR7Z2VuZXJhdGVIZWxwVXJsKFwianMtY2xpZW50LWFwaS12ZXJzaW9uXCIpfWBcbl0pLCBwcmludE5vRGVmYXVsdEV4cG9ydCA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcbiAgXCJUaGUgZGVmYXVsdCBleHBvcnQgb2YgQHNhbml0eS9jbGllbnQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIHRoZSBuYW1lZCBleHBvcnQgYGNyZWF0ZUNsaWVudGAgaW5zdGVhZC5cIlxuXSksIGRlZmF1bHRDZG5Ib3N0ID0gXCJhcGljZG4uc2FuaXR5LmlvXCIsIGRlZmF1bHRDb25maWcgPSB7XG4gIGFwaUhvc3Q6IFwiaHR0cHM6Ly9hcGkuc2FuaXR5LmlvXCIsXG4gIGFwaVZlcnNpb246IFwiMVwiLFxuICB1c2VQcm9qZWN0SG9zdG5hbWU6ICEwLFxuICBzdGVnYTogeyBlbmFibGVkOiAhMSB9XG59LCBMT0NBTEhPU1RTID0gW1wibG9jYWxob3N0XCIsIFwiMTI3LjAuMC4xXCIsIFwiMC4wLjAuMFwiXSwgaXNMb2NhbCA9IChob3N0KSA9PiBMT0NBTEhPU1RTLmluZGV4T2YoaG9zdCkgIT09IC0xO1xuZnVuY3Rpb24gdmFsaWRhdGVBcGlWZXJzaW9uKGFwaVZlcnNpb24pIHtcbiAgaWYgKGFwaVZlcnNpb24gPT09IFwiMVwiIHx8IGFwaVZlcnNpb24gPT09IFwiWFwiKVxuICAgIHJldHVybjtcbiAgY29uc3QgYXBpRGF0ZSA9IG5ldyBEYXRlKGFwaVZlcnNpb24pO1xuICBpZiAoISgvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8udGVzdChhcGlWZXJzaW9uKSAmJiBhcGlEYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiBhcGlEYXRlLmdldFRpbWUoKSA+IDApKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQVBJIHZlcnNpb24gc3RyaW5nLCBleHBlY3RlZCBgMWAgb3IgZGF0ZSBpbiBmb3JtYXQgYFlZWVktTU0tRERgXCIpO1xufVxuY29uc3QgdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKHBlcnNwZWN0aXZlKSB7XG4gIHN3aXRjaCAocGVyc3BlY3RpdmUpIHtcbiAgICBjYXNlIFwicHJldmlld0RyYWZ0c1wiOlxuICAgIGNhc2UgXCJwdWJsaXNoZWRcIjpcbiAgICBjYXNlIFwicmF3XCI6XG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBBUEkgcGVyc3BlY3RpdmUgc3RyaW5nLCBleHBlY3RlZCBgcHVibGlzaGVkYCwgYHByZXZpZXdEcmFmdHNgIG9yIGByYXdgXCJcbiAgICAgICk7XG4gIH1cbn0sIGluaXRDb25maWcgPSAoY29uZmlnLCBwcmV2Q29uZmlnKSA9PiB7XG4gIGNvbnN0IHNwZWNpZmllZENvbmZpZyA9IHtcbiAgICAuLi5wcmV2Q29uZmlnLFxuICAgIC4uLmNvbmZpZyxcbiAgICBzdGVnYToge1xuICAgICAgLi4udHlwZW9mIHByZXZDb25maWcuc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IHByZXZDb25maWcuc3RlZ2EgfSA6IHByZXZDb25maWcuc3RlZ2EgfHwgZGVmYXVsdENvbmZpZy5zdGVnYSxcbiAgICAgIC4uLnR5cGVvZiBjb25maWcuc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IGNvbmZpZy5zdGVnYSB9IDogY29uZmlnLnN0ZWdhIHx8IHt9XG4gICAgfVxuICB9O1xuICBzcGVjaWZpZWRDb25maWcuYXBpVmVyc2lvbiB8fCBwcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmcoKTtcbiAgY29uc3QgbmV3Q29uZmlnID0ge1xuICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgLi4uc3BlY2lmaWVkQ29uZmlnXG4gIH0sIHByb2plY3RCYXNlZCA9IG5ld0NvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWU7XG4gIGlmICh0eXBlb2YgUHJvbWlzZSA+IFwidVwiKSB7XG4gICAgY29uc3QgaGVscFVybCA9IGdlbmVyYXRlSGVscFVybChcImpzLWNsaWVudC1wcm9taXNlLXBvbHlmaWxsXCIpO1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gbmF0aXZlIFByb21pc2UtaW1wbGVtZW50YXRpb24gZm91bmQsIHBvbHlmaWxsIG5lZWRlZCAtIHNlZSAke2hlbHBVcmx9YCk7XG4gIH1cbiAgaWYgKHByb2plY3RCYXNlZCAmJiAhbmV3Q29uZmlnLnByb2plY3RJZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWd1cmF0aW9uIG11c3QgY29udGFpbiBgcHJvamVjdElkYFwiKTtcbiAgaWYgKHR5cGVvZiBuZXdDb25maWcucGVyc3BlY3RpdmUgPT0gXCJzdHJpbmdcIiAmJiB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlKG5ld0NvbmZpZy5wZXJzcGVjdGl2ZSksIFwiZW5jb2RlU291cmNlTWFwXCIgaW4gbmV3Q29uZmlnKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgb3B0aW9ucyBtZWFudCBmb3IgJ0BzYW5pdHkvcHJldmlldy1raXQvY2xpZW50Jy4gJ2VuY29kZVNvdXJjZU1hcCcgaXMgbm90IHN1cHBvcnRlZCBpbiAnQHNhbml0eS9jbGllbnQnLiBEaWQgeW91IG1lYW4gJ3N0ZWdhLmVuYWJsZWQnP1wiXG4gICAgKTtcbiAgaWYgKFwiZW5jb2RlU291cmNlTWFwQXRQYXRoXCIgaW4gbmV3Q29uZmlnKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgb3B0aW9ucyBtZWFudCBmb3IgJ0BzYW5pdHkvcHJldmlldy1raXQvY2xpZW50Jy4gJ2VuY29kZVNvdXJjZU1hcEF0UGF0aCcgaXMgbm90IHN1cHBvcnRlZCBpbiAnQHNhbml0eS9jbGllbnQnLiBEaWQgeW91IG1lYW4gJ3N0ZWdhLmZpbHRlcic/XCJcbiAgICApO1xuICBpZiAodHlwZW9mIG5ld0NvbmZpZy5zdGVnYS5lbmFibGVkICE9IFwiYm9vbGVhblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihgc3RlZ2EuZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbiwgcmVjZWl2ZWQgJHtuZXdDb25maWcuc3RlZ2EuZW5hYmxlZH1gKTtcbiAgaWYgKG5ld0NvbmZpZy5zdGVnYS5lbmFibGVkICYmIG5ld0NvbmZpZy5zdGVnYS5zdHVkaW9VcmwgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGVnYS5zdHVkaW9VcmwgbXVzdCBiZSBkZWZpbmVkIHdoZW4gc3RlZ2EuZW5hYmxlZCBpcyB0cnVlXCIpO1xuICBpZiAobmV3Q29uZmlnLnN0ZWdhLmVuYWJsZWQgJiYgdHlwZW9mIG5ld0NvbmZpZy5zdGVnYS5zdHVkaW9VcmwgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgbmV3Q29uZmlnLnN0ZWdhLnN0dWRpb1VybCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYHN0ZWdhLnN0dWRpb1VybCBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24sIHJlY2VpdmVkICR7bmV3Q29uZmlnLnN0ZWdhLnN0dWRpb1VybH1gXG4gICAgKTtcbiAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIGlzTG9jYWxob3N0ID0gaXNCcm93c2VyICYmIGlzTG9jYWwod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgaXNCcm93c2VyICYmIGlzTG9jYWxob3N0ICYmIG5ld0NvbmZpZy50b2tlbiAmJiBuZXdDb25maWcuaWdub3JlQnJvd3NlclRva2VuV2FybmluZyAhPT0gITAgPyBwcmludEJyb3dzZXJUb2tlbldhcm5pbmcoKSA6IHR5cGVvZiBuZXdDb25maWcudXNlQ2RuID4gXCJ1XCIgJiYgcHJpbnRDZG5XYXJuaW5nKCksIHByb2plY3RCYXNlZCAmJiBwcm9qZWN0SWQobmV3Q29uZmlnLnByb2plY3RJZCksIG5ld0NvbmZpZy5kYXRhc2V0ICYmIGRhdGFzZXQobmV3Q29uZmlnLmRhdGFzZXQpLCBcInJlcXVlc3RUYWdQcmVmaXhcIiBpbiBuZXdDb25maWcgJiYgKG5ld0NvbmZpZy5yZXF1ZXN0VGFnUHJlZml4ID0gbmV3Q29uZmlnLnJlcXVlc3RUYWdQcmVmaXggPyByZXF1ZXN0VGFnKG5ld0NvbmZpZy5yZXF1ZXN0VGFnUHJlZml4KS5yZXBsYWNlKC9cXC4rJC8sIFwiXCIpIDogdm9pZCAwKSwgbmV3Q29uZmlnLmFwaVZlcnNpb24gPSBgJHtuZXdDb25maWcuYXBpVmVyc2lvbn1gLnJlcGxhY2UoL152LywgXCJcIiksIG5ld0NvbmZpZy5pc0RlZmF1bHRBcGkgPSBuZXdDb25maWcuYXBpSG9zdCA9PT0gZGVmYXVsdENvbmZpZy5hcGlIb3N0LCBuZXdDb25maWcudXNlQ2RuID0gbmV3Q29uZmlnLnVzZUNkbiAhPT0gITEgJiYgIW5ld0NvbmZpZy53aXRoQ3JlZGVudGlhbHMsIHZhbGlkYXRlQXBpVmVyc2lvbihuZXdDb25maWcuYXBpVmVyc2lvbik7XG4gIGNvbnN0IGhvc3RQYXJ0cyA9IG5ld0NvbmZpZy5hcGlIb3N0LnNwbGl0KFwiOi8vXCIsIDIpLCBwcm90b2NvbCA9IGhvc3RQYXJ0c1swXSwgaG9zdCA9IGhvc3RQYXJ0c1sxXSwgY2RuSG9zdCA9IG5ld0NvbmZpZy5pc0RlZmF1bHRBcGkgPyBkZWZhdWx0Q2RuSG9zdCA6IGhvc3Q7XG4gIHJldHVybiBuZXdDb25maWcudXNlUHJvamVjdEhvc3RuYW1lID8gKG5ld0NvbmZpZy51cmwgPSBgJHtwcm90b2NvbH06Ly8ke25ld0NvbmZpZy5wcm9qZWN0SWR9LiR7aG9zdH0vdiR7bmV3Q29uZmlnLmFwaVZlcnNpb259YCwgbmV3Q29uZmlnLmNkblVybCA9IGAke3Byb3RvY29sfTovLyR7bmV3Q29uZmlnLnByb2plY3RJZH0uJHtjZG5Ib3N0fS92JHtuZXdDb25maWcuYXBpVmVyc2lvbn1gKSA6IChuZXdDb25maWcudXJsID0gYCR7bmV3Q29uZmlnLmFwaUhvc3R9L3Yke25ld0NvbmZpZy5hcGlWZXJzaW9ufWAsIG5ld0NvbmZpZy5jZG5VcmwgPSBuZXdDb25maWcudXJsKSwgbmV3Q29uZmlnO1xufSwgcHJvamVjdEhlYWRlciA9IFwiWC1TYW5pdHktUHJvamVjdC1JRFwiO1xuZnVuY3Rpb24gcmVxdWVzdE9wdGlvbnMoY29uZmlnLCBvdmVycmlkZXMgPSB7fSkge1xuICBjb25zdCBoZWFkZXJzMiA9IHt9LCB0b2tlbiA9IG92ZXJyaWRlcy50b2tlbiB8fCBjb25maWcudG9rZW47XG4gIHRva2VuICYmIChoZWFkZXJzMi5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke3Rva2VufWApLCAhb3ZlcnJpZGVzLnVzZUdsb2JhbEFwaSAmJiAhY29uZmlnLnVzZVByb2plY3RIb3N0bmFtZSAmJiBjb25maWcucHJvamVjdElkICYmIChoZWFkZXJzMltwcm9qZWN0SGVhZGVyXSA9IGNvbmZpZy5wcm9qZWN0SWQpO1xuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSAhISh0eXBlb2Ygb3ZlcnJpZGVzLndpdGhDcmVkZW50aWFscyA+IFwidVwiID8gY29uZmlnLnRva2VuIHx8IGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgOiBvdmVycmlkZXMud2l0aENyZWRlbnRpYWxzKSwgdGltZW91dCA9IHR5cGVvZiBvdmVycmlkZXMudGltZW91dCA+IFwidVwiID8gY29uZmlnLnRpbWVvdXQgOiBvdmVycmlkZXMudGltZW91dDtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG92ZXJyaWRlcywge1xuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMyLCBvdmVycmlkZXMuaGVhZGVycyB8fCB7fSksXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPiBcInVcIiA/IDUgKiA2MCAqIDFlMyA6IHRpbWVvdXQsXG4gICAgcHJveHk6IG92ZXJyaWRlcy5wcm94eSB8fCBjb25maWcucHJveHksXG4gICAganNvbjogITAsXG4gICAgd2l0aENyZWRlbnRpYWxzLFxuICAgIGZldGNoOiB0eXBlb2Ygb3ZlcnJpZGVzLmZldGNoID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNvbmZpZy5mZXRjaCA9PSBcIm9iamVjdFwiID8geyAuLi5jb25maWcuZmV0Y2gsIC4uLm92ZXJyaWRlcy5mZXRjaCB9IDogb3ZlcnJpZGVzLmZldGNoIHx8IGNvbmZpZy5mZXRjaFxuICB9KTtcbn1cbmNvbnN0IGVuY29kZVF1ZXJ5U3RyaW5nID0gKHtcbiAgcXVlcnksXG4gIHBhcmFtcyA9IHt9LFxuICBvcHRpb25zID0ge31cbn0pID0+IHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLCB7IHRhZywgcmV0dXJuUXVlcnksIC4uLm9wdHMgfSA9IG9wdGlvbnM7XG4gIHRhZyAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKFwidGFnXCIsIHRhZyksIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJxdWVyeVwiLCBxdWVyeSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChgJCR7a2V5fWAsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdHMpKVxuICAgIHZhbHVlICYmIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgJHt2YWx1ZX1gKTtcbiAgcmV0dXJuIHJldHVyblF1ZXJ5ID09PSAhMSAmJiBzZWFyY2hQYXJhbXMuYXBwZW5kKFwicmV0dXJuUXVlcnlcIiwgXCJmYWxzZVwiKSwgYD8ke3NlYXJjaFBhcmFtc31gO1xufSwgZXhjbHVkZUZhbHNleSA9IChwYXJhbSwgZGVmVmFsdWUpID0+IHBhcmFtID09PSAhMSA/IHZvaWQgMCA6IHR5cGVvZiBwYXJhbSA+IFwidVwiID8gZGVmVmFsdWUgOiBwYXJhbSwgZ2V0TXV0YXRpb25RdWVyeSA9IChvcHRpb25zID0ge30pID0+ICh7XG4gIGRyeVJ1bjogb3B0aW9ucy5kcnlSdW4sXG4gIHJldHVybklkczogITAsXG4gIHJldHVybkRvY3VtZW50czogZXhjbHVkZUZhbHNleShvcHRpb25zLnJldHVybkRvY3VtZW50cywgITApLFxuICB2aXNpYmlsaXR5OiBvcHRpb25zLnZpc2liaWxpdHkgfHwgXCJzeW5jXCIsXG4gIGF1dG9HZW5lcmF0ZUFycmF5S2V5czogb3B0aW9ucy5hdXRvR2VuZXJhdGVBcnJheUtleXMsXG4gIHNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBDcm9zc0RhdGFzZXRSZWZlcmVuY2VWYWxpZGF0aW9uXG59KSwgaXNSZXNwb25zZSA9IChldmVudCkgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiLCBnZXRCb2R5ID0gKGV2ZW50KSA9PiBldmVudC5ib2R5LCBpbmRleEJ5ID0gKGRvY3MsIGF0dHIpID0+IGRvY3MucmVkdWNlKChpbmRleGVkLCBkb2MpID0+IChpbmRleGVkW2F0dHIoZG9jKV0gPSBkb2MsIGluZGV4ZWQpLCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSksIGdldFF1ZXJ5U2l6ZUxpbWl0ID0gMTEyNjQ7XG5mdW5jdGlvbiBfZmV0Y2goY2xpZW50LCBodHRwUmVxdWVzdCwgX3N0ZWdhLCBxdWVyeSwgX3BhcmFtcyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qgc3RlZ2EgPSBcInN0ZWdhXCIgaW4gb3B0aW9ucyA/IHtcbiAgICAuLi5fc3RlZ2EgfHwge30sXG4gICAgLi4udHlwZW9mIG9wdGlvbnMuc3RlZ2EgPT0gXCJib29sZWFuXCIgPyB7IGVuYWJsZWQ6IG9wdGlvbnMuc3RlZ2EgfSA6IG9wdGlvbnMuc3RlZ2EgfHwge31cbiAgfSA6IF9zdGVnYSwgcGFyYW1zID0gc3RlZ2EuZW5hYmxlZCA/IHZlcmNlbFN0ZWdhQ2xlYW5BbGwoX3BhcmFtcykgOiBfcGFyYW1zLCBtYXBSZXNwb25zZSA9IG9wdGlvbnMuZmlsdGVyUmVzcG9uc2UgPT09ICExID8gKHJlcykgPT4gcmVzIDogKHJlcykgPT4gcmVzLnJlc3VsdCwgeyBjYWNoZSwgbmV4dCwgLi4ub3B0cyB9ID0ge1xuICAgIC8vIE9wdCBvdXQgb2Ygc2V0dGluZyBhIGBzaWduYWxgIG9uIGFuIGludGVybmFsIGBmZXRjaGAgaWYgb25lIGlzbid0IHByb3ZpZGVkLlxuICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIFJlYWN0IFNlcnZlciBDb21wb25lbnRzIHRvIGF2b2lkIG9wdGluZyBvdXQgb2YgUmVxdWVzdCBNZW1vaXphdGlvbi5cbiAgICB1c2VBYm9ydFNpZ25hbDogdHlwZW9mIG9wdGlvbnMuc2lnbmFsIDwgXCJ1XCIsXG4gICAgLy8gU2V0IGByZXN1bHRTb3VyY2VNYXAnIHdoZW4gc3RlZ2EgaXMgZW5hYmxlZCwgYXMgaXQncyByZXF1aXJlZCBmb3IgZW5jb2RpbmcuXG4gICAgcmVzdWx0U291cmNlTWFwOiBzdGVnYS5lbmFibGVkID8gXCJ3aXRoS2V5QXJyYXlTZWxlY3RvclwiIDogb3B0aW9ucy5yZXN1bHRTb3VyY2VNYXAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICAvLyBEZWZhdWx0IHRvIG5vdCByZXR1cm5pbmcgdGhlIHF1ZXJ5LCB1bmxlc3MgYGZpbHRlclJlc3BvbnNlYCBpcyBgZmFsc2VgLFxuICAgIC8vIG9yIGByZXR1cm5RdWVyeWAgaXMgZXhwbGljaXRseSBzZXQuIGB0cnVlYCBpcyB0aGUgZGVmYXVsdCBpbiBDb250ZW50IExha2UsIHNvIHNraXAgaWYgdHJ1dGh5XG4gICAgcmV0dXJuUXVlcnk6IG9wdGlvbnMuZmlsdGVyUmVzcG9uc2UgPT09ICExICYmIG9wdGlvbnMucmV0dXJuUXVlcnkgIT09ICExXG4gIH0sIHJlcU9wdHMgPSB0eXBlb2YgY2FjaGUgPCBcInVcIiB8fCB0eXBlb2YgbmV4dCA8IFwidVwiID8geyAuLi5vcHRzLCBmZXRjaDogeyBjYWNoZSwgbmV4dCB9IH0gOiBvcHRzLCAkcmVxdWVzdCA9IF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBcInF1ZXJ5XCIsIHsgcXVlcnksIHBhcmFtcyB9LCByZXFPcHRzKTtcbiAgcmV0dXJuIHN0ZWdhLmVuYWJsZWQgPyAkcmVxdWVzdC5waXBlKFxuICAgIGNvbWJpbmVMYXRlc3RXaXRoKFxuICAgICAgZnJvbShcbiAgICAgICAgaW1wb3J0KFwiLi9fY2h1bmtzLWVzL3N0ZWdhRW5jb2RlU291cmNlTWFwLmpzXCIpLnRoZW4oZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLmE7XG4gICAgICAgIH0pLnRoZW4oXG4gICAgICAgICAgKHsgc3RlZ2FFbmNvZGVTb3VyY2VNYXAgfSkgPT4gc3RlZ2FFbmNvZGVTb3VyY2VNYXBcbiAgICAgICAgKVxuICAgICAgKVxuICAgICksXG4gICAgbWFwKFxuICAgICAgKFtyZXMsIHN0ZWdhRW5jb2RlU291cmNlTWFwXSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdGVnYUVuY29kZVNvdXJjZU1hcChyZXMucmVzdWx0LCByZXMucmVzdWx0U291cmNlTWFwLCBzdGVnYSk7XG4gICAgICAgIHJldHVybiBtYXBSZXNwb25zZSh7IC4uLnJlcywgcmVzdWx0IH0pO1xuICAgICAgfVxuICAgIClcbiAgKSA6ICRyZXF1ZXN0LnBpcGUobWFwKG1hcFJlc3BvbnNlKSk7XG59XG5mdW5jdGlvbiBfZ2V0RG9jdW1lbnQoY2xpZW50LCBodHRwUmVxdWVzdCwgaWQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBvcHRpb25zID0geyB1cmk6IF9nZXREYXRhVXJsKGNsaWVudCwgXCJkb2NcIiwgaWQpLCBqc29uOiAhMCwgdGFnOiBvcHRzLnRhZyB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcCgoZXZlbnQpID0+IGV2ZW50LmJvZHkuZG9jdW1lbnRzICYmIGV2ZW50LmJvZHkuZG9jdW1lbnRzWzBdKVxuICApO1xufVxuZnVuY3Rpb24gX2dldERvY3VtZW50cyhjbGllbnQsIGh0dHBSZXF1ZXN0LCBpZHMsIG9wdHMgPSB7fSkge1xuICBjb25zdCBvcHRpb25zID0geyB1cmk6IF9nZXREYXRhVXJsKGNsaWVudCwgXCJkb2NcIiwgaWRzLmpvaW4oXCIsXCIpKSwganNvbjogITAsIHRhZzogb3B0cy50YWcgfTtcbiAgcmV0dXJuIF9yZXF1ZXN0T2JzZXJ2YWJsZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBvcHRpb25zKS5waXBlKFxuICAgIGZpbHRlcihpc1Jlc3BvbnNlKSxcbiAgICBtYXAoKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBpbmRleGVkID0gaW5kZXhCeShldmVudC5ib2R5LmRvY3VtZW50cyB8fCBbXSwgKGRvYykgPT4gZG9jLl9pZCk7XG4gICAgICByZXR1cm4gaWRzLm1hcCgoaWQpID0+IGluZGV4ZWRbaWRdIHx8IG51bGwpO1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBfY3JlYXRlSWZOb3RFeGlzdHMoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBvcHRpb25zKSB7XG4gIHJldHVybiByZXF1aXJlRG9jdW1lbnRJZChcImNyZWF0ZUlmTm90RXhpc3RzXCIsIGRvYyksIF9jcmVhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBcImNyZWF0ZUlmTm90RXhpc3RzXCIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZU9yUmVwbGFjZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHJlcXVpcmVEb2N1bWVudElkKFwiY3JlYXRlT3JSZXBsYWNlXCIsIGRvYyksIF9jcmVhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBcImNyZWF0ZU9yUmVwbGFjZVwiLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIF9kZWxldGUoY2xpZW50LCBodHRwUmVxdWVzdCwgc2VsZWN0aW9uLCBvcHRpb25zKSB7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoXG4gICAgY2xpZW50LFxuICAgIGh0dHBSZXF1ZXN0LFxuICAgIFwibXV0YXRlXCIsXG4gICAgeyBtdXRhdGlvbnM6IFt7IGRlbGV0ZTogZ2V0U2VsZWN0aW9uKHNlbGVjdGlvbikgfV0gfSxcbiAgICBvcHRpb25zXG4gICk7XG59XG5mdW5jdGlvbiBfbXV0YXRlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG11dGF0aW9ucywgb3B0aW9ucykge1xuICBsZXQgbXV0O1xuICBtdXRhdGlvbnMgaW5zdGFuY2VvZiBQYXRjaCB8fCBtdXRhdGlvbnMgaW5zdGFuY2VvZiBPYnNlcnZhYmxlUGF0Y2ggPyBtdXQgPSB7IHBhdGNoOiBtdXRhdGlvbnMuc2VyaWFsaXplKCkgfSA6IG11dGF0aW9ucyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uIHx8IG11dGF0aW9ucyBpbnN0YW5jZW9mIE9ic2VydmFibGVUcmFuc2FjdGlvbiA/IG11dCA9IG11dGF0aW9ucy5zZXJpYWxpemUoKSA6IG11dCA9IG11dGF0aW9ucztcbiAgY29uc3QgbXV0cyA9IEFycmF5LmlzQXJyYXkobXV0KSA/IG11dCA6IFttdXRdLCB0cmFuc2FjdGlvbklkID0gb3B0aW9ucyAmJiBvcHRpb25zLnRyYW5zYWN0aW9uSWQgfHwgdm9pZCAwO1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIFwibXV0YXRlXCIsIHsgbXV0YXRpb25zOiBtdXRzLCB0cmFuc2FjdGlvbklkIH0sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gX2RhdGFSZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIGVuZHBvaW50LCBib2R5LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgaXNNdXRhdGlvbiA9IGVuZHBvaW50ID09PSBcIm11dGF0ZVwiLCBpc1F1ZXJ5ID0gZW5kcG9pbnQgPT09IFwicXVlcnlcIiwgc3RyUXVlcnkgPSBpc011dGF0aW9uID8gXCJcIiA6IGVuY29kZVF1ZXJ5U3RyaW5nKGJvZHkpLCB1c2VHZXQgPSAhaXNNdXRhdGlvbiAmJiBzdHJRdWVyeS5sZW5ndGggPCBnZXRRdWVyeVNpemVMaW1pdCwgc3RyaW5nUXVlcnkgPSB1c2VHZXQgPyBzdHJRdWVyeSA6IFwiXCIsIHJldHVybkZpcnN0ID0gb3B0aW9ucy5yZXR1cm5GaXJzdCwgeyB0aW1lb3V0LCB0b2tlbiwgdGFnLCBoZWFkZXJzOiBoZWFkZXJzMiwgcmV0dXJuUXVlcnkgfSA9IG9wdGlvbnMsIHVyaSA9IF9nZXREYXRhVXJsKGNsaWVudCwgZW5kcG9pbnQsIHN0cmluZ1F1ZXJ5KSwgcmVxT3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6IHVzZUdldCA/IFwiR0VUXCIgOiBcIlBPU1RcIixcbiAgICB1cmksXG4gICAganNvbjogITAsXG4gICAgYm9keTogdXNlR2V0ID8gdm9pZCAwIDogYm9keSxcbiAgICBxdWVyeTogaXNNdXRhdGlvbiAmJiBnZXRNdXRhdGlvblF1ZXJ5KG9wdGlvbnMpLFxuICAgIHRpbWVvdXQsXG4gICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgdG9rZW4sXG4gICAgdGFnLFxuICAgIHJldHVyblF1ZXJ5LFxuICAgIHBlcnNwZWN0aXZlOiBvcHRpb25zLnBlcnNwZWN0aXZlLFxuICAgIHJlc3VsdFNvdXJjZU1hcDogb3B0aW9ucy5yZXN1bHRTb3VyY2VNYXAsXG4gICAgY2FuVXNlQ2RuOiBpc1F1ZXJ5LFxuICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgZmV0Y2g6IG9wdGlvbnMuZmV0Y2gsXG4gICAgdXNlQWJvcnRTaWduYWw6IG9wdGlvbnMudXNlQWJvcnRTaWduYWwsXG4gICAgdXNlQ2RuOiBvcHRpb25zLnVzZUNkblxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHJlcU9wdGlvbnMpLnBpcGUoXG4gICAgZmlsdGVyKGlzUmVzcG9uc2UpLFxuICAgIG1hcChnZXRCb2R5KSxcbiAgICBtYXAoKHJlcykgPT4ge1xuICAgICAgaWYgKCFpc011dGF0aW9uKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHJlcy5yZXN1bHRzIHx8IFtdO1xuICAgICAgaWYgKG9wdGlvbnMucmV0dXJuRG9jdW1lbnRzKVxuICAgICAgICByZXR1cm4gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uZG9jdW1lbnQgOiByZXN1bHRzLm1hcCgobXV0KSA9PiBtdXQuZG9jdW1lbnQpO1xuICAgICAgY29uc3Qga2V5ID0gcmV0dXJuRmlyc3QgPyBcImRvY3VtZW50SWRcIiA6IFwiZG9jdW1lbnRJZHNcIiwgaWRzID0gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uaWQgOiByZXN1bHRzLm1hcCgobXV0KSA9PiBtdXQuaWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzLnRyYW5zYWN0aW9uSWQsXG4gICAgICAgIHJlc3VsdHMsXG4gICAgICAgIFtrZXldOiBpZHNcbiAgICAgIH07XG4gICAgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBvcCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IG11dGF0aW9uID0geyBbb3BdOiBkb2MgfSwgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyByZXR1cm5GaXJzdDogITAsIHJldHVybkRvY3VtZW50czogITAgfSwgb3B0aW9ucyk7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJtdXRhdGVcIiwgeyBtdXRhdGlvbnM6IFttdXRhdGlvbl0gfSwgb3B0cyk7XG59XG5mdW5jdGlvbiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB1cmkgPSBvcHRpb25zLnVybCB8fCBvcHRpb25zLnVyaSwgY29uZmlnID0gY2xpZW50LmNvbmZpZygpLCBjYW5Vc2VDZG4gPSB0eXBlb2Ygb3B0aW9ucy5jYW5Vc2VDZG4gPiBcInVcIiA/IFtcIkdFVFwiLCBcIkhFQURcIl0uaW5kZXhPZihvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKSA+PSAwICYmIHVyaS5pbmRleE9mKFwiL2RhdGEvXCIpID09PSAwIDogb3B0aW9ucy5jYW5Vc2VDZG47XG4gIGxldCB1c2VDZG4gPSAoKF9hID0gb3B0aW9ucy51c2VDZG4pICE9IG51bGwgPyBfYSA6IGNvbmZpZy51c2VDZG4pICYmIGNhblVzZUNkbjtcbiAgY29uc3QgdGFnID0gb3B0aW9ucy50YWcgJiYgY29uZmlnLnJlcXVlc3RUYWdQcmVmaXggPyBbY29uZmlnLnJlcXVlc3RUYWdQcmVmaXgsIG9wdGlvbnMudGFnXS5qb2luKFwiLlwiKSA6IG9wdGlvbnMudGFnIHx8IGNvbmZpZy5yZXF1ZXN0VGFnUHJlZml4O1xuICBpZiAodGFnICYmIG9wdGlvbnMudGFnICE9PSBudWxsICYmIChvcHRpb25zLnF1ZXJ5ID0geyB0YWc6IHJlcXVlc3RUYWcodGFnKSwgLi4ub3B0aW9ucy5xdWVyeSB9KSwgW1wiR0VUXCIsIFwiSEVBRFwiLCBcIlBPU1RcIl0uaW5kZXhPZihvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKSA+PSAwICYmIHVyaS5pbmRleE9mKFwiL2RhdGEvcXVlcnkvXCIpID09PSAwKSB7XG4gICAgY29uc3QgcmVzdWx0U291cmNlTWFwID0gKF9iID0gb3B0aW9ucy5yZXN1bHRTb3VyY2VNYXApICE9IG51bGwgPyBfYiA6IGNvbmZpZy5yZXN1bHRTb3VyY2VNYXA7XG4gICAgcmVzdWx0U291cmNlTWFwICE9PSB2b2lkIDAgJiYgcmVzdWx0U291cmNlTWFwICE9PSAhMSAmJiAob3B0aW9ucy5xdWVyeSA9IHsgcmVzdWx0U291cmNlTWFwLCAuLi5vcHRpb25zLnF1ZXJ5IH0pO1xuICAgIGNvbnN0IHBlcnNwZWN0aXZlID0gb3B0aW9ucy5wZXJzcGVjdGl2ZSB8fCBjb25maWcucGVyc3BlY3RpdmU7XG4gICAgdHlwZW9mIHBlcnNwZWN0aXZlID09IFwic3RyaW5nXCIgJiYgcGVyc3BlY3RpdmUgIT09IFwicmF3XCIgJiYgKHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUocGVyc3BlY3RpdmUpLCBvcHRpb25zLnF1ZXJ5ID0geyBwZXJzcGVjdGl2ZSwgLi4ub3B0aW9ucy5xdWVyeSB9LCBwZXJzcGVjdGl2ZSA9PT0gXCJwcmV2aWV3RHJhZnRzXCIgJiYgdXNlQ2RuICYmICh1c2VDZG4gPSAhMSwgcHJpbnRDZG5QcmV2aWV3RHJhZnRzV2FybmluZygpKSksIG9wdGlvbnMucmV0dXJuUXVlcnkgPT09ICExICYmIChvcHRpb25zLnF1ZXJ5ID0geyByZXR1cm5RdWVyeTogXCJmYWxzZVwiLCAuLi5vcHRpb25zLnF1ZXJ5IH0pO1xuICB9XG4gIGNvbnN0IHJlcU9wdGlvbnMgPSByZXF1ZXN0T3B0aW9ucyhcbiAgICBjb25maWcsXG4gICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdXJsOiBfZ2V0VXJsKGNsaWVudCwgdXJpLCB1c2VDZG4pXG4gICAgfSlcbiAgKSwgcmVxdWVzdCA9IG5ldyBPYnNlcnZhYmxlKFxuICAgIChzdWJzY3JpYmVyKSA9PiBodHRwUmVxdWVzdChyZXFPcHRpb25zLCBjb25maWcucmVxdWVzdGVyKS5zdWJzY3JpYmUoc3Vic2NyaWJlcilcbiAgKTtcbiAgcmV0dXJuIG9wdGlvbnMuc2lnbmFsID8gcmVxdWVzdC5waXBlKF93aXRoQWJvcnRTaWduYWwob3B0aW9ucy5zaWduYWwpKSA6IHJlcXVlc3Q7XG59XG5mdW5jdGlvbiBfcmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykucGlwZShcbiAgICBmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC50eXBlID09PSBcInJlc3BvbnNlXCIpLFxuICAgIG1hcCgoZXZlbnQpID0+IGV2ZW50LmJvZHkpXG4gICk7XG59XG5mdW5jdGlvbiBfZ2V0RGF0YVVybChjbGllbnQsIG9wZXJhdGlvbiwgcGF0aCkge1xuICBjb25zdCBjb25maWcgPSBjbGllbnQuY29uZmlnKCksIGNhdGFsb2cgPSBoYXNEYXRhc2V0KGNvbmZpZyksIGJhc2VVcmkgPSBgLyR7b3BlcmF0aW9ufS8ke2NhdGFsb2d9YDtcbiAgcmV0dXJuIGAvZGF0YSR7cGF0aCA/IGAke2Jhc2VVcml9LyR7cGF0aH1gIDogYmFzZVVyaX1gLnJlcGxhY2UoL1xcLygkfFxcPykvLCBcIiQxXCIpO1xufVxuZnVuY3Rpb24gX2dldFVybChjbGllbnQsIHVyaSwgY2FuVXNlQ2RuID0gITEpIHtcbiAgY29uc3QgeyB1cmwsIGNkblVybCB9ID0gY2xpZW50LmNvbmZpZygpO1xuICByZXR1cm4gYCR7Y2FuVXNlQ2RuID8gY2RuVXJsIDogdXJsfS8ke3VyaS5yZXBsYWNlKC9eXFwvLywgXCJcIil9YDtcbn1cbmZ1bmN0aW9uIF93aXRoQWJvcnRTaWduYWwoc2lnbmFsKSB7XG4gIHJldHVybiAoaW5wdXQpID0+IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgIGNvbnN0IGFib3J0ID0gKCkgPT4gb2JzZXJ2ZXIuZXJyb3IoX2NyZWF0ZUFib3J0RXJyb3Ioc2lnbmFsKSk7XG4gICAgaWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgYWJvcnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gaW5wdXQuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICByZXR1cm4gc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCksICgpID0+IHtcbiAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpLCBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICB9KTtcbn1cbmNvbnN0IGlzRG9tRXhjZXB0aW9uU3VwcG9ydGVkID0gISFnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbjtcbmZ1bmN0aW9uIF9jcmVhdGVBYm9ydEVycm9yKHNpZ25hbCkge1xuICB2YXIgX2EsIF9iO1xuICBpZiAoaXNEb21FeGNlcHRpb25TdXBwb3J0ZWQpXG4gICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oKF9hID0gc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwucmVhc29uKSAhPSBudWxsID8gX2EgOiBcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsIFwiQWJvcnRFcnJvclwiKTtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKF9iID0gc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwucmVhc29uKSAhPSBudWxsID8gX2IgOiBcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIpO1xuICByZXR1cm4gZXJyb3IubmFtZSA9IFwiQWJvcnRFcnJvclwiLCBlcnJvcjtcbn1cbnZhciBfX2FjY2Vzc0NoZWNrJDQgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufSwgX19wcml2YXRlR2V0JDQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2skNChvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSksIF9fcHJpdmF0ZUFkZCQ0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufSwgX19wcml2YXRlU2V0JDQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrJDQob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSksIF9jbGllbnQkMywgX2h0dHBSZXF1ZXN0JDQ7XG5jbGFzcyBPYnNlcnZhYmxlQXNzZXRzQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIF9fcHJpdmF0ZUFkZCQ0KHRoaXMsIF9jbGllbnQkMywgdm9pZCAwKSwgX19wcml2YXRlQWRkJDQodGhpcywgX2h0dHBSZXF1ZXN0JDQsIHZvaWQgMCksIF9fcHJpdmF0ZVNldCQ0KHRoaXMsIF9jbGllbnQkMywgY2xpZW50KSwgX19wcml2YXRlU2V0JDQodGhpcywgX2h0dHBSZXF1ZXN0JDQsIGh0dHBSZXF1ZXN0KTtcbiAgfVxuICB1cGxvYWQoYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF91cGxvYWQoX19wcml2YXRlR2V0JDQodGhpcywgX2NsaWVudCQzKSwgX19wcml2YXRlR2V0JDQodGhpcywgX2h0dHBSZXF1ZXN0JDQpLCBhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpO1xuICB9XG59XG5fY2xpZW50JDMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX2h0dHBSZXF1ZXN0JDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfY2xpZW50MiQzLCBfaHR0cFJlcXVlc3QyJDQ7XG5jbGFzcyBBc3NldHNDbGllbnQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgX19wcml2YXRlQWRkJDQodGhpcywgX2NsaWVudDIkMywgdm9pZCAwKSwgX19wcml2YXRlQWRkJDQodGhpcywgX2h0dHBSZXF1ZXN0MiQ0LCB2b2lkIDApLCBfX3ByaXZhdGVTZXQkNCh0aGlzLCBfY2xpZW50MiQzLCBjbGllbnQpLCBfX3ByaXZhdGVTZXQkNCh0aGlzLCBfaHR0cFJlcXVlc3QyJDQsIGh0dHBSZXF1ZXN0KTtcbiAgfVxuICB1cGxvYWQoYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2JzZXJ2YWJsZTIgPSBfdXBsb2FkKF9fcHJpdmF0ZUdldCQ0KHRoaXMsIF9jbGllbnQyJDMpLCBfX3ByaXZhdGVHZXQkNCh0aGlzLCBfaHR0cFJlcXVlc3QyJDQpLCBhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgb2JzZXJ2YWJsZTIucGlwZShcbiAgICAgICAgZmlsdGVyKChldmVudCkgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiKSxcbiAgICAgICAgbWFwKFxuICAgICAgICAgIChldmVudCkgPT4gZXZlbnQuYm9keS5kb2N1bWVudFxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuX2NsaWVudDIkMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfaHR0cFJlcXVlc3QyJDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIF91cGxvYWQoY2xpZW50LCBodHRwUmVxdWVzdCwgYXNzZXRUeXBlLCBib2R5LCBvcHRzID0ge30pIHtcbiAgdmFsaWRhdGVBc3NldFR5cGUoYXNzZXRUeXBlKTtcbiAgbGV0IG1ldGEgPSBvcHRzLmV4dHJhY3QgfHwgdm9pZCAwO1xuICBtZXRhICYmICFtZXRhLmxlbmd0aCAmJiAobWV0YSA9IFtcIm5vbmVcIl0pO1xuICBjb25zdCBkYXRhc2V0MiA9IGhhc0RhdGFzZXQoY2xpZW50LmNvbmZpZygpKSwgYXNzZXRFbmRwb2ludCA9IGFzc2V0VHlwZSA9PT0gXCJpbWFnZVwiID8gXCJpbWFnZXNcIiA6IFwiZmlsZXNcIiwgb3B0aW9ucyA9IG9wdGlvbnNGcm9tRmlsZShvcHRzLCBib2R5KSwgeyB0YWcsIGxhYmVsLCB0aXRsZSwgZGVzY3JpcHRpb24sIGNyZWRpdExpbmUsIGZpbGVuYW1lLCBzb3VyY2UgfSA9IG9wdGlvbnMsIHF1ZXJ5ID0ge1xuICAgIGxhYmVsLFxuICAgIHRpdGxlLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIGZpbGVuYW1lLFxuICAgIG1ldGEsXG4gICAgY3JlZGl0TGluZVxuICB9O1xuICByZXR1cm4gc291cmNlICYmIChxdWVyeS5zb3VyY2VJZCA9IHNvdXJjZS5pZCwgcXVlcnkuc291cmNlTmFtZSA9IHNvdXJjZS5uYW1lLCBxdWVyeS5zb3VyY2VVcmwgPSBzb3VyY2UudXJsKSwgX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHtcbiAgICB0YWcsXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfHwgMCxcbiAgICB1cmk6IGAvYXNzZXRzLyR7YXNzZXRFbmRwb2ludH0vJHtkYXRhc2V0Mn1gLFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuY29udGVudFR5cGUgPyB7IFwiQ29udGVudC1UeXBlXCI6IG9wdGlvbnMuY29udGVudFR5cGUgfSA6IHt9LFxuICAgIHF1ZXJ5LFxuICAgIGJvZHlcbiAgfSk7XG59XG5mdW5jdGlvbiBvcHRpb25zRnJvbUZpbGUob3B0cywgZmlsZSkge1xuICByZXR1cm4gdHlwZW9mIEZpbGUgPiBcInVcIiB8fCAhKGZpbGUgaW5zdGFuY2VvZiBGaWxlKSA/IG9wdHMgOiBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIGZpbGVuYW1lOiBvcHRzLnByZXNlcnZlRmlsZW5hbWUgPT09ICExID8gdm9pZCAwIDogZmlsZS5uYW1lLFxuICAgICAgY29udGVudFR5cGU6IGZpbGUudHlwZVxuICAgIH0sXG4gICAgb3B0c1xuICApO1xufVxudmFyIGRlZmF1bHRzID0gKG9iaiwgZGVmYXVsdHMyKSA9PiBPYmplY3Qua2V5cyhkZWZhdWx0czIpLmNvbmNhdChPYmplY3Qua2V5cyhvYmopKS5yZWR1Y2UoKHRhcmdldCwgcHJvcCkgPT4gKHRhcmdldFtwcm9wXSA9IHR5cGVvZiBvYmpbcHJvcF0gPiBcInVcIiA/IGRlZmF1bHRzMltwcm9wXSA6IG9ialtwcm9wXSwgdGFyZ2V0KSwge30pO1xuY29uc3QgcGljayA9IChvYmosIHByb3BzKSA9PiBwcm9wcy5yZWR1Y2UoKHNlbGVjdGlvbiwgcHJvcCkgPT4gKHR5cGVvZiBvYmpbcHJvcF0gPiBcInVcIiB8fCAoc2VsZWN0aW9uW3Byb3BdID0gb2JqW3Byb3BdKSwgc2VsZWN0aW9uKSwge30pLCBNQVhfVVJMX0xFTkdUSCA9IDE0ODAwLCBwb3NzaWJsZU9wdGlvbnMgPSBbXG4gIFwiaW5jbHVkZVByZXZpb3VzUmV2aXNpb25cIixcbiAgXCJpbmNsdWRlUmVzdWx0XCIsXG4gIFwidmlzaWJpbGl0eVwiLFxuICBcImVmZmVjdEZvcm1hdFwiLFxuICBcInRhZ1wiXG5dLCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaW5jbHVkZVJlc3VsdDogITBcbn07XG5mdW5jdGlvbiBfbGlzdGVuKHF1ZXJ5LCBwYXJhbXMsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IHVybCwgdG9rZW4sIHdpdGhDcmVkZW50aWFscywgcmVxdWVzdFRhZ1ByZWZpeCB9ID0gdGhpcy5jb25maWcoKSwgdGFnID0gb3B0cy50YWcgJiYgcmVxdWVzdFRhZ1ByZWZpeCA/IFtyZXF1ZXN0VGFnUHJlZml4LCBvcHRzLnRhZ10uam9pbihcIi5cIikgOiBvcHRzLnRhZywgb3B0aW9ucyA9IHsgLi4uZGVmYXVsdHMob3B0cywgZGVmYXVsdE9wdGlvbnMpLCB0YWcgfSwgbGlzdGVuT3B0cyA9IHBpY2sob3B0aW9ucywgcG9zc2libGVPcHRpb25zKSwgcXMgPSBlbmNvZGVRdWVyeVN0cmluZyh7IHF1ZXJ5LCBwYXJhbXMsIG9wdGlvbnM6IHsgdGFnLCAuLi5saXN0ZW5PcHRzIH0gfSksIHVyaSA9IGAke3VybH0ke19nZXREYXRhVXJsKHRoaXMsIFwibGlzdGVuXCIsIHFzKX1gO1xuICBpZiAodXJpLmxlbmd0aCA+IE1BWF9VUkxfTEVOR1RIKVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLmVycm9yKG5ldyBFcnJvcihcIlF1ZXJ5IHRvbyBsYXJnZSBmb3IgbGlzdGVuZXJcIikpKTtcbiAgY29uc3QgbGlzdGVuRm9yID0gb3B0aW9ucy5ldmVudHMgPyBvcHRpb25zLmV2ZW50cyA6IFtcIm11dGF0aW9uXCJdLCBzaG91bGRFbWl0UmVjb25uZWN0ID0gbGlzdGVuRm9yLmluZGV4T2YoXCJyZWNvbm5lY3RcIikgIT09IC0xLCBlc09wdGlvbnMgPSB7fTtcbiAgcmV0dXJuICh0b2tlbiB8fCB3aXRoQ3JlZGVudGlhbHMpICYmIChlc09wdGlvbnMud2l0aENyZWRlbnRpYWxzID0gITApLCB0b2tlbiAmJiAoZXNPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgfSksIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgIGxldCBlcztcbiAgICBnZXRFdmVudFNvdXJjZSgpLnRoZW4oKGV2ZW50U291cmNlKSA9PiB7XG4gICAgICBlcyA9IGV2ZW50U291cmNlO1xuICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcbiAgICAgIG9ic2VydmVyLmVycm9yKHJlYXNvbiksIHN0b3AoKTtcbiAgICB9KTtcbiAgICBsZXQgcmVjb25uZWN0VGltZXIsIHN0b3BwZWQgPSAhMTtcbiAgICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgc3RvcHBlZCB8fCAoZW1pdFJlY29ubmVjdCgpLCAhc3RvcHBlZCAmJiBlcy5yZWFkeVN0YXRlID09PSBlcy5DTE9TRUQgJiYgKHVuc3Vic2NyaWJlKCksIGNsZWFyVGltZW91dChyZWNvbm5lY3RUaW1lciksIHJlY29ubmVjdFRpbWVyID0gc2V0VGltZW91dChvcGVuLCAxMDApKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ2hhbm5lbEVycm9yKGVycikge1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IoY29vZXJjZUVycm9yKGVycikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZ0KSB7XG4gICAgICBjb25zdCBldmVudCA9IHBhcnNlRXZlbnQoZXZ0KTtcbiAgICAgIHJldHVybiBldmVudCBpbnN0YW5jZW9mIEVycm9yID8gb2JzZXJ2ZXIuZXJyb3IoZXZlbnQpIDogb2JzZXJ2ZXIubmV4dChldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgIHN0b3BwZWQgPSAhMCwgdW5zdWJzY3JpYmUoKSwgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBlcyAmJiAoZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpLCBlcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbm5lbEVycm9yXCIsIG9uQ2hhbm5lbEVycm9yKSwgZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRpc2Nvbm5lY3RcIiwgb25EaXNjb25uZWN0KSwgbGlzdGVuRm9yLmZvckVhY2goKHR5cGUpID0+IGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgb25NZXNzYWdlKSksIGVzLmNsb3NlKCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0UmVjb25uZWN0KCkge1xuICAgICAgc2hvdWxkRW1pdFJlY29ubmVjdCAmJiBvYnNlcnZlci5uZXh0KHsgdHlwZTogXCJyZWNvbm5lY3RcIiB9KTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2UoKSB7XG4gICAgICBjb25zdCB7IGRlZmF1bHQ6IEV2ZW50U291cmNlIH0gPSBhd2FpdCBpbXBvcnQoXCJAc2FuaXR5L2V2ZW50c291cmNlXCIpLCBldnMgPSBuZXcgRXZlbnRTb3VyY2UodXJpLCBlc09wdGlvbnMpO1xuICAgICAgcmV0dXJuIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvciksIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbm5lbEVycm9yXCIsIG9uQ2hhbm5lbEVycm9yKSwgZXZzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCksIGxpc3RlbkZvci5mb3JFYWNoKCh0eXBlKSA9PiBldnMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UpKSwgZXZzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgZ2V0RXZlbnRTb3VyY2UoKS50aGVuKChldmVudFNvdXJjZSkgPT4ge1xuICAgICAgICBlcyA9IGV2ZW50U291cmNlO1xuICAgICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xuICAgICAgICBvYnNlcnZlci5lcnJvcihyZWFzb24pLCBzdG9wKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHN0b3BwZWQgPSAhMCwgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3A7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VFdmVudChldmVudCkge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhICYmIEpTT04ucGFyc2UoZXZlbnQuZGF0YSkgfHwge307XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB0eXBlOiBldmVudC50eXBlIH0sIGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG59XG5mdW5jdGlvbiBjb29lcmNlRXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcilcbiAgICByZXR1cm4gZXJyO1xuICBjb25zdCBldnQgPSBwYXJzZUV2ZW50KGVycik7XG4gIHJldHVybiBldnQgaW5zdGFuY2VvZiBFcnJvciA/IGV2dCA6IG5ldyBFcnJvcihleHRyYWN0RXJyb3JNZXNzYWdlKGV2dCkpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEVycm9yTWVzc2FnZShlcnIpIHtcbiAgcmV0dXJuIGVyci5lcnJvciA/IGVyci5lcnJvci5kZXNjcmlwdGlvbiA/IGVyci5lcnJvci5kZXNjcmlwdGlvbiA6IHR5cGVvZiBlcnIuZXJyb3IgPT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IEpTT04uc3RyaW5naWZ5KGVyci5lcnJvciwgbnVsbCwgMikgOiBlcnIubWVzc2FnZSB8fCBcIlVua25vd24gbGlzdGVuZXIgZXJyb3JcIjtcbn1cbnZhciBfX2FjY2Vzc0NoZWNrJDMgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufSwgX19wcml2YXRlR2V0JDMgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2skMyhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSksIF9fcHJpdmF0ZUFkZCQzID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufSwgX19wcml2YXRlU2V0JDMgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrJDMob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSksIF9jbGllbnQkMiwgX2h0dHBSZXF1ZXN0JDM7XG5jbGFzcyBPYnNlcnZhYmxlRGF0YXNldHNDbGllbnQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgX19wcml2YXRlQWRkJDModGhpcywgX2NsaWVudCQyLCB2b2lkIDApLCBfX3ByaXZhdGVBZGQkMyh0aGlzLCBfaHR0cFJlcXVlc3QkMywgdm9pZCAwKSwgX19wcml2YXRlU2V0JDModGhpcywgX2NsaWVudCQyLCBjbGllbnQpLCBfX3ByaXZhdGVTZXQkMyh0aGlzLCBfaHR0cFJlcXVlc3QkMywgaHR0cFJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBjcmVhdGVcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZGF0YXNldFxuICAgKi9cbiAgY3JlYXRlKG5hbWUyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9tb2RpZnkoX19wcml2YXRlR2V0JDModGhpcywgX2NsaWVudCQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0JDMpLCBcIlBVVFwiLCBuYW1lMiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXQgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGVkaXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOZXcgb3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGVkaXQobmFtZTIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX21vZGlmeShfX3ByaXZhdGVHZXQkMyh0aGlzLCBfY2xpZW50JDIpLCBfX3ByaXZhdGVHZXQkMyh0aGlzLCBfaHR0cFJlcXVlc3QkMyksIFwiUEFUQ0hcIiwgbmFtZTIsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKG5hbWUyKSB7XG4gICAgcmV0dXJuIF9tb2RpZnkoX19wcml2YXRlR2V0JDModGhpcywgX2NsaWVudCQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0JDMpLCBcIkRFTEVURVwiLCBuYW1lMik7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBkYXRhc2V0cyBmb3IgdGhlIGNvbmZpZ3VyZWQgcHJvamVjdFxuICAgKi9cbiAgbGlzdCgpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QoX19wcml2YXRlR2V0JDModGhpcywgX2NsaWVudCQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0JDMpLCB7XG4gICAgICB1cmk6IFwiL2RhdGFzZXRzXCIsXG4gICAgICB0YWc6IG51bGxcbiAgICB9KTtcbiAgfVxufVxuX2NsaWVudCQyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9odHRwUmVxdWVzdCQzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgX2NsaWVudDIkMiwgX2h0dHBSZXF1ZXN0MiQzO1xuY2xhc3MgRGF0YXNldHNDbGllbnQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgX19wcml2YXRlQWRkJDModGhpcywgX2NsaWVudDIkMiwgdm9pZCAwKSwgX19wcml2YXRlQWRkJDModGhpcywgX2h0dHBSZXF1ZXN0MiQzLCB2b2lkIDApLCBfX3ByaXZhdGVTZXQkMyh0aGlzLCBfY2xpZW50MiQyLCBjbGllbnQpLCBfX3ByaXZhdGVTZXQkMyh0aGlzLCBfaHR0cFJlcXVlc3QyJDMsIGh0dHBSZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGNyZWF0ZShuYW1lMiwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX21vZGlmeShfX3ByaXZhdGVHZXQkMyh0aGlzLCBfY2xpZW50MiQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0MiQzKSwgXCJQVVRcIiwgbmFtZTIsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRWRpdCBhIGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZWRpdFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5ldyBvcHRpb25zIGZvciB0aGUgZGF0YXNldFxuICAgKi9cbiAgZWRpdChuYW1lMiwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX21vZGlmeShfX3ByaXZhdGVHZXQkMyh0aGlzLCBfY2xpZW50MiQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0MiQzKSwgXCJQQVRDSFwiLCBuYW1lMiwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGRlbGV0ZVxuICAgKi9cbiAgZGVsZXRlKG5hbWUyKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX21vZGlmeShfX3ByaXZhdGVHZXQkMyh0aGlzLCBfY2xpZW50MiQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0MiQzKSwgXCJERUxFVEVcIiwgbmFtZTIpKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGRhdGFzZXRzIGZvciB0aGUgY29uZmlndXJlZCBwcm9qZWN0XG4gICAqL1xuICBsaXN0KCkge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX3JlcXVlc3QoX19wcml2YXRlR2V0JDModGhpcywgX2NsaWVudDIkMiksIF9fcHJpdmF0ZUdldCQzKHRoaXMsIF9odHRwUmVxdWVzdDIkMyksIHsgdXJpOiBcIi9kYXRhc2V0c1wiLCB0YWc6IG51bGwgfSlcbiAgICApO1xuICB9XG59XG5fY2xpZW50MiQyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9odHRwUmVxdWVzdDIkMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gX21vZGlmeShjbGllbnQsIGh0dHBSZXF1ZXN0LCBtZXRob2QsIG5hbWUyLCBvcHRpb25zKSB7XG4gIHJldHVybiBkYXRhc2V0KG5hbWUyKSwgX3JlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwge1xuICAgIG1ldGhvZCxcbiAgICB1cmk6IGAvZGF0YXNldHMvJHtuYW1lMn1gLFxuICAgIGJvZHk6IG9wdGlvbnMsXG4gICAgdGFnOiBudWxsXG4gIH0pO1xufVxudmFyIF9fYWNjZXNzQ2hlY2skMiA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59LCBfX3ByaXZhdGVHZXQkMiA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayQyKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKSwgX19wcml2YXRlQWRkJDIgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59LCBfX3ByaXZhdGVTZXQkMiA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2skMihvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKSwgX2NsaWVudCQxLCBfaHR0cFJlcXVlc3QkMjtcbmNsYXNzIE9ic2VydmFibGVQcm9qZWN0c0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICBfX3ByaXZhdGVBZGQkMih0aGlzLCBfY2xpZW50JDEsIHZvaWQgMCksIF9fcHJpdmF0ZUFkZCQyKHRoaXMsIF9odHRwUmVxdWVzdCQyLCB2b2lkIDApLCBfX3ByaXZhdGVTZXQkMih0aGlzLCBfY2xpZW50JDEsIGNsaWVudCksIF9fcHJpdmF0ZVNldCQyKHRoaXMsIF9odHRwUmVxdWVzdCQyLCBodHRwUmVxdWVzdCk7XG4gIH1cbiAgbGlzdChvcHRpb25zKSB7XG4gICAgY29uc3QgdXJpID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5jbHVkZU1lbWJlcnMpID09PSAhMSA/IFwiL3Byb2plY3RzP2luY2x1ZGVNZW1iZXJzPWZhbHNlXCIgOiBcIi9wcm9qZWN0c1wiO1xuICAgIHJldHVybiBfcmVxdWVzdChfX3ByaXZhdGVHZXQkMih0aGlzLCBfY2xpZW50JDEpLCBfX3ByaXZhdGVHZXQkMih0aGlzLCBfaHR0cFJlcXVlc3QkMiksIHsgdXJpIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2plY3QgYnkgcHJvamVjdCBJRFxuICAgKlxuICAgKiBAcGFyYW0gcHJvamVjdElkIC0gSUQgb2YgdGhlIHByb2plY3QgdG8gZmV0Y2hcbiAgICovXG4gIGdldEJ5SWQocHJvamVjdElkMikge1xuICAgIHJldHVybiBfcmVxdWVzdChfX3ByaXZhdGVHZXQkMih0aGlzLCBfY2xpZW50JDEpLCBfX3ByaXZhdGVHZXQkMih0aGlzLCBfaHR0cFJlcXVlc3QkMiksIHsgdXJpOiBgL3Byb2plY3RzLyR7cHJvamVjdElkMn1gIH0pO1xuICB9XG59XG5fY2xpZW50JDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX2h0dHBSZXF1ZXN0JDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfY2xpZW50MiQxLCBfaHR0cFJlcXVlc3QyJDI7XG5jbGFzcyBQcm9qZWN0c0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICBfX3ByaXZhdGVBZGQkMih0aGlzLCBfY2xpZW50MiQxLCB2b2lkIDApLCBfX3ByaXZhdGVBZGQkMih0aGlzLCBfaHR0cFJlcXVlc3QyJDIsIHZvaWQgMCksIF9fcHJpdmF0ZVNldCQyKHRoaXMsIF9jbGllbnQyJDEsIGNsaWVudCksIF9fcHJpdmF0ZVNldCQyKHRoaXMsIF9odHRwUmVxdWVzdDIkMiwgaHR0cFJlcXVlc3QpO1xuICB9XG4gIGxpc3Qob3B0aW9ucykge1xuICAgIGNvbnN0IHVyaSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVNZW1iZXJzKSA9PT0gITEgPyBcIi9wcm9qZWN0cz9pbmNsdWRlTWVtYmVycz1mYWxzZVwiIDogXCIvcHJvamVjdHNcIjtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfcmVxdWVzdChfX3ByaXZhdGVHZXQkMih0aGlzLCBfY2xpZW50MiQxKSwgX19wcml2YXRlR2V0JDIodGhpcywgX2h0dHBSZXF1ZXN0MiQyKSwgeyB1cmkgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2plY3QgYnkgcHJvamVjdCBJRFxuICAgKlxuICAgKiBAcGFyYW0gcHJvamVjdElkIC0gSUQgb2YgdGhlIHByb2plY3QgdG8gZmV0Y2hcbiAgICovXG4gIGdldEJ5SWQocHJvamVjdElkMikge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX3JlcXVlc3QoX19wcml2YXRlR2V0JDIodGhpcywgX2NsaWVudDIkMSksIF9fcHJpdmF0ZUdldCQyKHRoaXMsIF9odHRwUmVxdWVzdDIkMiksIHsgdXJpOiBgL3Byb2plY3RzLyR7cHJvamVjdElkMn1gIH0pXG4gICAgKTtcbiAgfVxufVxuX2NsaWVudDIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBfaHR0cFJlcXVlc3QyJDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBfX2FjY2Vzc0NoZWNrJDEgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufSwgX19wcml2YXRlR2V0JDEgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4gKF9fYWNjZXNzQ2hlY2skMShvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSwgZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKSksIF9fcHJpdmF0ZUFkZCQxID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufSwgX19wcml2YXRlU2V0JDEgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrJDEob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpLCB2YWx1ZSksIF9jbGllbnQsIF9odHRwUmVxdWVzdCQxO1xuY2xhc3MgT2JzZXJ2YWJsZVVzZXJzQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIF9fcHJpdmF0ZUFkZCQxKHRoaXMsIF9jbGllbnQsIHZvaWQgMCksIF9fcHJpdmF0ZUFkZCQxKHRoaXMsIF9odHRwUmVxdWVzdCQxLCB2b2lkIDApLCBfX3ByaXZhdGVTZXQkMSh0aGlzLCBfY2xpZW50LCBjbGllbnQpLCBfX3ByaXZhdGVTZXQkMSh0aGlzLCBfaHR0cFJlcXVlc3QkMSwgaHR0cFJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHVzZXIgYnkgdXNlciBJRFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBVc2VyIElEIG9mIHRoZSB1c2VyIHRvIGZldGNoLiBJZiBgbWVgIGlzIHByb3ZpZGVkLCBhIG1pbmltYWwgcmVzcG9uc2UgaW5jbHVkaW5nIHRoZSB1c2VycyByb2xlIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfcmVxdWVzdChcbiAgICAgIF9fcHJpdmF0ZUdldCQxKHRoaXMsIF9jbGllbnQpLFxuICAgICAgX19wcml2YXRlR2V0JDEodGhpcywgX2h0dHBSZXF1ZXN0JDEpLFxuICAgICAgeyB1cmk6IGAvdXNlcnMvJHtpZH1gIH1cbiAgICApO1xuICB9XG59XG5fY2xpZW50ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9odHRwUmVxdWVzdCQxID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgX2NsaWVudDIsIF9odHRwUmVxdWVzdDIkMTtcbmNsYXNzIFVzZXJzQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIF9fcHJpdmF0ZUFkZCQxKHRoaXMsIF9jbGllbnQyLCB2b2lkIDApLCBfX3ByaXZhdGVBZGQkMSh0aGlzLCBfaHR0cFJlcXVlc3QyJDEsIHZvaWQgMCksIF9fcHJpdmF0ZVNldCQxKHRoaXMsIF9jbGllbnQyLCBjbGllbnQpLCBfX3ByaXZhdGVTZXQkMSh0aGlzLCBfaHR0cFJlcXVlc3QyJDEsIGh0dHBSZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSB1c2VyIGJ5IHVzZXIgSURcbiAgICpcbiAgICogQHBhcmFtIGlkIC0gVXNlciBJRCBvZiB0aGUgdXNlciB0byBmZXRjaC4gSWYgYG1lYCBpcyBwcm92aWRlZCwgYSBtaW5pbWFsIHJlc3BvbnNlIGluY2x1ZGluZyB0aGUgdXNlcnMgcm9sZSBpcyByZXR1cm5lZC5cbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9yZXF1ZXN0KF9fcHJpdmF0ZUdldCQxKHRoaXMsIF9jbGllbnQyKSwgX19wcml2YXRlR2V0JDEodGhpcywgX2h0dHBSZXF1ZXN0MiQxKSwge1xuICAgICAgICB1cmk6IGAvdXNlcnMvJHtpZH1gXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbl9jbGllbnQyID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9odHRwUmVxdWVzdDIkMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWUsIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiAoX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpLCB2YWx1ZSksIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufSwgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IChfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpLCBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopKSwgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufSwgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiAoX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLCBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSksIHZhbHVlKSwgX2NsaWVudENvbmZpZywgX2h0dHBSZXF1ZXN0O1xuY29uc3QgX09ic2VydmFibGVTYW5pdHlDbGllbnQgPSBjbGFzcyBfT2JzZXJ2YWJsZVNhbml0eUNsaWVudDIge1xuICBjb25zdHJ1Y3RvcihodHRwUmVxdWVzdCwgY29uZmlnID0gZGVmYXVsdENvbmZpZykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhc3NldHNcIiksIF9fcHVibGljRmllbGQodGhpcywgXCJkYXRhc2V0c1wiKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2plY3RzXCIpLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidXNlcnNcIiksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2xpZW50Q29uZmlnLCB2b2lkIDApLCBfX3ByaXZhdGVBZGQodGhpcywgX2h0dHBSZXF1ZXN0LCB2b2lkIDApLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibGlzdGVuXCIsIF9saXN0ZW4pLCB0aGlzLmNvbmZpZyhjb25maWcpLCBfX3ByaXZhdGVTZXQodGhpcywgX2h0dHBSZXF1ZXN0LCBodHRwUmVxdWVzdCksIHRoaXMuYXNzZXRzID0gbmV3IE9ic2VydmFibGVBc3NldHNDbGllbnQodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCkpLCB0aGlzLmRhdGFzZXRzID0gbmV3IE9ic2VydmFibGVEYXRhc2V0c0NsaWVudCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSksIHRoaXMucHJvamVjdHMgPSBuZXcgT2JzZXJ2YWJsZVByb2plY3RzQ2xpZW50KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpKSwgdGhpcy51c2VycyA9IG5ldyBPYnNlcnZhYmxlVXNlcnNDbGllbnQodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCkpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgY2xpZW50IC0gcmV0dXJucyBhIG5ldyBpbnN0YW5jZVxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZVNhbml0eUNsaWVudDIoX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIHRoaXMuY29uZmlnKCkpO1xuICB9XG4gIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgICBpZiAobmV3Q29uZmlnID09PSB2b2lkIDApXG4gICAgICByZXR1cm4geyAuLi5fX3ByaXZhdGVHZXQodGhpcywgX2NsaWVudENvbmZpZykgfTtcbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9jbGllbnRDb25maWcpICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpZW50Q29uZmlnKS5hbGxvd1JlY29uZmlndXJlID09PSAhMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeGlzdGluZyBjbGllbnQgaW5zdGFuY2UgY2Fubm90IGJlIHJlY29uZmlndXJlZCAtIHVzZSBgd2l0aENvbmZpZyhuZXdDb25maWcpYCB0byByZXR1cm4gYSBuZXcgY2xpZW50XCJcbiAgICAgICk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xpZW50Q29uZmlnLCBpbml0Q29uZmlnKG5ld0NvbmZpZywgX19wcml2YXRlR2V0KHRoaXMsIF9jbGllbnRDb25maWcpIHx8IHt9KSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgd2l0aCBhIG5ldyAocGFydGlhbCkgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjbGllbnQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLCBzaGFsbG93bHkgbWVyZ2VkIHdpdGggZXhpc3RpbmcgY29uZmlndXJhdGlvblxuICAgKi9cbiAgd2l0aENvbmZpZyhuZXdDb25maWcpIHtcbiAgICBjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlU2FuaXR5Q2xpZW50MihfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSwge1xuICAgICAgLi4udGhpc0NvbmZpZyxcbiAgICAgIC4uLm5ld0NvbmZpZyxcbiAgICAgIHN0ZWdhOiB7XG4gICAgICAgIC4uLnRoaXNDb25maWcuc3RlZ2EgfHwge30sXG4gICAgICAgIC4uLnR5cGVvZiAobmV3Q29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBuZXdDb25maWcuc3RlZ2EpID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBuZXdDb25maWcuc3RlZ2EgfSA6IChuZXdDb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IG5ld0NvbmZpZy5zdGVnYSkgfHwge31cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmZXRjaChxdWVyeSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9mZXRjaChcbiAgICAgIHRoaXMsXG4gICAgICBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSxcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpZW50Q29uZmlnKS5zdGVnYSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgcGFyYW1zLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgc2luZ2xlIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIElELlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBEb2N1bWVudCBJRCB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnQoaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldERvY3VtZW50KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpLCBpZCwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIG11bHRpcGxlIGRvY3VtZW50cyBpbiBvbmUgcmVxdWVzdC5cbiAgICogU2hvdWxkIGJlIHVzZWQgc3BhcmluZ2x5IC0gcGVyZm9ybWluZyBhIHF1ZXJ5IGlzIHVzdWFsbHkgYSBiZXR0ZXIgb3B0aW9uLlxuICAgKiBUaGUgb3JkZXIvcG9zaXRpb24gb2YgZG9jdW1lbnRzIGlzIHByZXNlcnZlZCBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgSURzLlxuICAgKiBJZiBhbnkgb2YgdGhlIGRvY3VtZW50cyBhcmUgbWlzc2luZywgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgYG51bGxgIGVudHJ5IGluIHRoZSByZXR1cm5lZCBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gaWRzIC0gRG9jdW1lbnQgSURzIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudHMoaWRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXREb2N1bWVudHModGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIGlkcywgb3B0aW9ucyk7XG4gIH1cbiAgY3JlYXRlKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9jcmVhdGUodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIGRvY3VtZW50LCBcImNyZWF0ZVwiLCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGVJZk5vdEV4aXN0cyhkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfY3JlYXRlSWZOb3RFeGlzdHModGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIGRvY3VtZW50LCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGVPclJlcGxhY2UoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZU9yUmVwbGFjZSh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSwgZG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIGRlbGV0ZShzZWxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2RlbGV0ZSh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSwgc2VsZWN0aW9uLCBvcHRpb25zKTtcbiAgfVxuICBtdXRhdGUob3BlcmF0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiBfbXV0YXRlKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpLCBvcGVyYXRpb25zLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGJ1aWxkYWJsZSBwYXRjaCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIERvY3VtZW50IElELCBhbiBhcnJheSBvZiBkb2N1bWVudCBJRHMsIG9yIGFuIG9iamVjdCB3aXRoIGBxdWVyeWAgYW5kIG9wdGlvbmFsIGBwYXJhbXNgLCBkZWZpbmluZyB3aGljaCBkb2N1bWVudChzKSB0byBwYXRjaFxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIE9wdGlvbmFsIG9iamVjdCBvZiBwYXRjaCBvcGVyYXRpb25zIHRvIGluaXRpYWxpemUgdGhlIHBhdGNoIGluc3RhbmNlIHdpdGhcbiAgICogQHJldHVybnMgUGF0Y2ggaW5zdGFuY2UgLSBjYWxsIGAuY29tbWl0KClgIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbnMgZGVmaW5lZFxuICAgKi9cbiAgcGF0Y2goc2VsZWN0aW9uLCBvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUGF0Y2goc2VsZWN0aW9uLCBvcGVyYXRpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHRyYW5zYWN0aW9uIG9mIG11dGF0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIE9wdGlvbmFsIGFycmF5IG9mIG11dGF0aW9uIG9wZXJhdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgdHJhbnNhY3Rpb24gaW5zdGFuY2Ugd2l0aFxuICAgKi9cbiAgdHJhbnNhY3Rpb24ob3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uKG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBhZ2FpbnN0IHRoZSBTYW5pdHkgQVBJXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX3JlcXVlc3QodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIFVSSSBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVVJJL3BhdGggdG8gYnVpbGQgVVJMIGZvclxuICAgKiBAcGFyYW0gY2FuVXNlQ2RuIC0gV2hldGhlciBvciBub3QgdG8gYWxsb3cgdXNpbmcgdGhlIEFQSSBDRE4gZm9yIHRoaXMgcm91dGVcbiAgICovXG4gIGdldFVybCh1cmksIGNhblVzZUNkbikge1xuICAgIHJldHVybiBfZ2V0VXJsKHRoaXMsIHVyaSwgY2FuVXNlQ2RuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBkYXRhIG9wZXJhdGlvbiBhbmQgcGF0aCBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIC0gRGF0YSBvcGVyYXRpb24gKGVnIGBxdWVyeWAsIGBtdXRhdGVgLCBgbGlzdGVuYCBvciBzaW1pbGFyKVxuICAgKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gYXBwZW5kIGFmdGVyIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGdldERhdGFVcmwob3BlcmF0aW9uLCBwYXRoKSB7XG4gICAgcmV0dXJuIF9nZXREYXRhVXJsKHRoaXMsIG9wZXJhdGlvbiwgcGF0aCk7XG4gIH1cbn07XG5fY2xpZW50Q29uZmlnID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIF9odHRwUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IE9ic2VydmFibGVTYW5pdHlDbGllbnQgPSBfT2JzZXJ2YWJsZVNhbml0eUNsaWVudDtcbnZhciBfY2xpZW50Q29uZmlnMiwgX2h0dHBSZXF1ZXN0MjtcbmNvbnN0IF9TYW5pdHlDbGllbnQgPSBjbGFzcyBfU2FuaXR5Q2xpZW50MiB7XG4gIGNvbnN0cnVjdG9yKGh0dHBSZXF1ZXN0LCBjb25maWcgPSBkZWZhdWx0Q29uZmlnKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFzc2V0c1wiKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRhdGFzZXRzXCIpLCBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvamVjdHNcIiksIF9fcHVibGljRmllbGQodGhpcywgXCJ1c2Vyc1wiKSwgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9ic2VydmFibGVcIiksIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2xpZW50Q29uZmlnMiwgdm9pZCAwKSwgX19wcml2YXRlQWRkKHRoaXMsIF9odHRwUmVxdWVzdDIsIHZvaWQgMCksIF9fcHVibGljRmllbGQodGhpcywgXCJsaXN0ZW5cIiwgX2xpc3RlbiksIHRoaXMuY29uZmlnKGNvbmZpZyksIF9fcHJpdmF0ZVNldCh0aGlzLCBfaHR0cFJlcXVlc3QyLCBodHRwUmVxdWVzdCksIHRoaXMuYXNzZXRzID0gbmV3IEFzc2V0c0NsaWVudCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MikpLCB0aGlzLmRhdGFzZXRzID0gbmV3IERhdGFzZXRzQ2xpZW50KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSksIHRoaXMucHJvamVjdHMgPSBuZXcgUHJvamVjdHNDbGllbnQodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpKSwgdGhpcy51c2VycyA9IG5ldyBVc2Vyc0NsaWVudCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MikpLCB0aGlzLm9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVNhbml0eUNsaWVudChodHRwUmVxdWVzdCwgY29uZmlnKTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhlIGNsaWVudCAtIHJldHVybnMgYSBuZXcgaW5zdGFuY2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX1Nhbml0eUNsaWVudDIoX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCB0aGlzLmNvbmZpZygpKTtcbiAgfVxuICBjb25maWcobmV3Q29uZmlnKSB7XG4gICAgaWYgKG5ld0NvbmZpZyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIHsgLi4uX19wcml2YXRlR2V0KHRoaXMsIF9jbGllbnRDb25maWcyKSB9O1xuICAgIGlmIChfX3ByaXZhdGVHZXQodGhpcywgX2NsaWVudENvbmZpZzIpICYmIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpZW50Q29uZmlnMikuYWxsb3dSZWNvbmZpZ3VyZSA9PT0gITEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXhpc3RpbmcgY2xpZW50IGluc3RhbmNlIGNhbm5vdCBiZSByZWNvbmZpZ3VyZWQgLSB1c2UgYHdpdGhDb25maWcobmV3Q29uZmlnKWAgdG8gcmV0dXJuIGEgbmV3IGNsaWVudFwiXG4gICAgICApO1xuICAgIHJldHVybiB0aGlzLm9ic2VydmFibGUgJiYgdGhpcy5vYnNlcnZhYmxlLmNvbmZpZyhuZXdDb25maWcpLCBfX3ByaXZhdGVTZXQodGhpcywgX2NsaWVudENvbmZpZzIsIGluaXRDb25maWcobmV3Q29uZmlnLCBfX3ByaXZhdGVHZXQodGhpcywgX2NsaWVudENvbmZpZzIpIHx8IHt9KSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgd2l0aCBhIG5ldyAocGFydGlhbCkgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjbGllbnQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLCBzaGFsbG93bHkgbWVyZ2VkIHdpdGggZXhpc3RpbmcgY29uZmlndXJhdGlvblxuICAgKi9cbiAgd2l0aENvbmZpZyhuZXdDb25maWcpIHtcbiAgICBjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWcoKTtcbiAgICByZXR1cm4gbmV3IF9TYW5pdHlDbGllbnQyKF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSwge1xuICAgICAgLi4udGhpc0NvbmZpZyxcbiAgICAgIC4uLm5ld0NvbmZpZyxcbiAgICAgIHN0ZWdhOiB7XG4gICAgICAgIC4uLnRoaXNDb25maWcuc3RlZ2EgfHwge30sXG4gICAgICAgIC4uLnR5cGVvZiAobmV3Q29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBuZXdDb25maWcuc3RlZ2EpID09IFwiYm9vbGVhblwiID8geyBlbmFibGVkOiBuZXdDb25maWcuc3RlZ2EgfSA6IChuZXdDb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IG5ld0NvbmZpZy5zdGVnYSkgfHwge31cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmZXRjaChxdWVyeSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfZmV0Y2goXG4gICAgICAgIHRoaXMsXG4gICAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSxcbiAgICAgICAgX19wcml2YXRlR2V0KHRoaXMsIF9jbGllbnRDb25maWcyKS5zdGVnYSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgc2luZ2xlIGRvY3VtZW50IHdpdGggdGhlIGdpdmVuIElELlxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBEb2N1bWVudCBJRCB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnQoaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfZ2V0RG9jdW1lbnQodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBpZCwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBtdWx0aXBsZSBkb2N1bWVudHMgaW4gb25lIHJlcXVlc3QuXG4gICAqIFNob3VsZCBiZSB1c2VkIHNwYXJpbmdseSAtIHBlcmZvcm1pbmcgYSBxdWVyeSBpcyB1c3VhbGx5IGEgYmV0dGVyIG9wdGlvbi5cbiAgICogVGhlIG9yZGVyL3Bvc2l0aW9uIG9mIGRvY3VtZW50cyBpcyBwcmVzZXJ2ZWQgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGFycmF5IG9mIElEcy5cbiAgICogSWYgYW55IG9mIHRoZSBkb2N1bWVudHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSByZXBsYWNlZCBieSBhIGBudWxsYCBlbnRyeSBpbiB0aGUgcmV0dXJuZWQgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIGlkcyAtIERvY3VtZW50IElEcyB0byBmZXRjaFxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKi9cbiAgZ2V0RG9jdW1lbnRzKGlkcywgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9nZXREb2N1bWVudHModGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBpZHMsIG9wdGlvbnMpKTtcbiAgfVxuICBjcmVhdGUoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShcbiAgICAgIF9jcmVhdGUodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBkb2N1bWVudCwgXCJjcmVhdGVcIiwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIGNyZWF0ZUlmTm90RXhpc3RzKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oXG4gICAgICBfY3JlYXRlSWZOb3RFeGlzdHModGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBkb2N1bWVudCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIGNyZWF0ZU9yUmVwbGFjZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKFxuICAgICAgX2NyZWF0ZU9yUmVwbGFjZSh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIGRvY3VtZW50LCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9kZWxldGUodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBzZWxlY3Rpb24sIG9wdGlvbnMpKTtcbiAgfVxuICBtdXRhdGUob3BlcmF0aW9ucywgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9tdXRhdGUodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBvcGVyYXRpb25zLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBidWlsZGFibGUgcGF0Y2ggb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSBEb2N1bWVudCBJRCwgYW4gYXJyYXkgb2YgZG9jdW1lbnQgSURzLCBvciBhbiBvYmplY3Qgd2l0aCBgcXVlcnlgIGFuZCBvcHRpb25hbCBgcGFyYW1zYCwgZGVmaW5pbmcgd2hpY2ggZG9jdW1lbnQocykgdG8gcGF0Y2hcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBPcHRpb25hbCBvYmplY3Qgb2YgcGF0Y2ggb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSBwYXRjaCBpbnN0YW5jZSB3aXRoXG4gICAqIEByZXR1cm5zIFBhdGNoIGluc3RhbmNlIC0gY2FsbCBgLmNvbW1pdCgpYCB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb25zIGRlZmluZWRcbiAgICovXG4gIHBhdGNoKGRvY3VtZW50SWQsIG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBhdGNoKGRvY3VtZW50SWQsIG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gb2YgbXV0YXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgYXJyYXkgb2YgbXV0YXRpb24gb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoXG4gICAqL1xuICB0cmFuc2FjdGlvbihvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbihvcGVyYXRpb25zLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhIHJlcXVlc3QgYWdhaW5zdCB0aGUgU2FuaXR5IEFQSVxuICAgKiBOT1RFOiBPbmx5IHVzZSB0aGlzIGZvciBTYW5pdHkgQVBJIGVuZHBvaW50cywgbm90IGZvciB5b3VyIG93biBBUElzIVxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVzcG9uc2UgYm9keVxuICAgKi9cbiAgcmVxdWVzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX3JlcXVlc3QodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IGEgYC9kYXRhYCBzdWItZW5kcG9pbnRcbiAgICogTk9URTogQ29uc2lkZXJlZCBpbnRlcm5hbCwgdGh1cyBtYXJrZWQgYXMgZGVwcmVjYXRlZC4gVXNlIGByZXF1ZXN0YCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCAtIFVzZSBgcmVxdWVzdCgpYCBvciB5b3VyIG93biBIVFRQIGxpYnJhcnkgaW5zdGVhZFxuICAgKiBAcGFyYW0gZW5kcG9pbnQgLSBFbmRwb2ludCB0byBoaXQgKG11dGF0ZSwgcXVlcnkgZXRjKVxuICAgKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhdGFSZXF1ZXN0KGVuZHBvaW50LCBib2R5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2RhdGFSZXF1ZXN0KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSwgZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBVUkkgcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIHVyaSAtIFVSSS9wYXRoIHRvIGJ1aWxkIFVSTCBmb3JcbiAgICogQHBhcmFtIGNhblVzZUNkbiAtIFdoZXRoZXIgb3Igbm90IHRvIGFsbG93IHVzaW5nIHRoZSBBUEkgQ0ROIGZvciB0aGlzIHJvdXRlXG4gICAqL1xuICBnZXRVcmwodXJpLCBjYW5Vc2VDZG4pIHtcbiAgICByZXR1cm4gX2dldFVybCh0aGlzLCB1cmksIGNhblVzZUNkbik7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIFNhbml0eSBBUEkgVVJMIGZvciB0aGUgZGF0YSBvcGVyYXRpb24gYW5kIHBhdGggcHJvdmlkZWRcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbiAtIERhdGEgb3BlcmF0aW9uIChlZyBgcXVlcnlgLCBgbXV0YXRlYCwgYGxpc3RlbmAgb3Igc2ltaWxhcilcbiAgICogQHBhcmFtIHBhdGggLSBQYXRoIHRvIGFwcGVuZCBhZnRlciB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBnZXREYXRhVXJsKG9wZXJhdGlvbiwgcGF0aCkge1xuICAgIHJldHVybiBfZ2V0RGF0YVVybCh0aGlzLCBvcGVyYXRpb24sIHBhdGgpO1xuICB9XG59O1xuX2NsaWVudENvbmZpZzIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgX2h0dHBSZXF1ZXN0MiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xubGV0IFNhbml0eUNsaWVudCA9IF9TYW5pdHlDbGllbnQ7XG5mdW5jdGlvbiBkZWZpbmVDcmVhdGVDbGllbnRFeHBvcnRzKGVudk1pZGRsZXdhcmUsIENsYXNzQ29uc3RydWN0b3IpIHtcbiAgY29uc3QgZGVmYXVsdFJlcXVlc3RlciA9IGRlZmluZUh0dHBSZXF1ZXN0KGVudk1pZGRsZXdhcmUpO1xuICByZXR1cm4geyByZXF1ZXN0ZXI6IGRlZmF1bHRSZXF1ZXN0ZXIsIGNyZWF0ZUNsaWVudDogKGNvbmZpZykgPT4gbmV3IENsYXNzQ29uc3RydWN0b3IoXG4gICAgKG9wdGlvbnMsIHJlcXVlc3RlcjIpID0+IChyZXF1ZXN0ZXIyIHx8IGRlZmF1bHRSZXF1ZXN0ZXIpKHtcbiAgICAgIG1heFJlZGlyZWN0czogMCxcbiAgICAgIG1heFJldHJpZXM6IGNvbmZpZy5tYXhSZXRyaWVzLFxuICAgICAgcmV0cnlEZWxheTogY29uZmlnLnJldHJ5RGVsYXksXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSksXG4gICAgY29uZmlnXG4gICkgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZURlcHJlY2F0ZWRDcmVhdGVDbGllbnQoY3JlYXRlQ2xpZW50Mikge1xuICByZXR1cm4gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgcmV0dXJuIHByaW50Tm9EZWZhdWx0RXhwb3J0KCksIGNyZWF0ZUNsaWVudDIoY29uZmlnKTtcbiAgfTtcbn1cbnZhciBuYW1lID0gXCJAc2FuaXR5L2NsaWVudFwiLCB2ZXJzaW9uID0gXCI2LjE1LjE5XCI7XG5jb25zdCBtaWRkbGV3YXJlID0gW1xuICBkZWJ1Zyh7IHZlcmJvc2U6ICEwLCBuYW1lc3BhY2U6IFwic2FuaXR5OmNsaWVudFwiIH0pLFxuICBoZWFkZXJzKHsgXCJVc2VyLUFnZW50XCI6IGAke25hbWV9ICR7dmVyc2lvbn1gIH0pLFxuICAvLyBFbmFibGUga2VlcC1hbGl2ZSwgYW5kIGluIGFkZGl0aW9uIGxpbWl0IHRoZSBudW1iZXIgb2Ygc29ja2V0cyB0aGF0IGNhbiBiZSBvcGVuZWQuXG4gIC8vIFRoaXMgYXZvaWRzIG9wZW5pbmcgdG9vIG1hbnkgY29ubmVjdGlvbnMgdG8gdGhlIHNlcnZlciBpZiBzb21lb25lIHRyaWVzIHRvIGV4ZWN1dGVcbiAgLy8gYSBidW5jaCBvZiByZXF1ZXN0cyBpbiBwYXJhbGxlbC4gSXQncyByZWNvbW1lbmRlZCB0byBoYXZlIGEgY29uY3VycmVuY3kgbGltaXRcbiAgLy8gYXQgYSBcImhpZ2hlciBsaW1pdFwiIChpLmUuIHlvdSBzaG91bGRuJ3QgYWN0dWFsbHkgZXhlY3V0ZSBodW5kcmVkcyBvZiByZXF1ZXN0cyBpbiBwYXJhbGxlbCksXG4gIC8vIGFuZCB0aGlzIGlzIG1haW5seSB0byBtaW5pbWl6ZSB0aGUgaW1wYWN0IGZvciB0aGUgbmV0d29yayBhbmQgc2VydmVyLlxuICAvL1xuICAvLyBXZSdyZSBjdXJyZW50bHkgbWF0Y2hpbmcgdGhlIHNhbWUgZGVmYXVsdHMgYXMgYnJvd3NlcnM6XG4gIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MDAzNzU2L2lzLXRoZXJlLWEtbGltaXQtcHJhY3RpY2FsLW9yLW90aGVyd2lzZS10by10aGUtbnVtYmVyLW9mLXdlYi1zb2NrZXRzLWEtcGFnZS1vcFxuICBhZ2VudCh7XG4gICAga2VlcEFsaXZlOiAhMCxcbiAgICBtYXhTb2NrZXRzOiAzMCxcbiAgICBtYXhUb3RhbFNvY2tldHM6IDI1NlxuICB9KVxuXSwgZXhwID0gZGVmaW5lQ3JlYXRlQ2xpZW50RXhwb3J0cyhtaWRkbGV3YXJlLCBTYW5pdHlDbGllbnQpLCByZXF1ZXN0ZXIgPSBleHAucmVxdWVzdGVyLCBjcmVhdGVDbGllbnQgPSBleHAuY3JlYXRlQ2xpZW50LCBkZXByZWNhdGVkQ3JlYXRlQ2xpZW50ID0gZGVmaW5lRGVwcmVjYXRlZENyZWF0ZUNsaWVudChjcmVhdGVDbGllbnQpO1xuZXhwb3J0IHtcbiAgQmFzZVBhdGNoLFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIENsaWVudEVycm9yLFxuICBPYnNlcnZhYmxlUGF0Y2gsXG4gIE9ic2VydmFibGVTYW5pdHlDbGllbnQsXG4gIE9ic2VydmFibGVUcmFuc2FjdGlvbixcbiAgUGF0Y2gsXG4gIFNhbml0eUNsaWVudCxcbiAgU2VydmVyRXJyb3IsXG4gIFRyYW5zYWN0aW9uLFxuICBjcmVhdGVDbGllbnQsXG4gIGRlcHJlY2F0ZWRDcmVhdGVDbGllbnQgYXMgZGVmYXVsdCxcbiAgcmVxdWVzdGVyLFxuICBhZGFwdGVyIGFzIHVuc3RhYmxlX19hZGFwdGVyLFxuICBlbnZpcm9ubWVudCBhcyB1bnN0YWJsZV9fZW52aXJvbm1lbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sanity/client/dist/index.js\n");

/***/ })

};
;